"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => src_default
});
module.exports = __toCommonJS(src_exports);
var import_core = require("@satorijs/core");
var import_node_stream = require("node:stream");
var import_web = require("node:stream/web");
var import_promises = require("node:fs/promises");
var kClient = Symbol("state");
var Client = class {
  static {
    __name(this, "Client");
  }
  authorized = false;
};
function transformKey(source, callback) {
  if (!source || typeof source !== "object")
    return source;
  if (Array.isArray(source))
    return source.map((value) => transformKey(value, callback));
  return Object.fromEntries(Object.entries(source).map(([key, value]) => {
    if (key.startsWith("_"))
      return [key, value];
    return [callback(key), transformKey(value, callback)];
  }));
}
__name(transformKey, "transformKey");
var SatoriServer = class extends import_core.Service {
  constructor(ctx, config) {
    super(ctx, "satori.server", true);
    this.config = config;
    const logger = ctx.logger("server");
    const path = (0, import_core.sanitize)(config.path);
    ctx.server.get(path + "/v1/:name", async (koa, next) => {
      const method = import_core.Universal.Methods[koa.params.name];
      if (!method)
        return next();
      koa.body = "Please use POST method to send requests.";
      koa.status = 405;
    });
    ctx.server.post(path + "/v1/:name", async (koa) => {
      const method = import_core.Universal.Methods[koa.params.name];
      if (!method) {
        koa.body = "method not found";
        koa.status = 404;
        return;
      }
      if (config.token) {
        if (koa.request.headers.authorization !== `Bearer ${config.token}`) {
          koa.body = "invalid token";
          koa.status = 403;
          return;
        }
      }
      const selfId = koa.request.headers["x-self-id"];
      const platform = koa.request.headers["x-platform"];
      const bot = ctx.bots.find((bot2) => bot2.selfId === selfId && bot2.platform === platform);
      if (!bot) {
        koa.body = "login not found";
        koa.status = 403;
        return;
      }
      if (method.name === "createUpload") {
        const entries = Object.entries(koa.request.files ?? {}).map(([key, value]) => {
          return [key, (0, import_core.makeArray)(value)[0]];
        });
        const uploads = await Promise.all(entries.map(async ([, file]) => {
          const buffer2 = await (0, import_promises.readFile)(file.filepath);
          return {
            data: import_core.Binary.fromSource(buffer2),
            type: file.mimetype,
            filename: file.newFilename
          };
        }));
        const result2 = await bot.createUpload(...uploads);
        koa.body = Object.fromEntries(entries.map(([key], index) => [key, result2[index]]));
        koa.status = 200;
        return;
      }
      const json = koa.request.body;
      const args = method.fields.map(({ name }) => {
        return transformKey(json[name], import_core.camelCase);
      });
      const result = await bot[method.name](...args);
      koa.body = transformKey(result, import_core.snakeCase);
      koa.status = 200;
    });
    ctx.server.post(path + "/v1/internal/:name", async (koa) => {
      const selfId = koa.request.headers["x-self-id"];
      const platform = koa.request.headers["x-platform"];
      const bot = ctx.bots.find((bot2) => bot2.selfId === selfId && bot2.platform === platform);
      if (!bot) {
        koa.body = "login not found";
        koa.status = 403;
        return;
      }
      const name = (0, import_core.camelCase)(koa.params.name);
      if (!bot.internal?.[name]) {
        koa.body = "method not found";
        koa.status = 404;
        return;
      }
      const result = await bot.internal[name](...koa.request.body);
      koa.body = result;
      koa.status = 200;
    });
    ctx.server.get(path + "/v1/proxy/:url(.+)", async (koa) => {
      const url = koa.params.url;
      try {
        new URL(url);
      } catch {
        koa.body = "invalid url";
        koa.status = 400;
        return;
      }
      const proxyUrls = ctx.bots.flatMap((bot) => bot.proxyUrls);
      if (!proxyUrls.some((proxyUrl) => url.startsWith(proxyUrl))) {
        koa.body = "forbidden";
        koa.status = 403;
        return;
      }
      koa.header["Access-Control-Allow-Origin"] = ctx.server.config.selfUrl || "*";
      if (url.startsWith("upload://")) {
        const { status, statusText, data, headers } = await ctx.satori.download(url.slice(9));
        koa.status = status;
        for (const [key, value] of headers || new Headers()) {
          koa.set(key, value);
        }
        if (status >= 200 && status < 300) {
          koa.body = data instanceof import_web.ReadableStream ? import_node_stream.Readable.fromWeb(data) : data;
        } else {
          koa.body = statusText;
        }
      } else {
        try {
          koa.body = import_node_stream.Readable.fromWeb(await ctx.http.get(koa.params.url, { responseType: "stream" }));
        } catch (error) {
          if (!ctx.http.isError(error) || !error.response)
            throw error;
          koa.status = error.response.status;
          koa.body = error.response.data;
        }
      }
    });
    const buffer = [];
    const timeout = setInterval(() => {
      while (buffer[0]?.timestamp + config.websocket?.resumeTimeout < Date.now()) {
        buffer.shift();
      }
    }, import_core.Time.second * 10);
    ctx.on("dispose", () => clearInterval(timeout));
    const layer = ctx.server.ws(path + "/v1/events", (socket) => {
      const client = socket[kClient] = new Client();
      socket.addEventListener("message", (event) => {
        let payload;
        try {
          payload = JSON.parse(event.data.toString());
        } catch (error) {
          return socket.close(4e3, "invalid message");
        }
        if (payload.op === import_core.Universal.Opcode.IDENTIFY) {
          if (config.token) {
            if (payload.body?.token !== config.token) {
              return socket.close(4004, "invalid token");
            }
          }
          client.authorized = true;
          socket.send(JSON.stringify({
            op: import_core.Universal.Opcode.READY,
            body: {
              logins: transformKey(ctx.bots.map((bot) => bot.toJSON()), import_core.snakeCase)
            }
          }));
          if (!payload.body?.sequence)
            return;
          for (const session of buffer) {
            if (session.id <= payload.body.sequence)
              continue;
            dispatch(socket, transformKey(session.toJSON(), import_core.snakeCase));
          }
        } else if (payload.op === import_core.Universal.Opcode.PING) {
          socket.send(JSON.stringify({
            op: import_core.Universal.Opcode.PONG,
            body: {}
          }));
        }
      });
    });
    function dispatch(socket, body) {
      socket.send(JSON.stringify({
        op: import_core.Universal.Opcode.EVENT,
        body
      }));
    }
    __name(dispatch, "dispatch");
    ctx.on("internal/session", (session) => {
      const body = transformKey(session.toJSON(), import_core.snakeCase);
      for (const socket of layer.clients) {
        if (!socket[kClient]?.authorized)
          continue;
        dispatch(socket, body);
      }
      for (const webhook of config.webhooks) {
        if (!webhook.enabled)
          continue;
        ctx.http.post(webhook.endpoint, body, {
          headers: webhook.token ? {
            Authorization: `Bearer ${webhook.token}`
          } : {}
        }).catch(logger.warn);
      }
    });
  }
  static {
    __name(this, "SatoriServer");
  }
  static inject = ["server", "http"];
  get url() {
    return (this.ctx.server.config.selfUrl ?? this.ctx.server.selfUrl) + this.config.path;
  }
};
((SatoriServer2) => {
  SatoriServer2.Webhook = import_core.Schema.object({
    enabled: import_core.Schema.boolean().default(true),
    endpoint: import_core.Schema.string(),
    token: import_core.Schema.string()
  });
  SatoriServer2.Config = import_core.Schema.object({
    path: import_core.Schema.string().default("/satori"),
    token: import_core.Schema.string().experimental(),
    api: import_core.Schema.object({
      // enabled: Schema.boolean().default(true),
    }),
    websocket: import_core.Schema.object({
      // enabled: Schema.boolean().default(true),
      resumeTimeout: import_core.Schema.number().default(import_core.Time.minute * 5)
    }),
    webhooks: import_core.Schema.array(SatoriServer2.Webhook)
  });
})(SatoriServer || (SatoriServer = {}));
var src_default = SatoriServer;
//# sourceMappingURL=index.cjs.map
