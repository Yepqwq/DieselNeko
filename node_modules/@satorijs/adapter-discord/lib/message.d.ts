import { Context, Dict, h, MessageEncoder, Schema } from '@satorijs/core';
import { DiscordBot } from './bot';
import { ActionRow, Button } from './types';
export declare class DiscordMessageEncoder<C extends Context = Context> extends MessageEncoder<C, DiscordBot<C>> {
    private stack;
    private buffer;
    private addition;
    private figure;
    private mode;
    private listType;
    private rows;
    private getUrl;
    post(data?: any, headers?: any): any;
    sendEmbed(attrs: Dict, payload: Dict): Promise<any>;
    sendAsset(type: string, attrs: Dict<string>, addition: Dict): Promise<any>;
    checkMediaType(url: string, type: string): true | Promise<boolean>;
    ensureWebhook(): Promise<import("./types").Webhook>;
    flush(): Promise<void>;
    decodeButton(attrs: Dict, label: string): Button;
    lastRow(): ActionRow;
    trimButtons(): void;
    visit(element: h): Promise<void>;
}
export declare namespace DiscordMessageEncoder {
    type HandleExternalAsset = 'auto' | 'download' | 'direct';
    type HandleMixedContent = 'auto' | 'separate' | 'attach';
    interface Config {
        /**
         * 发送外链资源时采用的方式
         * - download：先下载后发送
         * - direct：直接发送链接
         * - auto：发送一个 HEAD 请求，如果返回的 Content-Type 正确，则直接发送链接，否则先下载后发送（默认）
         */
        handleExternalAsset?: HandleExternalAsset;
        /**
         * 发送图文等混合内容时采用的方式
         * - separate：将每个不同形式的内容分开发送
         * - attach：图片前如果有文本内容，则将文本作为图片的附带信息进行发送
         * - auto：如果图片本身采用直接发送则与前面的文本分开，否则将文本作为图片的附带信息发送（默认）
         */
        handleMixedContent?: HandleMixedContent;
    }
    const Config: Schema<DiscordMessageEncoder.Config>;
}
