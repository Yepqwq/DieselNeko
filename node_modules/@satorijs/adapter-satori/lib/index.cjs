var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  SatoriAdapter: () => SatoriAdapter,
  SatoriBot: () => SatoriBot,
  default: () => src_default,
  transformKey: () => transformKey
});
module.exports = __toCommonJS(src_exports);

// src/ws.ts
var import_core2 = require("@satorijs/core");

// src/bot.ts
var import_core = require("@satorijs/core");
function transformKey(source, callback) {
  if (!source || typeof source !== "object")
    return source;
  if (Array.isArray(source))
    return source.map((value) => transformKey(value, callback));
  return Object.fromEntries(Object.entries(source).map(([key, value]) => {
    if (key.startsWith("_"))
      return [key, value];
    return [callback(key), transformKey(value, callback)];
  }));
}
__name(transformKey, "transformKey");
function createInternal(bot, prefix = "") {
  return new Proxy(() => {
  }, {
    apply(target, thisArg, args) {
      const key = (0, import_core.snakeCase)(prefix.slice(1));
      bot.logger.debug("[request.internal]", key, args);
      return bot.http.post("/v1/internal/" + key, args);
    },
    get(target, key, receiver) {
      if (typeof key === "symbol" || key in target) {
        return Reflect.get(target, key, receiver);
      }
      return createInternal(bot, prefix + "." + key);
    }
  });
}
__name(createInternal, "createInternal");
var SatoriBot = class extends import_core.Bot {
  static {
    __name(this, "SatoriBot");
  }
  http;
  internal = createInternal(this);
  constructor(ctx, config) {
    super(ctx, config, "satori");
    Object.assign(this, config);
  }
};
for (const [key, method] of Object.entries(import_core.Universal.Methods)) {
  SatoriBot.prototype[method.name] = async function(...args) {
    const payload = {};
    for (const [index, field] of method.fields.entries()) {
      if (method.name === "createMessage" && field.name === "content") {
        const session = this.session({
          type: "send",
          channel: { id: args[0], type: 0 },
          ...args[3]?.session?.event
        });
        session.elements = await session.transform(import_core.h.normalize(args[index]));
        if (await session.app.serial(session, "before-send", session, args[3] ?? {}))
          return;
        payload[field.name] = session.elements.join("");
      } else {
        payload[field.name] = transformKey(args[index], import_core.snakeCase);
      }
    }
    this.logger.debug("[request]", key, payload);
    const result = await this.http.post("/v1/" + key, payload);
    return transformKey(result, import_core.camelCase);
  };
}

// src/ws.ts
var SatoriAdapter = class extends import_core2.Adapter.WsClientBase {
  constructor(ctx, config) {
    super(ctx, config);
    this.ctx = ctx;
    this.config = config;
    this.logger = ctx.logger("satori");
    this.http = ctx.http.extend({
      endpoint: config.endpoint,
      headers: {
        "Authorization": `Bearer ${config.token}`
      }
    });
    ctx.on("ready", () => this.start());
    ctx.on("dispose", () => this.stop());
  }
  static {
    __name(this, "SatoriAdapter");
  }
  static schema = true;
  static reusable = true;
  static inject = ["http"];
  http;
  logger;
  _status = import_core2.Universal.Status.OFFLINE;
  sequence;
  timeout;
  getActive() {
    return this._status !== import_core2.Universal.Status.OFFLINE && this._status !== import_core2.Universal.Status.DISCONNECT;
  }
  setStatus(status, error) {
    this._status = status;
    if (status === import_core2.Universal.Status.ONLINE)
      return;
    for (const bot of this.bots) {
      bot.status = status;
      bot.error = error;
    }
  }
  async prepare() {
    return this.http.ws("/v1/events");
  }
  getBot(platform, selfId, login) {
    let bot = this.bots.find((bot2) => bot2.selfId === selfId && bot2.platform === platform);
    if (bot) {
      if (login)
        bot.update(login);
      return this.bots.includes(bot) ? bot : void 0;
    }
    if (!login) {
      this.logger.error("cannot find bot for", platform, selfId);
      return;
    }
    bot = new SatoriBot(this.ctx, login);
    this.bots.push(bot);
    bot.adapter = this;
    bot.http = this.http.extend({
      headers: {
        "X-Platform": platform,
        "X-Self-ID": selfId
      }
    });
    bot.status = login.status;
  }
  accept() {
    this.socket.send(JSON.stringify({
      op: import_core2.Universal.Opcode.IDENTIFY,
      body: {
        token: this.config.token,
        sequence: this.sequence
      }
    }));
    this.timeout = setInterval(() => {
      this.socket.send(JSON.stringify({
        op: import_core2.Universal.Opcode.PING,
        body: {}
      }));
    }, import_core2.Time.second * 10);
    this.socket.addEventListener("message", async ({ data }) => {
      let parsed;
      data = data.toString();
      try {
        parsed = transformKey(JSON.parse(data), import_core2.camelize);
      } catch (error) {
        return this.logger.warn("cannot parse message", data);
      }
      if (parsed.op === import_core2.Universal.Opcode.READY) {
        this.logger.debug("ready");
        for (const login of parsed.body.logins) {
          this.getBot(login.platform, login.selfId, login);
        }
      }
      if (parsed.op === import_core2.Universal.Opcode.EVENT) {
        const { id, type, selfId, platform, login } = parsed.body;
        this.sequence = id;
        const bot = this.getBot(platform, selfId, type === "login-added" && login);
        if (!bot)
          return;
        if (type === "login-updated") {
          return bot.update(login);
        } else if (type === "login-removed") {
          return bot.dispose();
        }
        const session = bot.session(parsed.body);
        if (typeof parsed.body.message?.content === "string") {
          session.content = parsed.body.message.content;
        }
        if (parsed.body._type && parsed.body.type !== "internal") {
          session.setInternal(parsed.body._type, parsed.body._data);
        }
        bot.dispatch(session);
        if (type === "message-created" && session.userId === selfId) {
          session.app.emit(session, "send", session);
        }
      }
    });
    this.socket.addEventListener("close", () => {
      clearInterval(this.timeout);
    });
  }
  async start() {
    this.setStatus(import_core2.Universal.Status.CONNECT);
    await super.start();
  }
  async stop() {
    this.setStatus(import_core2.Universal.Status.DISCONNECT);
    await super.stop();
  }
};
((SatoriAdapter2) => {
  SatoriAdapter2.Config = import_core2.Schema.intersect([
    import_core2.Schema.object({
      endpoint: import_core2.Schema.string().description("API 终结点。").required(),
      token: import_core2.Schema.string().description("API 访问令牌。")
    }),
    import_core2.Adapter.WsClientConfig
  ]);
})(SatoriAdapter || (SatoriAdapter = {}));

// src/index.ts
var src_default = SatoriAdapter;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  SatoriAdapter,
  SatoriBot,
  transformKey
});
//# sourceMappingURL=index.cjs.map
