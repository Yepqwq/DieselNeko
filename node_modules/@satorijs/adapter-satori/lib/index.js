var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// src/ws.ts
import { Adapter, camelize, Schema, Time, Universal as Universal2 } from "@satorijs/core";

// src/bot.ts
import { Bot, camelCase, h, snakeCase, Universal } from "@satorijs/core";
function transformKey(source, callback) {
  if (!source || typeof source !== "object")
    return source;
  if (Array.isArray(source))
    return source.map((value) => transformKey(value, callback));
  return Object.fromEntries(Object.entries(source).map(([key, value]) => {
    if (key.startsWith("_"))
      return [key, value];
    return [callback(key), transformKey(value, callback)];
  }));
}
__name(transformKey, "transformKey");
function createInternal(bot, prefix = "") {
  return new Proxy(() => {
  }, {
    apply(target, thisArg, args) {
      const key = snakeCase(prefix.slice(1));
      bot.logger.debug("[request.internal]", key, args);
      return bot.http.post("/v1/internal/" + key, args);
    },
    get(target, key, receiver) {
      if (typeof key === "symbol" || key in target) {
        return Reflect.get(target, key, receiver);
      }
      return createInternal(bot, prefix + "." + key);
    }
  });
}
__name(createInternal, "createInternal");
var SatoriBot = class extends Bot {
  static {
    __name(this, "SatoriBot");
  }
  http;
  internal = createInternal(this);
  constructor(ctx, config) {
    super(ctx, config, "satori");
    Object.assign(this, config);
  }
};
for (const [key, method] of Object.entries(Universal.Methods)) {
  SatoriBot.prototype[method.name] = async function(...args) {
    const payload = {};
    for (const [index, field] of method.fields.entries()) {
      if (method.name === "createMessage" && field.name === "content") {
        const session = this.session({
          type: "send",
          channel: { id: args[0], type: 0 },
          ...args[3]?.session?.event
        });
        session.elements = await session.transform(h.normalize(args[index]));
        if (await session.app.serial(session, "before-send", session, args[3] ?? {}))
          return;
        payload[field.name] = session.elements.join("");
      } else {
        payload[field.name] = transformKey(args[index], snakeCase);
      }
    }
    this.logger.debug("[request]", key, payload);
    const result = await this.http.post("/v1/" + key, payload);
    return transformKey(result, camelCase);
  };
}

// src/ws.ts
var SatoriAdapter = class extends Adapter.WsClientBase {
  constructor(ctx, config) {
    super(ctx, config);
    this.ctx = ctx;
    this.config = config;
    this.logger = ctx.logger("satori");
    this.http = ctx.http.extend({
      endpoint: config.endpoint,
      headers: {
        "Authorization": `Bearer ${config.token}`
      }
    });
    ctx.on("ready", () => this.start());
    ctx.on("dispose", () => this.stop());
  }
  static {
    __name(this, "SatoriAdapter");
  }
  static schema = true;
  static reusable = true;
  static inject = ["http"];
  http;
  logger;
  _status = Universal2.Status.OFFLINE;
  sequence;
  timeout;
  getActive() {
    return this._status !== Universal2.Status.OFFLINE && this._status !== Universal2.Status.DISCONNECT;
  }
  setStatus(status, error) {
    this._status = status;
    if (status === Universal2.Status.ONLINE)
      return;
    for (const bot of this.bots) {
      bot.status = status;
      bot.error = error;
    }
  }
  async prepare() {
    return this.http.ws("/v1/events");
  }
  getBot(platform, selfId, login) {
    let bot = this.bots.find((bot2) => bot2.selfId === selfId && bot2.platform === platform);
    if (bot) {
      if (login)
        bot.update(login);
      return this.bots.includes(bot) ? bot : void 0;
    }
    if (!login) {
      this.logger.error("cannot find bot for", platform, selfId);
      return;
    }
    bot = new SatoriBot(this.ctx, login);
    this.bots.push(bot);
    bot.adapter = this;
    bot.http = this.http.extend({
      headers: {
        "X-Platform": platform,
        "X-Self-ID": selfId
      }
    });
    bot.status = login.status;
  }
  accept() {
    this.socket.send(JSON.stringify({
      op: Universal2.Opcode.IDENTIFY,
      body: {
        token: this.config.token,
        sequence: this.sequence
      }
    }));
    this.timeout = setInterval(() => {
      this.socket.send(JSON.stringify({
        op: Universal2.Opcode.PING,
        body: {}
      }));
    }, Time.second * 10);
    this.socket.addEventListener("message", async ({ data }) => {
      let parsed;
      data = data.toString();
      try {
        parsed = transformKey(JSON.parse(data), camelize);
      } catch (error) {
        return this.logger.warn("cannot parse message", data);
      }
      if (parsed.op === Universal2.Opcode.READY) {
        this.logger.debug("ready");
        for (const login of parsed.body.logins) {
          this.getBot(login.platform, login.selfId, login);
        }
      }
      if (parsed.op === Universal2.Opcode.EVENT) {
        const { id, type, selfId, platform, login } = parsed.body;
        this.sequence = id;
        const bot = this.getBot(platform, selfId, type === "login-added" && login);
        if (!bot)
          return;
        if (type === "login-updated") {
          return bot.update(login);
        } else if (type === "login-removed") {
          return bot.dispose();
        }
        const session = bot.session(parsed.body);
        if (typeof parsed.body.message?.content === "string") {
          session.content = parsed.body.message.content;
        }
        if (parsed.body._type && parsed.body.type !== "internal") {
          session.setInternal(parsed.body._type, parsed.body._data);
        }
        bot.dispatch(session);
        if (type === "message-created" && session.userId === selfId) {
          session.app.emit(session, "send", session);
        }
      }
    });
    this.socket.addEventListener("close", () => {
      clearInterval(this.timeout);
    });
  }
  async start() {
    this.setStatus(Universal2.Status.CONNECT);
    await super.start();
  }
  async stop() {
    this.setStatus(Universal2.Status.DISCONNECT);
    await super.stop();
  }
};
((SatoriAdapter2) => {
  SatoriAdapter2.Config = Schema.intersect([
    Schema.object({
      endpoint: Schema.string().description("API 终结点。").required(),
      token: Schema.string().description("API 访问令牌。")
    }),
    Adapter.WsClientConfig
  ]);
})(SatoriAdapter || (SatoriAdapter = {}));

// src/index.ts
var src_default = SatoriAdapter;
export {
  SatoriAdapter,
  SatoriBot,
  src_default as default,
  transformKey
};
//# sourceMappingURL=index.js.map
