import { Context, Service, Logger, z } from 'cordis';
import { Message, SendOptions, Event, GuildMember, User, Login, Methods, Response, Status, Upload, WebSocket } from '@satorijs/protocol';
import h from '@satorijs/element';
import { Dict, Awaitable } from 'cosmokit';
import { HTTP } from '@cordisjs/plugin-http';
export abstract class MessageEncoder<C extends Context = Context, B extends Bot<C> = Bot<C>> {
    bot: B;
    channelId: string;
    guildId?: string;
    options: SendOptions;
    errors: Error[];
    results: Message[];
    session: C[typeof Context.session];
    constructor(bot: B, channelId: string, guildId?: string, options?: SendOptions);
    prepare(): Promise<void>;
    abstract flush(): Promise<void>;
    abstract visit(element: h): Promise<void>;
    render(elements: h[], flush?: boolean): Promise<void>;
    send(content: h.Fragment): Promise<Message[]>;
}
export { MessageEncoder as Modulator, MessageEncoder as Messenger };
declare module '@satorijs/protocol' {
    interface SendOptions {
        session?: Session;
    }
}
export interface Session {
    type: string;
    subtype: string;
    subsubtype: string;
    selfId: string;
    platform: string;
    timestamp: number;
    userId: string;
    channelId: string;
    guildId: string;
    messageId: string;
    operatorId: string;
    roleId: string;
    quote: Message;
}
export class Session<C extends Context = Context> {
    static counter: number;
    [Service.tracker]: {
        associate: string;
        property: string;
    };
    id: number;
    bot: Bot<C>;
    app: C['root'];
    event: Event;
    locales: string[];
    constructor(bot: Bot<C>, event: Partial<Event>);
    /** @deprecated */
    get data(): Event;
    get isDirect(): boolean;
    set isDirect(value: boolean);
    get author(): GuildMember & User;
    get uid(): string;
    get gid(): string;
    get cid(): string;
    get fid(): string;
    get sid(): string;
    get elements(): h[];
    set elements(value: h[]);
    get content(): string | undefined;
    set content(value: string | undefined);
    setInternal(type: string, data: any): void;
    transform(elements: h[]): Promise<h[]>;
    toJSON(): Event;
}
export function defineAccessor(prototype: {}, name: string, keys: string[]): void;
export interface Bot extends Methods {
    userId: string;
    selfId: string;
    internal: any;
}
export abstract class Bot<C extends Context = Context, T = any> implements Login {
    ctx: C;
    config: T;
    static reusable: boolean;
    static MessageEncoder?: new (bot: Bot, channelId: string, guildId?: string, options?: SendOptions) => MessageEncoder;
    [Service.tracker]: {
        associate: string;
        property: string;
    };
    user: User;
    isBot: boolean;
    hidden: boolean;
    platform: string;
    features: string[];
    proxyUrls: string[];
    adapter?: Adapter<C, this>;
    error?: Error;
    callbacks: Dict<Function>;
    logger: Logger;
    protected context: Context;
    protected _status: Status;
    constructor(ctx: C, config: T, platform?: string);
    registerUpload(path: string, callback: (path: string) => Promise<Response>): void;
    update(login: Login): void;
    dispose(): Promise<void>;
    private dispatchLoginEvent;
    get status(): Status;
    set status(value: Status);
    get isActive(): boolean;
    online(): void;
    offline(error?: Error): void;
    start(): Promise<void>;
    stop(): Promise<void>;
    get sid(): string;
    session(event?: Partial<Event>): C[typeof Context.session];
    dispatch(session: C[typeof Context.session]): void;
    createMessage(channelId: string, content: h.Fragment, guildId?: string, options?: SendOptions): Promise<import("@satorijs/protocol").Message[]>;
    sendMessage(channelId: string, content: h.Fragment, guildId?: string, options?: SendOptions): Promise<string[]>;
    sendPrivateMessage(userId: string, content: h.Fragment, guildId?: string, options?: SendOptions): Promise<string[]>;
    createUpload(...uploads: Upload[]): Promise<string[]>;
    supports(name: string, session?: Partial<C[typeof Context.session]>): Promise<boolean>;
    checkPermission(name: string, session: Partial<C[typeof Context.session]>): Promise<boolean>;
    toJSON(): Login;
    getLogin(): Promise<Login>;
    /** @deprecated use `bot.getLogin()` instead */
    getSelf(): Promise<User>;
}
export abstract class Adapter<C extends Context = Context, B extends Bot<C> = Bot<C>> {
    protected ctx: C;
    static schema: false;
    bots: B[];
    constructor(ctx: C);
    connect(bot: B): Promise<void>;
    disconnect(bot: B): Promise<void>;
    fork(ctx: Context, bot: B): void;
}
export namespace Adapter {
    interface WsClientConfig {
        retryLazy?: number;
        retryTimes?: number;
        retryInterval?: number;
    }
    const WsClientConfig: z<WsClientConfig>;
    abstract class WsClientBase<C extends Context, B extends Bot<C>> extends Adapter<C, B> {
        config: WsClientConfig;
        protected socket: WebSocket;
        protected abstract prepare(): Awaitable<WebSocket>;
        protected abstract accept(socket: WebSocket): void;
        protected abstract getActive(): boolean;
        protected abstract setStatus(status: Status, error?: Error): void;
        constructor(ctx: C, config: WsClientConfig);
        start(): Promise<void>;
        stop(): Promise<void>;
    }
    abstract class WsClient<C extends Context, B extends Bot<C, WsClientConfig>> extends WsClientBase<C, B> {
        bot: B;
        static reusable: boolean;
        constructor(ctx: C, bot: B);
        getActive(): boolean;
        setStatus(status: Status, error?: Error): void;
        connect(bot: B): Promise<void>;
        disconnect(bot: B): Promise<void>;
    }
}
export type { Fragment, Render } from '@satorijs/element';
export { h, h as Element, h as segment, HTTP, HTTP as Quester };
export * from 'cordis';
export * from 'cosmokit';
export * as Universal from '@satorijs/protocol';
declare module 'cordis' {
    interface Context {
        [Context.session]: Session<this>;
        satori: Satori<this>;
        bots: Bot<this>[] & Dict<Bot<this>>;
        component(name: string, component: Component<GetSession<this>>, options?: Component.Options): () => void;
    }
    namespace Context {
        const session: unique symbol;
    }
    interface Events<C> {
        'internal/session'(session: GetSession<C>): void;
        'interaction/command'(session: GetSession<C>): void;
        'interaction/button'(session: GetSession<C>): void;
        'message'(session: GetSession<C>): void;
        'message-created'(session: GetSession<C>): void;
        'message-deleted'(session: GetSession<C>): void;
        'message-updated'(session: GetSession<C>): void;
        'message-pinned'(session: GetSession<C>): void;
        'message-unpinned'(session: GetSession<C>): void;
        'guild-added'(session: GetSession<C>): void;
        'guild-removed'(session: GetSession<C>): void;
        'guild-updated'(session: GetSession<C>): void;
        'guild-member-added'(session: GetSession<C>): void;
        'guild-member-removed'(session: GetSession<C>): void;
        'guild-member-updated'(session: GetSession<C>): void;
        'guild-role-created'(session: GetSession<C>): void;
        'guild-role-deleted'(session: GetSession<C>): void;
        'guild-role-updated'(session: GetSession<C>): void;
        'reaction-added'(session: GetSession<C>): void;
        'reaction-removed'(session: GetSession<C>): void;
        'login-added'(session: GetSession<C>): void;
        'login-removed'(session: GetSession<C>): void;
        'login-updated'(session: GetSession<C>): void;
        'friend-request'(session: GetSession<C>): void;
        'guild-request'(session: GetSession<C>): void;
        'guild-member-request'(session: GetSession<C>): void;
        'before-send'(session: GetSession<C>, options: SendOptions): Awaitable<void | boolean>;
        'send'(session: GetSession<C>): void;
        /** @deprecated use `login-added` instead */
        'bot-added'(client: Bot<C>): void;
        /** @deprecated use `login-removed` instead */
        'bot-removed'(client: Bot<C>): void;
        /** @deprecated use `login-updated` instead */
        'bot-status-updated'(client: Bot<C>): void;
        'bot-connect'(client: Bot<C>): Awaitable<void>;
        'bot-disconnect'(client: Bot<C>): Awaitable<void>;
    }
}
declare module '@cordisjs/plugin-http' {
    namespace HTTP {
        function createConfig(this: typeof HTTP, endpoint?: string | boolean): z<Config>;
    }
}
export type Component<S extends Session = Session> = h.Render<Awaitable<h.Fragment>, S>;
export namespace Component {
    interface Options {
        session?: boolean;
    }
}
export type GetSession<C extends Context> = C[typeof Context.session];
declare class SatoriContext extends Context {
    constructor(config?: any);
}
export { SatoriContext as Context };
export interface UploadRoute {
    path: string | string[] | (() => string | string[]);
    callback: (path: string) => Promise<Response>;
}
export class Satori<C extends Context = Context> extends Service<unknown, C> {
    static [Service.provide]: string;
    static [Service.immediate]: boolean;
    uid: string;
    _uploadRoutes: UploadRoute[];
    _tempStore: Dict<Response>;
    constructor(ctx?: C);
    bots: Bot<C>[] & Dict<Bot<C>>;
    component(name: string, component: Component<C[typeof Context.session]>, options?: Component.Options): () => void;
    upload(path: UploadRoute['path'], callback: UploadRoute['callback'], proxyUrls?: UploadRoute['path'][]): () => void;
    download(path: string): Promise<Response>;
}
export default Satori;
