var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Adapter: () => Adapter,
  Bot: () => Bot,
  Context: () => SatoriContext,
  Element: () => import_element3.default,
  HTTP: () => import_plugin_http.HTTP,
  MessageEncoder: () => MessageEncoder,
  Messenger: () => MessageEncoder,
  Modulator: () => MessageEncoder,
  Quester: () => import_plugin_http.HTTP,
  Satori: () => Satori,
  Session: () => Session,
  Universal: () => Universal,
  default: () => src_default,
  defineAccessor: () => defineAccessor,
  h: () => import_element3.default,
  segment: () => import_element3.default
});
module.exports = __toCommonJS(src_exports);
var import_cordis4 = require("cordis");
var import_cosmokit4 = require("cosmokit");
var import_plugin_http = require("@cordisjs/plugin-http");
var import_element3 = __toESM(require("@satorijs/element"), 1);
__reExport(src_exports, require("cordis"), module.exports);
__reExport(src_exports, require("cosmokit"), module.exports);
var Universal = __toESM(require("@satorijs/protocol"), 1);

// src/bot.ts
var import_cosmokit2 = require("cosmokit");
var import_cordis2 = require("cordis");

// src/session.ts
var import_protocol = require("@satorijs/protocol");
var import_cosmokit = require("cosmokit");
var import_cordis = require("cordis");
var import_element = __toESM(require("@satorijs/element"), 1);
var Session = class _Session {
  static {
    __name(this, "Session");
  }
  static counter = 0;
  [import_cordis.Service.tracker] = {
    associate: "session",
    property: "ctx"
  };
  id;
  bot;
  app;
  event;
  locales = [];
  constructor(bot, event) {
    event.selfId ??= bot.selfId;
    event.platform ??= bot.platform;
    event.timestamp ??= Date.now();
    this.event = event;
    this.id = ++_Session.counter;
    (0, import_cosmokit.defineProperty)(this, "bot", bot);
    (0, import_cosmokit.defineProperty)(this, "app", bot.ctx.root);
    (0, import_cosmokit.defineProperty)(this, import_cordis.Context.current, bot.ctx);
    return import_cordis.Context.associate(this, "session");
  }
  /** @deprecated */
  get data() {
    return this.event;
  }
  get isDirect() {
    return this.event.channel.type === import_protocol.Channel.Type.DIRECT;
  }
  set isDirect(value) {
    (this.event.channel ??= {}).type = value ? import_protocol.Channel.Type.DIRECT : import_protocol.Channel.Type.TEXT;
  }
  get author() {
    return {
      ...this.event.user,
      ...this.event.member,
      userId: this.event.user?.id,
      username: this.event.user?.name,
      nickname: this.event.member?.name
    };
  }
  get uid() {
    return `${this.platform}:${this.userId}`;
  }
  get gid() {
    return `${this.platform}:${this.guildId}`;
  }
  get cid() {
    return `${this.platform}:${this.channelId}`;
  }
  get fid() {
    return `${this.platform}:${this.channelId}:${this.userId}`;
  }
  get sid() {
    return `${this.platform}:${this.selfId}`;
  }
  get elements() {
    return this.event.message?.elements;
  }
  set elements(value) {
    this.event.message ??= {};
    this.event.message.elements = value;
  }
  get content() {
    return this.event.message?.elements?.join("");
  }
  set content(value) {
    this.event.message ??= {};
    this.event.message.elements = (0, import_cosmokit.isNullable)(value) ? value : import_element.default.parse(value);
  }
  setInternal(type, data) {
    this.event._type = type;
    this.event._data = data;
    const internal = Object.create(this.bot.internal);
    (0, import_cosmokit.defineProperty)(this, type, Object.assign(internal, data));
  }
  async transform(elements) {
    return await import_element.default.transformAsync(elements, ({ type, attrs, children }, session) => {
      const render = type === "component" ? attrs.is : this.app.get("component:" + type);
      return render?.(attrs, children, session) ?? true;
    }, this);
  }
  toJSON() {
    return { ...this.event, id: this.id };
  }
};
function defineAccessor(prototype, name, keys) {
  Object.defineProperty(prototype, name, {
    get() {
      return keys.reduce((data, key) => data?.[key], this);
    },
    set(value) {
      if (value === void 0)
        return;
      const _keys = keys.slice();
      const last = _keys.pop();
      const data = _keys.reduce((data2, key) => data2[key] ??= {}, this);
      data[last] = value;
    }
  });
}
__name(defineAccessor, "defineAccessor");
defineAccessor(Session.prototype, "type", ["event", "type"]);
defineAccessor(Session.prototype, "subtype", ["event", "subtype"]);
defineAccessor(Session.prototype, "subsubtype", ["event", "subsubtype"]);
defineAccessor(Session.prototype, "selfId", ["event", "selfId"]);
defineAccessor(Session.prototype, "platform", ["event", "platform"]);
defineAccessor(Session.prototype, "timestamp", ["event", "timestamp"]);
defineAccessor(Session.prototype, "userId", ["event", "user", "id"]);
defineAccessor(Session.prototype, "channelId", ["event", "channel", "id"]);
defineAccessor(Session.prototype, "channelName", ["event", "channel", "name"]);
defineAccessor(Session.prototype, "guildId", ["event", "guild", "id"]);
defineAccessor(Session.prototype, "guildName", ["event", "guild", "name"]);
defineAccessor(Session.prototype, "messageId", ["event", "message", "id"]);
defineAccessor(Session.prototype, "operatorId", ["event", "operator", "id"]);
defineAccessor(Session.prototype, "roleId", ["event", "role", "id"]);
defineAccessor(Session.prototype, "quote", ["event", "message", "quote"]);

// src/bot.ts
var import_protocol2 = require("@satorijs/protocol");
var eventAliases = [
  ["message-created", "message"],
  ["guild-removed", "guild-deleted"],
  ["guild-member-removed", "guild-member-deleted"]
];
var Bot = class {
  constructor(ctx, config, platform) {
    this.ctx = ctx;
    this.config = config;
    this.internal = null;
    this.context = ctx;
    ctx.bots.push(this);
    this.context.emit("bot-added", this);
    if (platform) {
      this.logger = ctx.logger(platform);
      this.platform = platform;
    }
    this.proxyUrls = [`upload://temp/${ctx.satori.uid}/`];
    this.features = Object.entries(import_protocol2.Methods).filter(([, value]) => this[value.name]).map(([key]) => key);
    ctx.on("ready", async () => {
      await Promise.resolve();
      this.dispatchLoginEvent("login-added");
      return this.start();
    });
    ctx.on("dispose", () => this.dispose());
    ctx.on("interaction/button", (session) => {
      const cb = this.callbacks[session.event.button.id];
      if (cb)
        cb(session);
    });
  }
  static {
    __name(this, "Bot");
  }
  static reusable = true;
  static MessageEncoder;
  [import_cordis2.Service.tracker] = {
    associate: "bot",
    property: "ctx"
  };
  user = {};
  isBot = true;
  hidden = false;
  platform;
  features;
  proxyUrls;
  adapter;
  error;
  callbacks = {};
  logger;
  // Same as `this.ctx`, but with a more specific type.
  context;
  _status = import_protocol2.Status.OFFLINE;
  registerUpload(path, callback) {
    this.ctx.satori.upload(path, callback, this.proxyUrls);
  }
  update(login) {
    const { status, ...rest } = login;
    Object.assign(this, rest);
    this.status = status;
  }
  dispose() {
    const index = this.ctx.bots.findIndex((bot) => bot.sid === this.sid);
    if (index >= 0) {
      this.ctx.bots.splice(index, 1);
      this.context.emit("bot-removed", this);
      this.dispatchLoginEvent("login-removed");
    }
    return this.stop();
  }
  dispatchLoginEvent(type) {
    const session = this.session();
    session.type = type;
    session.event.login = this.toJSON();
    this.dispatch(session);
  }
  get status() {
    return this._status;
  }
  set status(value) {
    if (value === this._status)
      return;
    this._status = value;
    if (this.ctx.bots?.some((bot) => bot.sid === this.sid)) {
      this.context.emit("bot-status-updated", this);
      this.dispatchLoginEvent("login-updated");
    }
  }
  get isActive() {
    return this._status !== import_protocol2.Status.OFFLINE && this._status !== import_protocol2.Status.DISCONNECT;
  }
  online() {
    this.status = import_protocol2.Status.ONLINE;
    this.error = null;
  }
  offline(error) {
    this.status = import_protocol2.Status.OFFLINE;
    this.error = error;
  }
  async start() {
    if (this.isActive)
      return;
    this.status = import_protocol2.Status.CONNECT;
    try {
      await this.context.parallel("bot-connect", this);
      await this.adapter?.connect(this);
    } catch (error) {
      this.offline(error);
    }
  }
  async stop() {
    if (!this.isActive)
      return;
    this.status = import_protocol2.Status.DISCONNECT;
    try {
      await this.context.parallel("bot-disconnect", this);
      await this.adapter?.disconnect(this);
    } catch (error) {
      this.context.emit(this.ctx, "internal/error", error);
    } finally {
      this.offline();
    }
  }
  get sid() {
    return `${this.platform}:${this.selfId}`;
  }
  session(event = {}) {
    return new Session(this, event);
  }
  dispatch(session) {
    if (!this.ctx.lifecycle.isActive)
      return;
    let events = [session.type];
    for (const aliases of eventAliases) {
      if (aliases.includes(session.type)) {
        events = aliases;
        session.type = aliases[0];
        break;
      }
    }
    this.context.emit("internal/session", session);
    if (session.type === "internal") {
      this.context.emit(session.event._type, session.event._data, session.bot);
      return;
    }
    for (const event of events) {
      this.context.emit(session, event, session);
    }
  }
  async createMessage(channelId, content, guildId, options) {
    const { MessageEncoder: MessageEncoder2 } = this.constructor;
    return new MessageEncoder2(this, channelId, guildId, options).send(content);
  }
  async sendMessage(channelId, content, guildId, options) {
    const messages = await this.createMessage(channelId, content, guildId, options);
    return messages.map((message) => message.id);
  }
  async sendPrivateMessage(userId, content, guildId, options) {
    const { id } = await this.createDirectChannel(userId, guildId ?? options?.session?.guildId);
    return this.sendMessage(id, content, null, options);
  }
  async createUpload(...uploads) {
    const ids = [];
    for (const upload of uploads) {
      const id = Math.random().toString(36).slice(2);
      const headers = new Headers();
      headers.set("content-type", upload.type);
      if (upload.filename) {
        headers.set("content-disposition", `attachment; filename="${upload.filename}"`);
      }
      this.ctx.satori._tempStore[id] = {
        status: 200,
        data: upload.data,
        headers
      };
      ids.push(id);
    }
    const timer = setTimeout(() => dispose(), 6e5);
    const dispose = /* @__PURE__ */ __name(() => {
      _dispose();
      clearTimeout(timer);
      for (const id of ids) {
        delete this.ctx.satori._tempStore[id];
      }
    }, "dispose");
    const _dispose = this.ctx.on("dispose", dispose);
    return ids.map((id) => `upload://temp/${this.ctx.satori.uid}/${id}`);
  }
  async supports(name, session = {}) {
    return !!this[import_protocol2.Methods[name]?.name];
  }
  async checkPermission(name, session) {
    if (name.startsWith("bot.")) {
      return this.supports(name.slice(4), session);
    }
  }
  toJSON() {
    return (0, import_cosmokit2.clone)((0, import_cosmokit2.pick)(this, ["platform", "selfId", "status", "user", "hidden", "features", "proxyUrls"]));
  }
  async getLogin() {
    return this.toJSON();
  }
  /** @deprecated use `bot.getLogin()` instead */
  async getSelf() {
    const { user } = await this.getLogin();
    return user;
  }
};
var iterableMethods = [
  "getMessage",
  "getReaction",
  "getFriend",
  "getGuild",
  "getGuildMember",
  "getGuildRole",
  "getChannel"
];
for (const name of iterableMethods) {
  Bot.prototype[name + "Iter"] = function(...args) {
    let list;
    if (!this[name + "List"])
      throw new Error(`not implemented: ${name}List`);
    const getList = /* @__PURE__ */ __name(async () => {
      list = await this[name + "List"](...args, list?.next);
      if (name === "getMessage")
        list.data.reverse();
    }, "getList");
    return {
      async next() {
        if (list?.data.length)
          return { done: false, value: list.data.shift() };
        if (list && !list?.next)
          return { done: true, value: void 0 };
        await getList();
        return this.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      }
    };
  };
}
defineAccessor(Bot.prototype, "selfId", ["user", "id"]);
defineAccessor(Bot.prototype, "userId", ["user", "id"]);

// src/adapter.ts
var import_cosmokit3 = require("cosmokit");
var import_protocol3 = require("@satorijs/protocol");
var import_cordis3 = require("cordis");
var Adapter = class {
  constructor(ctx) {
    this.ctx = ctx;
  }
  static {
    __name(this, "Adapter");
  }
  static schema = false;
  bots = [];
  async connect(bot) {
  }
  async disconnect(bot) {
  }
  fork(ctx, bot) {
    bot.adapter = this;
    this.bots.push(bot);
    ctx.on("dispose", () => {
      (0, import_cosmokit3.remove)(this.bots, bot);
    });
  }
};
((Adapter2) => {
  Adapter2.WsClientConfig = import_cordis3.z.object({
    retryTimes: import_cordis3.z.natural().description("初次连接时的最大重试次数。").default(6),
    retryInterval: import_cordis3.z.natural().role("ms").description("初次连接时的重试时间间隔。").default(5 * import_cosmokit3.Time.second),
    retryLazy: import_cordis3.z.natural().role("ms").description("连接关闭后的重试时间间隔。").default(import_cosmokit3.Time.minute)
  }).description("连接设置");
  class WsClientBase extends Adapter2 {
    constructor(ctx, config) {
      super(ctx);
      this.config = config;
    }
    static {
      __name(this, "WsClientBase");
    }
    socket;
    async start() {
      let _retryCount = 0;
      const logger = this.ctx.logger("adapter");
      const { retryTimes, retryInterval, retryLazy } = this.config;
      const reconnect = /* @__PURE__ */ __name(async (initial = false) => {
        logger.debug("websocket client opening");
        let socket;
        try {
          socket = await this.prepare();
        } catch (error) {
          logger.warn(error);
          return;
        }
        const url = socket.url.replace(/\?.+/, "");
        socket.addEventListener("error", (event) => {
          if (event.message)
            logger.warn(event.message);
        });
        socket.addEventListener("close", ({ code, reason }) => {
          this.socket = null;
          logger.debug(`websocket closed with ${code}`);
          if (!this.getActive())
            return;
          const message = reason.toString() || `failed to connect to ${url}, code: ${code}`;
          let timeout = retryInterval;
          if (_retryCount >= retryTimes) {
            if (initial) {
              return this.setStatus(import_protocol3.Status.OFFLINE, new Error(message));
            } else {
              timeout = retryLazy;
            }
          }
          _retryCount++;
          this.setStatus(import_protocol3.Status.RECONNECT);
          logger.warn(`${message}, will retry in ${import_cosmokit3.Time.format(timeout)}...`);
          setTimeout(() => {
            if (this.getActive())
              reconnect();
          }, timeout);
        });
        socket.addEventListener("open", () => {
          _retryCount = 0;
          this.socket = socket;
          logger.info("connect to server: %c", url);
          this.accept(socket);
        });
      }, "reconnect");
      reconnect(true);
    }
    async stop() {
      this.socket?.close();
    }
  }
  Adapter2.WsClientBase = WsClientBase;
  class WsClient extends WsClientBase {
    constructor(ctx, bot) {
      super(ctx, bot.config);
      this.bot = bot;
      bot.adapter = this;
    }
    static {
      __name(this, "WsClient");
    }
    static reusable = true;
    getActive() {
      return this.bot.isActive;
    }
    setStatus(status, error = null) {
      this.bot.status = status;
      this.bot.error = error;
    }
    async connect(bot) {
      this.start();
    }
    async disconnect(bot) {
      this.stop();
    }
  }
  Adapter2.WsClient = WsClient;
})(Adapter || (Adapter = {}));

// src/message.ts
var import_element2 = __toESM(require("@satorijs/element"), 1);
var AggregateError = class extends Error {
  constructor(errors, message = "") {
    super(message);
    this.errors = errors;
  }
  static {
    __name(this, "AggregateError");
  }
};
var MessageEncoder = class {
  constructor(bot, channelId, guildId, options = {}) {
    this.bot = bot;
    this.channelId = channelId;
    this.guildId = guildId;
    this.options = options;
  }
  static {
    __name(this, "MessageEncoder");
  }
  errors = [];
  results = [];
  session;
  async prepare() {
  }
  async render(elements, flush) {
    for (const element of elements) {
      await this.visit(element);
    }
    if (flush) {
      await this.flush();
    }
  }
  async send(content) {
    this.session = this.bot.session({
      type: "send",
      channel: { id: this.channelId, ...this.options.session?.event.channel },
      guild: this.options.session?.event.guild
    });
    for (const key in this.options.session || {}) {
      if (key === "id" || key === "event")
        continue;
      this.session[key] = this.options.session[key];
    }
    await this.prepare();
    const session = this.options.session ?? this.session;
    this.session.elements = await session.transform(import_element2.default.normalize(content));
    const btns = import_element2.default.select(this.session.elements, "button").filter((v) => v.attrs.type !== "link" && !v.attrs.id);
    for (const btn of btns) {
      const r = Math.random().toString(36).slice(2);
      btn.attrs.id ||= r;
      if (typeof btn.attrs.action === "function")
        this.bot.callbacks[btn.attrs.id] = btn.attrs.action;
    }
    if (await this.session.app.serial(this.session, "before-send", this.session, this.options))
      return;
    await this.render(this.session.elements);
    await this.flush();
    if (this.errors.length) {
      throw new AggregateError(this.errors);
    } else {
      return this.results;
    }
  }
};

// src/index.ts
import_element3.default.warn = new import_cordis4.Logger("element").warn;
import_plugin_http.HTTP.createConfig = /* @__PURE__ */ __name(function createConfig(endpoint) {
  return import_cordis4.z.object({
    endpoint: import_cordis4.z.string().role("link").description("要连接的服务器地址。").default(typeof endpoint === "string" ? endpoint : null).required(typeof endpoint === "boolean" ? endpoint : false),
    headers: import_cordis4.z.dict(String).role("table").description("要附加的额外请求头。"),
    ...this.Config.dict
  }).description("请求设置");
}, "createConfig");
var SatoriContext = class extends import_cordis4.Context {
  static {
    __name(this, "SatoriContext");
  }
  constructor(config) {
    super(config);
    this.provide("satori", void 0, true);
    this.plugin(Satori);
  }
};
var Satori = class extends import_cordis4.Service {
  static {
    __name(this, "Satori");
  }
  static [import_cordis4.Service.provide] = "satori";
  static [import_cordis4.Service.immediate] = true;
  uid = Math.random().toString(36).slice(2);
  _uploadRoutes = [];
  _tempStore = /* @__PURE__ */ Object.create(null);
  constructor(ctx) {
    super(ctx);
    ctx.mixin("satori", ["bots", "component"]);
    this.upload(`/temp/${this.uid}/`, async (path) => {
      const id = path.split("/").pop();
      return this._tempStore[id] ?? { status: 404 };
    });
    (0, import_cosmokit4.defineProperty)(this.bots, import_cordis4.Service.tracker, {});
    const self = this;
    ctx.on("http/file", async function(url, options) {
      if (!url.startsWith("upload://"))
        return;
      const { status, data, headers } = await self.download(url.slice(9));
      if (status >= 400)
        throw new Error(`Failed to fetch ${url}, status code: ${status}`);
      if (status >= 300) {
        const location = headers?.get("location");
        return this.file(location, options);
      }
      const type = headers?.get("content-type");
      const filename = headers?.get("content-disposition")?.split("filename=")[1];
      return { data, filename, type, mime: type };
    });
  }
  bots = new Proxy([], {
    get(target, prop) {
      if (prop in target || typeof prop === "symbol") {
        return Reflect.get(target, prop);
      }
      return target.find((bot) => bot.sid === prop);
    },
    deleteProperty(target, prop) {
      if (prop in target || typeof prop === "symbol") {
        return Reflect.deleteProperty(target, prop);
      }
      const bot = target.findIndex((bot2) => bot2.sid === prop);
      if (bot < 0)
        return true;
      target.splice(bot, 1);
      return true;
    }
  });
  component(name, component, options = {}) {
    const render = /* @__PURE__ */ __name(async (attrs, children, session) => {
      if (options.session && session.type === "send") {
        throw new Error("interactive components is not available outside sessions");
      }
      const result = await component(attrs, children, session);
      return session.transform(import_element3.default.normalize(result));
    }, "render");
    return this.ctx.set("component:" + name, render);
  }
  upload(path, callback, proxyUrls = []) {
    return this.ctx.effect(() => {
      const route = { path, callback };
      this._uploadRoutes.push(route);
      proxyUrls.push(path);
      return () => {
        (0, import_cosmokit4.remove)(this._uploadRoutes, route);
        (0, import_cosmokit4.remove)(proxyUrls, path);
      };
    });
  }
  async download(path) {
    for (const route of this._uploadRoutes) {
      const paths = (0, import_cosmokit4.makeArray)(typeof route.path === "function" ? route.path() : route.path);
      if (paths.some((prefix) => path.startsWith(prefix))) {
        return route.callback(path);
      }
    }
    return { status: 404 };
  }
};
var src_default = Satori;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Adapter,
  Bot,
  Context,
  Element,
  HTTP,
  MessageEncoder,
  Messenger,
  Modulator,
  Quester,
  Satori,
  Session,
  Universal,
  defineAccessor,
  h,
  segment,
  ...require("cordis"),
  ...require("cosmokit")
});
//# sourceMappingURL=index.cjs.map
