var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  HttpPolling: () => HttpPolling,
  HttpServer: () => HttpServer,
  Internal: () => Internal,
  SenderError: () => SenderError,
  Telegram: () => types_exports,
  TelegramBot: () => TelegramBot,
  TelegramMessageEncoder: () => TelegramMessageEncoder,
  decodeGuildMember: () => decodeGuildMember,
  decodeMessage: () => decodeMessage,
  decodeUser: () => decodeUser,
  default: () => src_default,
  handleUpdate: () => handleUpdate
});
module.exports = __toCommonJS(src_exports);

// src/bot.ts
var import_core5 = require("@satorijs/core");
var import_url = require("url");

// src/types/index.ts
var types_exports = {};
__export(types_exports, {
  Internal: () => Internal
});

// src/types/internal.ts
var Internal = class _Internal {
  constructor(bot) {
    this.bot = bot;
  }
  static {
    __name(this, "Internal");
  }
  static define(method) {
    _Internal.prototype[method] = async function(data = {}) {
      this.bot.logger.debug("[request] %s %o", method, data);
      try {
        const response = await this.bot.http.post("/" + method, data);
        this.bot.logger.debug("[response] %o", response);
        const { ok, result } = response;
        if (ok)
          return result;
        throw new Error(`Telegram API error ${response.data.error_code}. ${response.data.description}`);
      } catch (err) {
        if (err.response?.data?.error_code && err.response.data.description) {
          throw new Error(`Telegram API error ${err.response.data.error_code}. ${err.response.data.description}`);
        } else {
          throw err;
        }
      }
    };
  }
};

// src/types/inline.ts
Internal.define("answerInlineQuery");
Internal.define("answerWebAppQuery");

// src/types/game.ts
Internal.define("sendGame");
Internal.define("setGameScore");
Internal.define("getGameHighScores");

// src/types/passport.ts
Internal.define("setPassportDataErrors");

// src/types/payment.ts
Internal.define("sendInvoice");
Internal.define("createInvoiceLink");
Internal.define("answerShippingQuery");
Internal.define("answerPreCheckoutQuery");

// src/types/sticker.ts
Internal.define("sendSticker");
Internal.define("getStickerSet");
Internal.define("getCustomEmojiStickers");
Internal.define("uploadStickerFile");
Internal.define("createNewStickerSet");
Internal.define("addStickerToSet");
Internal.define("setStickerPositionInSet");
Internal.define("deleteStickerFromSet");
Internal.define("setStickerSetThumb");

// src/types/update.ts
Internal.define("getUpdates");
Internal.define("setWebhook");
Internal.define("deleteWebhook");
Internal.define("getWebhookInfo");

// src/types/index.ts
Internal.define("getMe");
Internal.define("logOut");
Internal.define("close");
Internal.define("sendMessage");
Internal.define("forwardMessage");
Internal.define("copyMessage");
Internal.define("sendPhoto");
Internal.define("sendAudio");
Internal.define("sendDocument");
Internal.define("sendVideo");
Internal.define("sendAnimation");
Internal.define("sendVoice");
Internal.define("sendVideoNote");
Internal.define("sendMediaGroup");
Internal.define("sendLocation");
Internal.define("editMessageLiveLocation");
Internal.define("stopMessageLiveLocation");
Internal.define("sendVenue");
Internal.define("sendContact");
Internal.define("sendPoll");
Internal.define("sendDice");
Internal.define("sendChatAction");
Internal.define("getUserProfilePhotos");
Internal.define("getFile");
Internal.define("banChatMember");
Internal.define("unbanChatMember");
Internal.define("restrictChatMember");
Internal.define("promoteChatMember");
Internal.define("setChatAdministratorCustomTitle");
Internal.define("banChatSenderChat");
Internal.define("unbanChatSenderChat");
Internal.define("setChatPermissions");
Internal.define("exportChatInviteLink");
Internal.define("createChatInviteLink");
Internal.define("editChatInviteLink");
Internal.define("revokeChatInviteLink");
Internal.define("approveChatJoinRequest");
Internal.define("declineChatJoinRequest");
Internal.define("setChatPhoto");
Internal.define("deleteChatPhoto");
Internal.define("setChatTitle");
Internal.define("setChatDescription");
Internal.define("pinChatMessage");
Internal.define("unpinChatMessage");
Internal.define("unpinAllChatMessages");
Internal.define("leaveChat");
Internal.define("getChat");
Internal.define("getChatAdministrators");
Internal.define("getChatMemberCount");
Internal.define("getChatMember");
Internal.define("setChatStickerSet");
Internal.define("deleteChatStickerSet");
Internal.define("getForumTopicIconStickers");
Internal.define("createForumTopic");
Internal.define("editForumTopic");
Internal.define("closeForumTopic");
Internal.define("reopenForumTopic");
Internal.define("deleteForumTopic");
Internal.define("unpinAllForumTopicMessages");
Internal.define("editGeneralForumTopic");
Internal.define("closeGeneralForumTopic");
Internal.define("reopenGeneralForumTopic");
Internal.define("hideGeneralForumTopic");
Internal.define("unhideGeneralForumTopic");
Internal.define("answerCallbackQuery");
Internal.define("setMyCommands");
Internal.define("deleteMyCommands");
Internal.define("getMyCommands");
Internal.define("setChatMenuButton");
Internal.define("getChatMenuButton");
Internal.define("setMyDefaultAdministratorRights");
Internal.define("getMyDefaultAdministratorRights");
Internal.define("editMessageText");
Internal.define("editMessageCaption");
Internal.define("editMessageMedia");
Internal.define("editMessageReplyMarkup");
Internal.define("stopPoll");
Internal.define("deleteMessage");

// src/utils.ts
var import_core = require("@satorijs/core");
var decodeUser = /* @__PURE__ */ __name((data) => ({
  id: data.id.toString(),
  name: data.username,
  nick: data.first_name + (data.last_name ? " " + data.last_name : ""),
  isBot: data.is_bot
}), "decodeUser");
var decodeGuildMember = /* @__PURE__ */ __name((data) => ({
  user: decodeUser(data.user),
  title: data["custom_title"]
}), "decodeGuildMember");
var mediaGroupMap = /* @__PURE__ */ new Map();
async function handleUpdate(update, bot) {
  bot.logger.debug("receive %s", JSON.stringify(update));
  const subtype = Object.keys(update).filter((v) => v !== "update_id")[0];
  if (subtype) {
    bot.dispatch(bot.session({
      type: "internal",
      _type: `telegram/${subtype.replace(/_/g, "-")}`,
      _data: update[subtype]
    }));
  }
  const session = bot.session();
  session.setInternal("telegram", update);
  const message = update.message || update.edited_message || update.channel_post || update.edited_channel_post;
  const isBotCommand = update.message && update.message.entities?.[0].type === "bot_command";
  const code = message?.from?.language_code;
  if (code) {
    if (code === "zh-hans") {
      session.locales = ["zh-CN"];
    } else if (code === "zh-hant") {
      session.locales = ["zh-TW"];
    } else {
      session.locales = [code.slice(0, 2)];
    }
  }
  if (isBotCommand) {
    session.type = "interaction/command";
    await decodeMessage(bot, message, session.event.message = {}, session.event);
    session.content = session.content.slice(1);
  } else if (message) {
    if (update.message?.media_group_id) {
      if (!mediaGroupMap.has(update.message.media_group_id)) {
        mediaGroupMap.set(update.message.media_group_id, [/* @__PURE__ */ new Date(), []]);
      }
      const [, updates] = mediaGroupMap.get(update.message.media_group_id);
      session.type = update.message || update.channel_post ? "message" : "message-updated";
      await decodeMessage(bot, message, session.event.message = {}, session.event);
      updates.push({
        id: update.message.message_id,
        elements: session.event.message.elements
      });
      const thisUpdateTime = /* @__PURE__ */ new Date();
      mediaGroupMap.set(update.message.media_group_id, [thisUpdateTime, updates]);
      await new Promise((resolve) => setTimeout(resolve, 1200));
      if (mediaGroupMap.get(update.message.media_group_id)[0] === thisUpdateTime) {
        mediaGroupMap.delete(update.message.media_group_id);
        session.event.message.elements = updates.sort((a, b) => a.id - b.id).reduce((acc, cur) => acc.concat(cur.elements), []);
        session.event.message.content = session.event.message.elements.join("");
        session.event.message.id = Math.min(...updates.map((e) => e.id)).toString();
        session.event._data.mediaGroup = updates.map((e) => e.id);
      } else {
        return;
      }
    } else {
      session.type = update.message || update.channel_post ? "message" : "message-updated";
      await decodeMessage(bot, message, session.event.message = {}, session.event);
    }
  } else if (update.chat_join_request) {
    session.timestamp = update.chat_join_request.date * 1e3;
    session.type = "guild-member-request";
    session.messageId = `${update.chat_join_request.chat.id}@${update.chat_join_request.from.id}`;
    session.content = "";
    session.channelId = update.chat_join_request.chat.id.toString();
    session.guildId = session.channelId;
  } else if (update.my_chat_member) {
    session.timestamp = update.my_chat_member.date * 1e3;
    session.messageId = `${update.my_chat_member.chat.id}@${update.my_chat_member.from.id}`;
    session.content = "";
    session.channelId = update.my_chat_member.chat.id.toString();
    session.guildId = session.channelId;
    if (update.my_chat_member.old_chat_member.user.id.toString() === bot.selfId) {
      if (update.my_chat_member.new_chat_member.status === "left") {
        session.type = "group-deleted";
      } else if (update.my_chat_member.old_chat_member.status === "left") {
        session.type = "group-added";
      }
    }
  } else if (update.callback_query) {
    session.type = "interaction/button";
    session.userId = update.callback_query.from.id.toString();
    session.messageId = update.callback_query.id.toString();
    session.event.button = {
      id: update.callback_query.data
    };
    const data = update.callback_query.message;
    if (data.chat.type === "private") {
      session.event.channel = {
        id: data.chat.id.toString(),
        type: import_core.Universal.Channel.Type.DIRECT
      };
    } else {
      session.event.guild = {
        id: data.chat.id.toString(),
        name: data.chat.title
      };
      session.event.channel = {
        id: data.is_topic_message ? data.message_thread_id.toString() : data.chat.id.toString(),
        type: import_core.Universal.Channel.Type.TEXT
      };
    }
    await bot.internal.answerCallbackQuery({
      callback_query_id: update.callback_query.id
    });
  }
  bot.dispatch(session);
}
__name(handleUpdate, "handleUpdate");
async function decodeMessage(bot, data, message, payload = message) {
  const parseText = /* @__PURE__ */ __name((text, entities) => {
    if (!text)
      return [];
    const breakpoints = /* @__PURE__ */ new Set();
    for (const e of entities) {
      breakpoints.add(e.offset);
      breakpoints.add(e.offset + e.length);
    }
    breakpoints.add(text.length);
    for (let i = 0; i < text.length; i++) {
      if (text[i] === "\n") {
        breakpoints.add(i);
        breakpoints.add(i + 1);
      }
    }
    const obtainAttributeAtBP = /* @__PURE__ */ __name((bp) => {
      const attr = [];
      let url = null, user = null;
      for (const e of entities) {
        if (e.offset <= bp && e.offset + e.length > bp) {
          attr.push(e.type);
          if (e.type === "text_link") {
            url = e.url;
          } else if (e.type === "mention") {
            user = e.user;
          }
        }
      }
      return { attr, url, user };
    }, "obtainAttributeAtBP");
    const segs = [];
    let start = 0;
    for (const bp of Array.from(breakpoints).sort((a, b) => a - b)) {
      if (start < bp) {
        const { attr, url, user } = obtainAttributeAtBP(start);
        const content = text.slice(start, bp);
        let ele = (0, import_core.h)("text", { content });
        if (attr.includes("bold"))
          ele = (0, import_core.h)("b", {}, ele);
        if (attr.includes("italic"))
          ele = (0, import_core.h)("i", {}, ele);
        if (attr.includes("underline"))
          ele = (0, import_core.h)("u", {}, ele);
        if (attr.includes("strikethrough"))
          ele = (0, import_core.h)("s", {}, ele);
        if (attr.includes("code"))
          ele = (0, import_core.h)("code", {}, ele);
        if (attr.includes("pre"))
          ele = (0, import_core.h)("pre", {}, ele);
        if (attr.includes("spoiler"))
          ele = (0, import_core.h)("spl", {}, ele);
        if (url)
          ele = (0, import_core.h)("a", { href: url }, ele);
        if (user)
          ele = (0, import_core.h)("at", { id: user.id }, ele);
        if (content === "\n")
          ele = (0, import_core.h)("br");
        segs.push(ele);
      }
      start = bp;
    }
    return segs;
  }, "parseText");
  const segments = [];
  if (data.reply_to_message && !(data.is_topic_message && data.reply_to_message.forum_topic_created)) {
    await decodeMessage(bot, data.reply_to_message, message.quote = {}, null);
    message.quote.user = decodeUser(data.reply_to_message.from);
  }
  const msgText = data.text || data.caption;
  segments.push(...parseText(msgText, [...data.entities ?? [], ...data.caption_entities ?? []]));
  if (data.caption) {
    segments.push((0, import_core.h)("text", { content: " " }));
  }
  const addResource = /* @__PURE__ */ __name(async (type, data2) => {
    const attrs = await bot.$getFileFromId(data2.file_id);
    if (data2["file_name"]) {
      attrs.filename = data2["file_name"];
    }
    segments.push((0, import_core.h)(type, attrs));
  }, "addResource");
  if (data.location) {
    segments.push((0, import_core.h)("location", { lat: data.location.latitude, lon: data.location.longitude }));
  } else if (data.photo) {
    const photo = data.photo.sort((s1, s2) => s2.file_size - s1.file_size)[0];
    segments.push((0, import_core.h)("img", await bot.$getFileFromId(photo.file_id)));
  } else if (data.sticker) {
    try {
      const file = await bot.internal.getFile({ file_id: data.sticker.file_id });
      if (file.file_path.endsWith(".tgs")) {
        throw new Error("tgs is not supported now");
      }
      segments.push((0, import_core.h)("img", await bot.$getFileFromPath(file.file_path)));
    } catch (e) {
      bot.logger.warn("get file error", e);
      segments.push((0, import_core.h)("text", { content: `[${data.sticker.set_name || "sticker"} ${data.sticker.emoji || ""}]` }));
    }
  } else if (data.voice) {
    await addResource("audio", data.voice);
  } else if (data.animation) {
    await addResource("img", data.animation);
  } else if (data.video) {
    await addResource("video", data.video);
  } else if (data.document) {
    await addResource("file", data.document);
  } else if (data.audio) {
    await addResource("audio", data.audio);
  }
  message.elements = segments;
  message.content = segments.join("");
  message.id = message.messageId = data.message_id.toString();
  if (!payload)
    return;
  payload.timestamp = data.date * 1e3;
  payload.user = data.from ? decodeUser(data.from) : {};
  if (data.chat.type === "private") {
    payload.channel = {
      id: data.chat.id.toString(),
      type: import_core.Universal.Channel.Type.DIRECT
    };
  } else {
    payload.guild = {
      id: data.chat.id.toString(),
      name: data.chat.title
    };
    payload.member = {};
    payload.channel = {
      id: data.is_topic_message ? data.message_thread_id.toString() : data.chat.id.toString(),
      type: import_core.Universal.Channel.Type.TEXT
    };
  }
}
__name(decodeMessage, "decodeMessage");

// src/message.ts
var import_core2 = require("@satorijs/core");
var supportedElements = ["b", "strong", "i", "em", "u", "ins", "s", "del", "a"];
var TelegramMessageEncoder = class extends import_core2.MessageEncoder {
  static {
    __name(this, "TelegramMessageEncoder");
  }
  asset = [];
  payload;
  mode = "default";
  rows = [];
  async prepare() {
    const chat_id = this.session.guildId || this.channelId;
    this.payload = { chat_id, parse_mode: "html", caption: "" };
    if (this.session.guildId && this.channelId !== this.session.guildId) {
      this.payload.message_thread_id = +this.channelId;
    }
  }
  async addResult(result) {
    const session = this.bot.session();
    await decodeMessage(this.bot, result, session.event.message = {}, session.event);
    session.event._data ??= {};
    session.event._data.message = result;
    this.results.push(session.event.message);
    session.app.emit(session, "send", session);
  }
  async flush() {
    if (this.payload.caption || this.asset.length > 0) {
      this.trimButtons();
      if (this.asset.length > 0) {
        const files = [];
        const typeMap = {
          img: "photo",
          image: "photo",
          audio: "audio",
          video: "video",
          file: "document"
        };
        let i = 0;
        for (const element of this.asset) {
          const { filename, data, type: mime } = await this.bot.ctx.http.file(element.attrs.src || element.attrs.url, element.attrs);
          files.push({
            filename: i++ + filename,
            data,
            mime,
            type: filename.endsWith("gif") ? "animation" : typeMap[element.type] ?? element.type,
            element
          });
        }
        const inputFiles = [];
        for (const { filename, type, element } of files) {
          const media = "attach://" + filename;
          inputFiles.push({
            media,
            type,
            has_spoiler: element.attrs.spoiler
          });
        }
        if (files.length > 1) {
          inputFiles[0].caption = this.payload.caption;
          inputFiles[0].parse_mode = this.payload.parse_mode;
          const form = new FormData();
          const data = {
            chat_id: this.payload.chat_id,
            reply_to_message_id: this.payload.reply_to_message_id,
            message_thread_id: this.payload.message_thread_id,
            media: JSON.stringify(inputFiles)
          };
          for (const key in data) {
            form.append(key, data[key]);
          }
          for (const { filename, data: data2, mime } of files) {
            form.append(filename, new Blob([data2], { type: mime }), filename);
          }
          const result = await this.bot.internal.sendMediaGroup(form);
          for (const x of result) {
            await this.addResult(x);
          }
          if (this.rows.length > 0 && this.rows[0].length > 0) {
            const result2 = await this.bot.internal.sendMessage({
              chat_id: this.payload.chat_id,
              text: this.payload.caption,
              parse_mode: this.payload.parse_mode,
              reply_to_message_id: result[0].message_id,
              message_thread_id: this.payload.message_thread_id,
              disable_web_page_preview: !this.options.linkPreview,
              reply_markup: {
                inline_keyboard: this.rows
              }
            });
            await this.addResult(result2);
            delete this.payload.reply_to_message_id;
            this.payload.caption = "";
            this.rows = [];
          }
          delete this.payload.reply_to_message_id;
          this.payload.caption = "";
          this.rows = [];
        } else {
          const sendMap = [
            ["audio", ["sendAudio", "audio"]],
            ["voice", ["sendAudio", "audio"]],
            ["video", ["sendVideo", "video"]],
            ["animation", ["sendAnimation", "animation"]],
            ["image", ["sendPhoto", "photo"]],
            ["photo", ["sendPhoto", "photo"]],
            ["document", ["sendDocument", "document"]],
            ["", ["sendDocument", "document"]]
          ];
          const [, [method, dataKey]] = sendMap.find(([key]) => files[0].type.startsWith(key)) || [];
          const formData = new FormData();
          formData.append("chat_id", this.payload.chat_id);
          formData.append("caption", this.payload.caption);
          formData.append("parse_mode", this.payload.parse_mode);
          formData.append("reply_to_message_id", this.payload.reply_to_message_id);
          formData.append("message_thread_id", this.payload.message_thread_id);
          formData.append("has_spoiler", files[0].element.attrs.spoiler ? "true" : "false");
          formData.append(dataKey, "attach://" + files[0].filename);
          formData.append(files[0].filename, new Blob([files[0].data], { type: files[0].mime }), files[0].filename);
          const result = await this.bot.internal[method](formData);
          await this.addResult(result);
          this.payload.caption = "";
          this.rows = [];
          delete this.payload.reply_to_message_id;
        }
      } else {
        const result = await this.bot.internal.sendMessage({
          chat_id: this.payload.chat_id,
          text: this.payload.caption,
          parse_mode: this.payload.parse_mode,
          reply_to_message_id: this.payload.reply_to_message_id,
          message_thread_id: this.payload.message_thread_id,
          disable_web_page_preview: !this.options.linkPreview,
          reply_markup: {
            inline_keyboard: this.rows
          }
        });
        await this.addResult(result);
        delete this.payload.reply_to_message_id;
        this.payload.caption = "";
        this.rows = [];
      }
    }
  }
  decodeButton(attrs, label) {
    if (attrs.type === "link") {
      return {
        text: label,
        url: attrs.href
      };
    } else if (attrs.type === "input") {
      return {
        text: label,
        switch_inline_query_current_chat: attrs.text
      };
    } else {
      return {
        text: label,
        callback_data: attrs.id
      };
    }
  }
  lastRow() {
    if (!this.rows.length)
      this.rows.push([]);
    let last = this.rows[this.rows.length - 1];
    if (last.length >= 5) {
      this.rows.push([]);
      last = this.rows[this.rows.length - 1];
    }
    return last;
  }
  trimButtons() {
    if (this.rows.length && this.rows[this.rows.length - 1].length === 0)
      this.rows.pop();
  }
  async visit(element) {
    const { type, attrs, children } = element;
    if (type === "text") {
      this.payload.caption += import_core2.h.escape(attrs.content);
    } else if (type === "br") {
      this.payload.caption += "\n";
    } else if (type === "p") {
      if (!this.payload.caption.endsWith("\n"))
        this.payload.caption += "\n";
      await this.render(children);
      if (!this.payload.caption.endsWith("\n"))
        this.payload.caption += "\n";
    } else if (supportedElements.includes(type)) {
      this.payload.caption += element.toString();
    } else if (type === "spl") {
      this.payload.caption += "<tg-spoiler>";
      await this.render(children);
      this.payload.caption += "</tg-spoiler>";
    } else if (type === "code") {
      const { lang } = attrs;
      this.payload.caption += `<code${lang ? ` class="language-${lang}"` : ""}>${import_core2.h.escape(attrs.content)}</code>`;
    } else if (type === "at") {
      if (attrs.id) {
        this.payload.caption += `<a href="tg://user?id=${attrs.id}">@${attrs.name || attrs.id}</a>`;
      }
    } else if (["img", "image", "audio", "video", "file"].includes(type)) {
      this.asset.push(element);
    } else if (type === "figure") {
      await this.flush();
      this.mode = "figure";
      await this.render(children);
      await this.flush();
      this.mode = "default";
    } else if (type === "quote") {
      if ("id" in attrs) {
        await this.flush();
        this.payload.reply_to_message_id = attrs.id;
      } else {
        this.payload.caption += "<blockquote>";
        await this.render(children);
        this.payload.caption += "</blockquote>";
      }
    } else if (type === "button") {
      const last = this.lastRow();
      last.push(this.decodeButton(
        attrs,
        children.join("")
      ));
    } else if (type === "button-group") {
      this.rows.push([]);
      await this.render(children);
      this.rows.push([]);
    } else if (type === "message") {
      if (this.mode === "figure") {
        await this.render(children);
        this.payload.caption += "\n";
      } else {
        await this.flush();
        await this.render(children);
        await this.flush();
      }
    } else {
      await this.render(children);
    }
  }
};

// src/server.ts
var import_core3 = require("@satorijs/core");
var HttpServer = class extends import_core3.Adapter {
  static {
    __name(this, "HttpServer");
  }
  static inject = ["server"];
  async connect(bot) {
    let { token, path, selfUrl } = bot.config;
    path = (0, import_core3.sanitize)(path || "/telegram");
    if (selfUrl) {
      selfUrl = (0, import_core3.trimSlash)(selfUrl);
    } else {
      selfUrl = this.ctx.server.config.selfUrl;
    }
    this.ctx.server.post(path, async (ctx) => {
      const payload = ctx.request.body;
      const token2 = ctx.request.query.token;
      const [selfId] = token2.split(":");
      const bot2 = this.bots.find((bot3) => bot3.selfId === selfId);
      if (!(bot2?.config?.token === token2))
        return ctx.status = 403;
      ctx.body = "OK";
      await handleUpdate(payload, bot2);
    });
    bot.initialize(async (bot2) => {
      const info = await bot2.internal.setWebhook({
        url: selfUrl + path + "?token=" + token,
        drop_pending_updates: true
      });
      if (!info)
        throw new Error("Set webhook failed");
      bot2.logger.debug("listening updates %c", "telegram: " + bot2.selfId);
    });
  }
};
((HttpServer2) => {
  HttpServer2.Options = import_core3.Schema.object({
    protocol: import_core3.Schema.const("server").required(),
    path: import_core3.Schema.string().description("服务器监听的路径。").default("/telegram"),
    selfUrl: import_core3.Schema.string().role("link").description("服务器暴露在公网的地址。缺省时将使用全局配置。")
  });
})(HttpServer || (HttpServer = {}));

// src/polling.ts
var import_core4 = require("@satorijs/core");
var HttpPolling = class extends import_core4.Adapter {
  static {
    __name(this, "HttpPolling");
  }
  static reusable = true;
  offset = 0;
  timeout;
  async connect(bot) {
    bot.initialize(async () => {
      let _retryCount = 0;
      let _initial = true;
      const { retryTimes, retryInterval } = bot.config;
      const { url } = await bot.internal.getWebhookInfo();
      if (url) {
        bot.logger.warn("Bot currently has a webhook set up, trying to remove it...");
        await bot.internal.setWebhook({ url: "" });
      }
      const previousUpdates = await bot.internal.getUpdates({
        allowed_updates: [],
        timeout: 0
      });
      previousUpdates.forEach((e) => {
        this.offset = Math.max(this.offset, e.update_id);
      });
      const polling = /* @__PURE__ */ __name(async () => {
        try {
          const updates = await bot.internal.getUpdates({
            offset: this.offset + 1,
            timeout: Math.ceil(bot.config.pollingTimeout / 1e3)
            // in seconds
          });
          if (!bot.isActive)
            return;
          bot.online();
          _retryCount = 0;
          _initial = false;
          for (const e of updates) {
            this.offset = Math.max(this.offset, e.update_id);
            handleUpdate(e, bot);
          }
          this.timeout = setTimeout(polling, 0);
        } catch (e) {
          if (!bot.http.isError(e) || !e.response?.data) {
            bot.logger.warn("failed to get updates. reason: %s", e.message);
          } else {
            const { error_code, description } = e.response.data;
            bot.logger.warn("failed to get updates: %c %s", error_code, description);
          }
          if (_initial && _retryCount > retryTimes) {
            bot.error = e;
            return bot.status = import_core4.Universal.Status.OFFLINE;
          }
          if (!bot.isActive)
            return;
          _retryCount++;
          bot.status = import_core4.Universal.Status.RECONNECT;
          this.timeout = setTimeout(polling, retryInterval);
        }
      }, "polling");
      polling();
      bot.logger.debug("listening updates %c", "telegram: " + bot.selfId);
    });
  }
  async disconnect() {
    clearTimeout(this.timeout);
  }
};
((HttpPolling2) => {
  HttpPolling2.Options = import_core4.Schema.object({
    protocol: import_core4.Schema.const("polling").required(process.env.KOISHI_ENV !== "browser"),
    pollingTimeout: import_core4.Schema.natural().role("ms").default(import_core4.Time.second * 25).description("通过长轮询获取更新时请求的超时 (单位为毫秒)。"),
    retryTimes: import_core4.Schema.natural().description("初次连接时的最大重试次数。").default(6),
    retryInterval: import_core4.Schema.natural().role("ms").default(import_core4.Time.second * 5).description("长轮询断开后的重试时间间隔 (单位为毫秒)。")
  });
})(HttpPolling || (HttpPolling = {}));

// src/bot.ts
var import_file_type = __toESM(require("file-type"), 1);
var SenderError = class extends Error {
  static {
    __name(this, "SenderError");
  }
  constructor(args, url, retcode, selfId) {
    super(`Error when trying to send to ${url}, args: ${JSON.stringify(args)}, retcode: ${retcode}`);
    Object.defineProperties(this, {
      name: { value: "SenderError" },
      selfId: { value: selfId },
      code: { value: retcode },
      args: { value: args },
      url: { value: url }
    });
  }
};
var TelegramBot = class _TelegramBot extends import_core5.Bot {
  static {
    __name(this, "TelegramBot");
  }
  static MessageEncoder = TelegramMessageEncoder;
  static inject = ["http"];
  http;
  file;
  internal;
  local;
  server;
  constructor(ctx, config) {
    super(ctx, config, "telegram");
    this.selfId = config.token.split(":")[0];
    this.local = config.files.local;
    this.http = this.ctx.http.extend({
      ...config,
      endpoint: `${config.endpoint}/bot${config.token}`
    });
    this.file = this.ctx.http.extend({
      ...config,
      endpoint: `${config.files.endpoint || config.endpoint}/file/bot${config.token}`
    });
    this.internal = new Internal(this);
    if (config.protocol === "server") {
      ctx.plugin(HttpServer, this);
    } else if (config.protocol === "polling") {
      ctx.plugin(HttpPolling, this);
    }
    const selfUrl = config["selfUrl"] || ctx.get("server")?.config.selfUrl;
    if (config.files.server ?? selfUrl) {
      const route = `/telegram/${this.selfId}`;
      this.server = selfUrl + route;
      ctx.get("server").get(route + "/:file+", async (ctx2) => {
        const { data, type } = await this.$getFile(ctx2.params.file);
        ctx2.set("content-type", type);
        ctx2.body = Buffer.from(data);
      });
    }
  }
  async initialize(callback) {
    await this.getLogin();
    await callback(this);
    this.logger.debug("connected to %c", "telegram:" + this.selfId);
    this.online();
  }
  async deleteMessage(chat_id, message_id) {
    message_id = +message_id;
    await this.internal.deleteMessage({ chat_id, message_id });
  }
  async editMessage(chat_id, message_id, content) {
    message_id = +message_id;
    const payload = {
      chat_id,
      message_id,
      parse_mode: "html"
    };
    payload.text = import_core5.h.normalize(content).join("");
    await this.internal.editMessageText(payload);
  }
  static adaptGroup(data) {
    data["guildId"] = data.id + "";
    data["guildName"] = data.title;
    return data;
  }
  async getGuild(chat_id) {
    const data = await this.internal.getChat({ chat_id });
    return _TelegramBot.adaptGroup(data);
  }
  async getGuildMember(chat_id, user_id) {
    user_id = +user_id;
    if (Number.isNaN(user_id))
      return null;
    const data = await this.internal.getChatMember({ chat_id, user_id });
    const member = decodeGuildMember(data);
    await this.setAvatarUrl(member.user);
    return member;
  }
  async getGuildMemberList(chat_id) {
    const data = await this.internal.getChatAdministrators({ chat_id });
    const members = data.map(decodeGuildMember);
    return { data: members };
  }
  async kickGuildMember(chat_id, user_id, permanent) {
    user_id = +user_id;
    await this.internal.banChatMember({
      chat_id,
      user_id,
      until_date: Date.now() + (permanent ? 0 : import_core5.Time.minute),
      revoke_messages: true
    });
  }
  setGroupLeave(chat_id) {
    return this.internal.leaveChat({ chat_id });
  }
  async handleGuildMemberRequest(messageId, approve, comment) {
    const [chat_id, user_id] = messageId.split("@");
    const method = approve ? "approveChatJoinRequest" : "declineChatJoinRequest";
    const success = await this.internal[method]({ chat_id, user_id: +user_id });
    if (!success)
      throw new Error(`handel guild member request field ${success}`);
  }
  async getLogin() {
    const data = await this.internal.getMe();
    const user = decodeUser(data);
    await this.setAvatarUrl(user);
    this.user = user;
    return this.toJSON();
  }
  async $getFile(filePath) {
    if (this.local) {
      return await this.ctx.http.file((0, import_url.pathToFileURL)(filePath).href);
    } else {
      return await this.file.file(`/${filePath}`);
    }
  }
  async $getFileFromId(file_id) {
    try {
      const file = await this.internal.getFile({ file_id });
      return await this.$getFileFromPath(file.file_path);
    } catch (e) {
      this.logger.warn("get file error", e);
    }
  }
  async $getFileFromPath(filePath) {
    if (this.server) {
      return { src: `${this.server}/${filePath}` };
    }
    let { type, data } = await this.$getFile(filePath);
    if (type === "application/octet-stream") {
      type = (await import_file_type.default.fromBuffer(data))?.mime;
    }
    const base64 = `data:${type};base64,` + import_core5.Binary.toBase64(data);
    return { src: base64 };
  }
  async setAvatarUrl(user) {
    const { photos: [avatar] } = await this.internal.getUserProfilePhotos({ user_id: +user.id });
    if (!avatar)
      return;
    const { file_id } = avatar[avatar.length - 1];
    const file = await this.internal.getFile({ file_id });
    if (this.server) {
      user.avatar = `${this.server}/${file.file_path}`;
    } else {
      const { endpoint } = this.file.config;
      user.avatar = `${endpoint}/${file.file_path}`;
    }
  }
  async getUser(userId, guildId) {
    const data = await this.internal.getChat({ chat_id: userId });
    if (!data.photo?.big_file_id && !data.photo?.small_file_id)
      return decodeUser(data);
    const { src } = await this.$getFileFromId(data.photo?.big_file_id || data.photo?.small_file_id);
    return {
      ...decodeUser(data),
      avatar: src
    };
  }
  async createDirectChannel(id) {
    return { id, type: import_core5.Universal.Channel.Type.DIRECT };
  }
  async updateCommands(commands) {
    if (!this.config.slash)
      return;
    const result = {};
    for (const cmd of commands) {
      const { name, description } = cmd;
      const languages = {};
      for (const locale in description) {
        if (!locale || !description[locale])
          continue;
        const lang = locale.slice(0, 2);
        languages[lang] ||= description[locale];
      }
      for (const lang in languages) {
        result[lang] ??= [];
        result[lang].push({ command: name, description: languages[lang] });
      }
    }
    for (const lang in result) {
      await this.internal.setMyCommands({
        commands: result[lang],
        language_code: lang
      });
    }
    await this.internal.setMyCommands({
      commands: commands.map(({ name, description }) => ({
        command: name,
        description: description[""] || name
      }))
    });
  }
};
((TelegramBot2) => {
  TelegramBot2.Config = import_core5.Schema.intersect([
    import_core5.Schema.object({
      token: import_core5.Schema.string().description("机器人的用户令牌。").role("secret").required(),
      protocol: process.env.KOISHI_ENV === "browser" ? import_core5.Schema.const("polling").default("polling") : import_core5.Schema.union(["server", "polling"]).description("选择要使用的协议。").required()
    }),
    import_core5.Schema.union([
      HttpServer.Options,
      HttpPolling.Options
    ]).description("推送设置"),
    import_core5.Schema.object({
      slash: import_core5.Schema.boolean().description("是否启用斜线指令。").default(true)
    }).description("功能设置"),
    import_core5.HTTP.createConfig("https://api.telegram.org"),
    import_core5.Schema.object({
      files: import_core5.Schema.object({
        endpoint: import_core5.Schema.string().description("文件请求的终结点。"),
        local: import_core5.Schema.boolean().description("是否启用 [Telegram Bot API](https://github.com/tdlib/telegram-bot-api) 本地模式。"),
        server: import_core5.Schema.boolean().description("是否启用文件代理。若开启将会使用 `selfUrl` 进行反代，否则会下载所有资源文件 (包括图片、视频等)。当配置了 `selfUrl` 时将默认开启。")
      })
    }).hidden(process.env.KOISHI_ENV === "browser").description("文件设置")
  ]);
})(TelegramBot || (TelegramBot = {}));

// src/index.ts
var src_default = TelegramBot;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  HttpPolling,
  HttpServer,
  Internal,
  SenderError,
  Telegram,
  TelegramBot,
  TelegramMessageEncoder,
  decodeGuildMember,
  decodeMessage,
  decodeUser,
  handleUpdate
});
//# sourceMappingURL=index.cjs.map
