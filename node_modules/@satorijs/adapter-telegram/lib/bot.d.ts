import { Bot, Context, Dict, h, HTTP, Schema, Universal } from '@satorijs/core';
import * as Telegram from './types';
import { TelegramMessageEncoder } from './message';
import { HttpServer } from './server';
import { HttpPolling } from './polling';
export declare class SenderError extends Error {
    constructor(args: Dict<any>, url: string, retcode: number, selfId: string);
}
export interface TelegramResponse {
    ok: boolean;
    result: any;
}
export declare class TelegramBot<C extends Context = Context, T extends TelegramBot.Config = TelegramBot.Config> extends Bot<C, T> {
    static MessageEncoder: typeof TelegramMessageEncoder;
    static inject: string[];
    http: HTTP;
    file: HTTP;
    internal: Telegram.Internal;
    local?: boolean;
    server?: string;
    constructor(ctx: C, config: T);
    initialize(callback: (bot: this) => Promise<void>): Promise<void>;
    deleteMessage(chat_id: string, message_id: string | number): Promise<void>;
    editMessage(chat_id: string, message_id: string | number, content: h.Fragment): Promise<void>;
    static adaptGroup(data: Telegram.Chat): Universal.Guild;
    getGuild(chat_id: string): Promise<Universal.Guild>;
    getGuildMember(chat_id: string, user_id: string | number): Promise<Universal.GuildMember>;
    getGuildMemberList(chat_id: string): Promise<{
        data: Universal.GuildMember[];
    }>;
    kickGuildMember(chat_id: string, user_id: string | number, permanent?: boolean): Promise<void>;
    setGroupLeave(chat_id: string): Promise<boolean>;
    handleGuildMemberRequest(messageId: string, approve: boolean, comment?: string): Promise<void>;
    getLogin(): Promise<Universal.Login>;
    $getFile(filePath: string): Promise<import("@cordisjs/plugin-http").FileResponse>;
    $getFileFromId(file_id: string): Promise<{
        src: string;
    }>;
    $getFileFromPath(filePath: string): Promise<{
        src: string;
    }>;
    private setAvatarUrl;
    getUser(userId: string, guildId?: string): Promise<Universal.User>;
    createDirectChannel(id: string): Promise<{
        id: string;
        type: Universal.Channel.Type;
    }>;
    updateCommands(commands: Universal.Command[]): Promise<void>;
}
export declare namespace TelegramBot {
    interface BaseConfig extends HTTP.Config {
        protocol: 'server' | 'polling';
        token: string;
        files?: Config.Files;
        slash?: boolean;
    }
    type Config = BaseConfig & (HttpServer.Options | HttpPolling.Options);
    namespace Config {
        interface Files {
            endpoint?: string;
            local?: boolean;
            server?: boolean;
        }
    }
    const Config: Schema<Config>;
}
