var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// external/dialogue/packages/core/src/locales/zh-CN.yml
var require_zh_CN = __commonJS({
  "external/dialogue/packages/core/src/locales/zh-CN.yml"(exports, module2) {
    module2.exports = { commands: { teach: { description: "添加教学对话", options: { search: "搜索已有问答", page: "设置搜索结果的页码", autoMerge: "自动合并相同的问题和回答", recursive: "禁用递归查询", pipe: "对每个搜索结果执行操作", review: "查看最近的修改", revert: "回退最近的修改", includeLast: "包含最近的修改数量", excludeLast: "排除最近的修改数量", target: "查看或修改已有问题", remove: "彻底删除问答", ignoreHint: "忽略智能提示", "regexp.true": "使用正则表达式匹配", "regexp.false": "取消使用正则表达式匹配", redirect: "重定向到其他问答", probabilityStrict: "设置问题的触发权重", probabilityAppellative: "设置被称呼时问题的触发权重" }, messages: { "options-conflict": "选项 {0} 不能同时使用。", "too-many-arguments": "存在多余的参数，请检查指令语法或将含有空格或换行的问答置于一对引号内。", "missing-question-or-answer": "缺少问题或回答，请检查指令语法。", "prohibited-command": "禁止在教学回答中插值调用 {0} 指令。", "prohibited-cq-code": "问题必须是纯文本。", "illegal-regexp": "问题含有错误的或不支持的正则表达式语法。", "probably-modify-answer": "推测你想修改的是回答而不是问题。发送句号以修改回答，使用 -I 选项以忽略本提示。", "probably-regexp": "推测你想{0}的问题是正则表达式。发送句号以添加 -x 选项，使用 -I 选项以忽略本提示。", "upload-failed": "上传资源时发生错误。", redirections: "重定向到：", "create-success": "问答已添加，编号为 {0}。", "modify-success": "问答 {0} 已成功修改。", "remove-success": "问答 {0} 已成功删除。", "revert-success": "问答 {0} 已回退完成。", unchanged: "问答 {0} 没有发生改动。", "create-modified": "修改了已存在的问答，编号为 {0}。", "create-unchanged": "问答已存在，编号为 {0}，如要修改请尝试使用 {1} 指令。", "revert-unknown": "最近无人修改过编号为 {0} 的问答。", "modify-unknown": "没有搜索到编号为 {0} 的问答。", "permission-denied": "问答 {0} 因权限过低无法{1}。", "low-permission": "该问答因权限过低无法添加。", "unknown-error": "{0}问答时遇到错误。", "no-history": "没有搜索到满足条件的教学操作。", "recent-history": "近期执行的教学操作有：", "max-previews": "一次最多同时预览 {0} 个问答。", review: "{0}于：<i18n:time value={1}/>前", "detail-header": "问答 {0} 的{1}：", detail: "{0}：{1}", entity: { question: "问题", answer: "回答", regexp: "正则", detail: "详细信息", history: "历史版本" }, operation: { create: "添加", modify: "修改", remove: "删除", revert: "回退" }, search: { count: "共 {0} 个", empty: "没有搜索到任何问答。", regexp: "正则", "regexp-hint": "，请尝试使用正则表达式匹配", probability: "实际触发概率：", "result-all": "全部问答如下{2}：", "result-answer": "回答“{1}”的问题如下{2}：", "result-question": "问题“{0}”的回答如下{2}：", "result-dialogue": "“{0}”“{1}”匹配的回答如下{2}：", "result-regexp-answer": "回答正则表达式“{1}”的搜索结果如下{2}：", "result-regexp-question": "问题正则表达式“{0}”的搜索结果如下{2}：", "result-regexp-dialogue": "问答正则表达式“{0}”“{1}”的搜索结果如下{2}：", "empty-all": "没有搜索到任何回答，尝试切换到其他环境。", "empty-answer": "没有搜索到回答“{1}”{2}。", "empty-question": "没有搜索到问题“{0}”{2}。", "empty-dialogue": "没有搜索到问答“{0}”“{1}”{2}。", "empty-regexp-answer": "没有搜索到含有正则表达式“{1}”的回答。", "empty-regexp-question": "没有搜索到含有正则表达式“{0}”的问题。", "empty-regexp-dialogue": "没有搜索到含有正则表达式“{0}”“{1}”的问答。", "page-hint": " (第 {0}/{1} 页)", "page-footer": "可以使用 /+页码 以调整输出的条目页数。" }, probability: { detail: "触发权重：p={probS}, P={probA}", "zero-to-one": "应为不超过 1 的正数。" } } }, dialogue: { description: "触发教学对话", stats: { messages: { output: "共收录了 {questions} 个问题和 {dialogues} 个回答。" } } } } };
  }
});

// external/dialogue/packages/core/src/index.ts
var src_exports = {};
__export(src_exports, {
  Dialogue: () => Dialogue,
  DialogueService: () => DialogueService,
  MessageBuffer: () => MessageBuffer,
  OrderedList: () => OrderedList,
  RE_DIALOGUES: () => RE_DIALOGUES,
  analyze: () => analyze,
  apply: () => apply5,
  create: () => create,
  equal: () => equal,
  escapeAnswer: () => escapeAnswer,
  formatAbstract: () => formatAbstract,
  formatAnswer: () => formatAnswer,
  formatAnswers: () => formatAnswers,
  formatPrefix: () => formatPrefix,
  getAbstract: () => getAbstract,
  getTotalWeight: () => getTotalWeight,
  handleError: () => handleError,
  inject: () => inject,
  isZeroToOne: () => isZeroToOne,
  name: () => name,
  prepareTargets: () => prepareTargets,
  schema: () => schema,
  sendResult: () => sendResult,
  split: () => split,
  triggerDialogue: () => triggerDialogue,
  unescapeAnswer: () => unescapeAnswer
});
module.exports = __toCommonJS(src_exports);
var import_koishi7 = require("koishi");

// external/dialogue/packages/core/src/service.ts
var import_koishi = require("koishi");
var halfWidth = ",,.~?!()[]";
var fullWidth = "，、。～？！（）【】";
var fullWidthRegExp = new RegExp(`[${fullWidth}]`);
function createLeadingRE(patterns, prefix = "", suffix = "") {
  return patterns.length ? new RegExp(`^${prefix}(${patterns.map(import_koishi.escapeRegExp).join("|")})${suffix}`) : /$^/;
}
__name(createLeadingRE, "createLeadingRE");
var _DialogueService = class _DialogueService extends import_koishi.Service {
  constructor(ctx, config) {
    super(ctx, "dialogue", true);
    this.config = config;
    ctx.model.extend("dialogue", {
      id: "unsigned",
      flag: "unsigned(4)",
      probS: { type: "decimal", precision: 4, scale: 3, initial: 1 },
      probA: { type: "decimal", precision: 4, scale: 3, initial: 0 },
      original: "string(255)",
      question: "string(255)",
      answer: "text"
    }, {
      autoInc: true
    });
    this.nameRE = createLeadingRE((0, import_koishi.makeArray)(ctx.root.config.nickname), "@?", "([,，]\\s*|\\s+|$)");
  }
  states = /* @__PURE__ */ Object.create(null);
  history = /* @__PURE__ */ Object.create(null);
  nameRE;
  flag(flag) {
    this.ctx.before("dialogue/search", (session, test) => {
      test[flag] = session.argv.options[flag];
    });
    this.ctx.on("dialogue/modify", (session, data) => {
      const { options } = session.argv;
      if (options[flag] !== void 0) {
        data.flag &= ~Dialogue.Flag[flag];
        data.flag |= +options[flag] * Dialogue.Flag[flag];
      }
    });
    this.ctx.on("dialogue/query", (test, query) => {
      if (test[flag] === void 0)
        return;
      query.$and.push({
        flag: { [test[flag] ? "$bitsAllSet" : "$bitsAllClear"]: Dialogue.Flag[flag] }
      });
    });
  }
  async stats() {
    const selection = this.ctx.database.select("dialogue");
    const [dialogues, questions] = await Promise.all([
      selection.execute((row) => import_koishi.$.count(row.id)),
      selection.execute((row) => import_koishi.$.count(row.question))
    ]);
    return { dialogues, questions };
  }
  async get(test, fields) {
    if (Array.isArray(test)) {
      const dialogues = await this.ctx.database.get("dialogue", test, fields);
      dialogues.forEach((d) => (0, import_koishi.defineProperty)(d, "_backup", (0, import_koishi.clone)(d)));
      return dialogues;
    } else {
      const query = { $and: [] };
      this.ctx.emit("dialogue/query", test, query);
      const dialogues = await this.ctx.database.get("dialogue", query);
      dialogues.forEach((d) => (0, import_koishi.defineProperty)(d, "_backup", (0, import_koishi.clone)(d)));
      return dialogues;
    }
  }
  async update(dialogues, session) {
    const data = [];
    const { options } = session.argv;
    for (const dialogue of dialogues) {
      if (!Object.keys(dialogue.$diff).length) {
        options.skipped.push(dialogue.id);
      } else {
        options.updated.push(dialogue.id);
        data.push({ ...dialogue.$diff, id: dialogue.id });
        dialogue.$diff = {};
        this.addHistory(dialogue._backup, "modify", session, false);
      }
    }
    await this.ctx.database.upsert("dialogue", data);
  }
  async remove(dialogues, session, revert = false) {
    const ids = dialogues.map((d) => d.id);
    for (const id of ids) {
      this.addHistory(session.argv.options.dialogueMap[id], "remove", session, revert);
    }
    await this.ctx.database.remove("dialogue", ids);
    return ids;
  }
  async revert(dialogues, session) {
    const created = dialogues.filter((d) => d._type === "create");
    const edited = dialogues.filter((d) => d._type !== "create");
    await this.remove(created, session, true);
    await this.recover(edited, session);
    return session.text(".revert-success", [dialogues.map((d) => d.id).sort((a, b) => a - b).join(", ")]);
  }
  async recover(dialogues, session) {
    await this.ctx.database.upsert("dialogue", dialogues);
    for (const dialogue of dialogues) {
      this.addHistory(dialogue, "modify", session, true);
    }
  }
  addHistory(dialogue, type, session, revert) {
    if (revert)
      return delete this.history[dialogue.id];
    this.history[dialogue.id] = dialogue;
    const time = Date.now();
    (0, import_koishi.defineProperty)(dialogue, "_timestamp", time);
    (0, import_koishi.defineProperty)(dialogue, "_operator", session.userId);
    (0, import_koishi.defineProperty)(dialogue, "_type", type);
    this.ctx.setTimeout(() => {
      var _a;
      if (((_a = this.history[dialogue.id]) == null ? void 0 : _a._timestamp) === time) {
        delete this.history[dialogue.id];
      }
    }, this.config.historyTimeout);
  }
  stripQuestion(source) {
    const original = import_koishi.segment.unescape(source);
    source = import_koishi.segment.transform(source, {
      text({ content }) {
        return import_koishi.segment.unescape("" + content).toLowerCase().replace(/\s+/g, "").replace(fullWidthRegExp, ($0) => halfWidth[fullWidth.indexOf($0)]);
      }
    });
    source = source.replace(/^\(*/, "");
    source = source.replace(/[\.,?!()~]*$/, "");
    const capture = this.nameRE.exec(source);
    const unprefixed = capture ? source.slice(capture[0].length) : source;
    return {
      original,
      parsed: unprefixed || source,
      appellative: unprefixed && unprefixed !== source,
      activated: !unprefixed && unprefixed !== source
    };
  }
  formatDialogue(session, dialogue) {
    const abstract = getAbstract(session, dialogue);
    const { original, answer } = dialogue;
    const questionType = session.text(`commands.teach.messages.entity.${abstract.questionType || "question"}`);
    const answerType = session.text(`commands.teach.messages.entity.${abstract.answerType || "answer"}`);
    return [
      session.text("commands.teach.messages.detail", [formatAbstract(dialogue, abstract) + questionType, original]),
      session.text("commands.teach.messages.detail", [answerType, formatAnswer(answer, this.config)])
    ].join(session.text("general.comma"));
  }
  list(session, dialogues, prefix = "") {
    return dialogues.map((dialogue) => {
      const output = [prefix + this.formatDialogue(session, dialogue)];
      this.ctx.emit("dialogue/appendix", dialogue, output, prefix, session);
      return output.join("\n");
    });
  }
};
__name(_DialogueService, "DialogueService");
var DialogueService = _DialogueService;
function formatAnswer(source, { maxAnswerLength = 100 }) {
  let trimmed = false;
  const lines = source.split(/(\r?\n|\$n)/g);
  if (lines.length > 1) {
    trimmed = true;
    source = lines[0].trim();
  }
  source = source.replace(/<image [^>]+>/g, "[图片]");
  if (source.length > maxAnswerLength) {
    trimmed = true;
    source = source.slice(0, maxAnswerLength);
  }
  if (trimmed && !source.endsWith("……")) {
    if (source.endsWith("…")) {
      source += "…";
    } else {
      source += "……";
    }
  }
  return source;
}
__name(formatAnswer, "formatAnswer");
function getAbstract(session, dialogue) {
  const abstract = [];
  session.app.emit("dialogue/abstract", dialogue, abstract, session);
  return abstract;
}
__name(getAbstract, "getAbstract");
function formatAbstract(dialogue, abstract) {
  return `${dialogue.id}. ${abstract.length ? `[${abstract.join(", ")}] ` : ""}`;
}
__name(formatAbstract, "formatAbstract");
function formatPrefix(session, dialogue, showAnswerType = false) {
  const details = getAbstract(session, dialogue);
  let result = formatAbstract(dialogue, details);
  if (details.questionType) {
    result += `[${session.text("commands.teach.messages.entity." + details.questionType)}] `;
  }
  if (showAnswerType && details.answerType) {
    result += `[${session.text("commands.teach.messages.entity." + details.answerType)}] `;
  }
  return result;
}
__name(formatPrefix, "formatPrefix");
function formatAnswers(session, dialogues, prefix = "") {
  const app = session.app;
  return dialogues.map((dialogue) => {
    const { answer } = dialogue;
    const output = [`${prefix}${formatPrefix(session, dialogue, true)}${formatAnswer(answer, app.dialogue.config)}`];
    app.emit("dialogue/appendix", dialogue, output, prefix, session);
    return output.join("\n");
  });
}
__name(formatAnswers, "formatAnswers");

// external/dialogue/packages/core/src/command.ts
var import_koishi2 = require("koishi");

// external/dialogue/packages/core/src/utils.ts
function split(source) {
  if (!source)
    return [];
  return source.split(",").flatMap((value) => {
    if (!value.includes(".."))
      return +value;
    const capture = value.split("..");
    const start = +capture[0], end = +capture[1];
    if (end < start)
      return [];
    return new Array(end - start + 1).fill(0).map((_, index) => start + index);
  });
}
__name(split, "split");
function equal(array1, array2) {
  return array1.slice().sort().join() === array2.slice().sort().join();
}
__name(equal, "equal");
var RE_DIALOGUES = /^\d+(\.\.\d+)?(,\d+(\.\.\d+)?)*$/;
var _OrderedList = class _OrderedList {
  output = [];
  add(text, order) {
    order != null ? order : order = 0;
    const index = this.output.findIndex((a) => a[1] < order);
    if (index >= 0) {
      this.output.splice(index, 0, [text, order]);
    } else {
      this.output.push([text, order]);
    }
  }
  toString() {
    return this.output.map((entry) => entry[0]).join("\n");
  }
};
__name(_OrderedList, "OrderedList");
var OrderedList = _OrderedList;

// external/dialogue/packages/core/src/command.ts
var cheatSheet = /* @__PURE__ */ __name((session, config) => {
  var _a, _b;
  const { authority } = session.user;
  const { authority: a, prefix: p } = config;
  const l = p[p.length - 1];
  const output = new OrderedList();
  output.add(`教学系统基本用法：
　添加问答：${p} 问题 回答
　搜索回答：${p}${l} 问题
　搜索问题：${p}${l} ~ 回答
　查看问答：${p}id
　修改问题：${p}id 问题
　修改回答：${p}id ~ 回答
　删除问答：${p}id -r
　批量查看：${p}${l}id
搜索选项：
　管道语法：　　　|
　结果页码：　　　/ page
　禁用递归查询：　-R${authority >= a.regExp ? `
　正则+合并结果：${p}${l}${l}` : ""}`, 1e3);
  output.add("问答选项：", 600);
  output.add(`　忽略智能提示：　-I
　重定向：　　　　=>`, 510);
  output.add("匹配规则：", 500);
  if (authority >= a.regExp) {
    output.add("　正则表达式：　　-x/-X", 490);
  }
  output.add(`　严格匹配权重：　-p prob
　称呼匹配权重：　-P prob`, 480);
  output.add(`回退功能：
　查看近期改动：　-v
　回退近期改动：　-V
　设置查看区间：　-l/-L
特殊语法：
　$$：一个普通的 $ 字符
　$0：收到的原文本
　$n：分条发送
　$a：@说话人
　$m：@${(_b = (_a = session.app.config.nickname) == null ? void 0 : _a[0]) != null ? _b : session.bot.user.name}
　$s：说话人的名字
　$()：指令插值
　\${}：表达式插值`, 0);
  session.app.emit("dialogue/usage", output, session);
  return output.toString();
}, "cheatSheet");
function command(ctx, config) {
  const { prefix } = config;
  const g = "\\d+(?:\\.\\.\\d+)?";
  const last = prefix[prefix.length - 1];
  const p = (0, import_koishi2.escapeRegExp)(prefix);
  const l = (0, import_koishi2.escapeRegExp)(last);
  const teachRegExp = new RegExp(`^${p}(${l}?)((${g}(?:,${g})*)?|${l}?)$`);
  ctx.before("parse", (content, session) => {
    const argv = import_koishi2.Argv.parse(content);
    if (session.quote || !argv.tokens.length)
      return;
    let prefix2 = argv.tokens[0].content;
    if (session.stripped.prefix) {
      prefix2 = session.stripped.prefix + prefix2;
    }
    try {
      import_koishi2.segment.transform(prefix2, {
        text: true,
        default: () => {
          throw new Error();
        }
      });
    } catch {
      return;
    }
    prefix2 = import_koishi2.segment.unescape(prefix2);
    const capture = teachRegExp.exec(prefix2);
    if (!capture)
      return;
    argv.tokens.shift();
    argv.tokens.forEach(import_koishi2.Argv.revert);
    argv.source = session.stripped.content;
    argv.options = {};
    const { length } = argv.tokens;
    if (capture[1] === last) {
      if (!argv.tokens.length) {
        argv.name = "dialogue.stats";
        return argv;
      }
      argv.options.action = "search";
      if (capture[2] === last) {
        argv.options.autoMerge = true;
        argv.options.regexp = true;
      }
    } else if (!capture[2] && !length) {
      argv.options.help = true;
    }
    if (capture[2] && capture[2] !== last) {
      argv.options.target = (0, import_koishi2.deduplicate)(split(capture[2]));
    }
    argv.name = "teach";
    return argv;
  });
  ctx.command("teach", { authority: config.authority.base, checkUnknown: true, hideOptions: true }).userFields(["authority", "id"]).option("target", "").usage((session) => cheatSheet(session, config)).before(({ session }) => {
    return ctx.serial("dialogue/before-action", session);
  }, true).action(({ session }) => {
    return ctx.bail("dialogue/action", session);
  });
}
__name(command, "command");

// external/dialogue/packages/core/src/receiver.ts
var import_koishi3 = require("koishi");
function escapeAnswer(message) {
  return message.replace(/\$/g, "@@__PLACEHOLDER__@@");
}
__name(escapeAnswer, "escapeAnswer");
function unescapeAnswer(message) {
  return message.replace(/@@__PLACEHOLDER__@@/g, "$");
}
__name(unescapeAnswer, "unescapeAnswer");
import_koishi3.Context.prototype.getSessionState = function(session) {
  const { channelId, userId, app } = session;
  if (!app.dialogue.states[channelId]) {
    this.emit("dialogue/state", app.dialogue.states[channelId] = { channelId });
  }
  const state = Object.create(app.dialogue.states[channelId]);
  state.session = session;
  state.userId = userId;
  return state;
};
async function getTotalWeight(ctx, state) {
  const { session, dialogues } = state;
  ctx.emit(session, "dialogue/prepare", state);
  const userFields = /* @__PURE__ */ new Set(["name", "flag"]);
  ctx.emit(session, "dialogue/before-attach-user", state, userFields);
  await session.observeUser(userFields);
  if (ctx.bail(session, "dialogue/attach-user", state))
    return 0;
  return dialogues.reduce((prev, curr) => prev + curr._weight, 0);
}
__name(getTotalWeight, "getTotalWeight");
var _MessageBuffer = class _MessageBuffer {
  constructor(session) {
    this.session = session;
    this.send = session.send.bind(session);
    this.sendQueued = session.sendQueued.bind(session);
    session.send = async (message) => {
      if (!message)
        return;
      this.hasData = true;
      if (this.original) {
        return this.send(message);
      }
      this.buffer += message;
    };
    session.sendQueued = async (message, delay) => {
      if (!message)
        return;
      this.hasData = true;
      if (this.original) {
        return this.sendQueued(message, delay);
      }
      return this._flush(this.buffer + message, delay);
    };
  }
  buffer = "";
  original = false;
  hasData = false;
  send;
  sendQueued;
  write(message) {
    if (!message)
      return;
    this.hasData = true;
    this.buffer += message;
  }
  async _flush(message, delay) {
    this.original = true;
    message = message.trim();
    const result = await this.sendQueued(message, delay);
    this.buffer = "";
    this.original = false;
    return result;
  }
  flush() {
    return this._flush(this.buffer);
  }
  async execute(argv) {
    this.original = false;
    const send = this.session.send;
    const sendQueued = this.session.sendQueued;
    await this.session.execute(argv);
    this.session.sendQueued = sendQueued;
    this.session.send = send;
    this.original = true;
  }
  async end(message = "") {
    this.write(message);
    await this.flush();
    this.original = true;
    delete this.session.send;
    delete this.session.sendQueued;
  }
};
__name(_MessageBuffer, "MessageBuffer");
var MessageBuffer = _MessageBuffer;
var tokenizer = new import_koishi3.Argv.Tokenizer();
tokenizer.interpolate("$n", "", (rest) => {
  return { rest, tokens: [], source: "" };
});
async function triggerDialogue(ctx, session, next = import_koishi3.noop) {
  if (!session.content)
    return;
  const state = ctx.getSessionState(session);
  state.next = next;
  state.test = {};
  if (ctx.bail("dialogue/receive", state))
    return next();
  const logger = ctx.logger("dialogue");
  logger.debug("[receive]", session.content);
  const dialogues = state.dialogues = await ctx.root.dialogue.get(state.test);
  let dialogue;
  const total = await getTotalWeight(ctx, state);
  if (!total)
    return next();
  const target = import_koishi3.Random.real(Math.max(1, total));
  let pointer = 0;
  for (const _dialogue of dialogues) {
    pointer += _dialogue._weight;
    if (target < pointer) {
      dialogue = _dialogue;
      break;
    }
  }
  if (!dialogue)
    return next();
  logger.debug("[attach]", session.messageId);
  state.dialogue = dialogue;
  state.dialogues = [dialogue];
  state.answer = dialogue.answer.replace(/\$\$/g, "@@__PLACEHOLDER__@@").replace(/\$A/g, (0, import_koishi3.segment)("at", { type: "all" }).toString()).replace(/\$a/g, (0, import_koishi3.segment)("at", { id: session.userId }).toString()).replace(/\$m/g, (0, import_koishi3.segment)("at", { id: session.selfId }).toString()).replace(/\$s/g, () => escapeAnswer(session.username)).replace(/\$0/g, escapeAnswer(session.content));
  if (dialogue.flag & Dialogue.Flag.regexp) {
    const capture = dialogue._capture || new RegExp(dialogue.original, "i").exec(state.test.original);
    if (!capture)
      return;
    capture.forEach((segment5, index2) => {
      if (index2 && index2 <= 9) {
        state.answer = state.answer.replace(new RegExp(`\\$${index2}`, "g"), escapeAnswer(segment5 || ""));
      }
    });
  }
  if (await ctx.serial(session, "dialogue/before-send", state))
    return;
  logger.debug("[send]", session.messageId, "->", dialogue.answer);
  const buffer = new MessageBuffer(session);
  session._redirected = (session._redirected || 0) + 1;
  let index;
  const { content, inters } = tokenizer.parseToken(unescapeAnswer(state.answer));
  while (inters.length) {
    const argv = inters.shift();
    buffer.write(content.slice(index, argv.pos));
    if (argv.initiator === "$n") {
      await buffer.flush();
    } else {
      await buffer.execute(argv);
    }
    index = argv.pos;
  }
  await buffer.end(content.slice(index));
  await ctx.parallel(session, "dialogue/send", state);
}
__name(triggerDialogue, "triggerDialogue");
function receiver(ctx, config) {
  const { maxRedirections = 3 } = config;
  const ctx2 = ctx.guild();
  ctx.before("attach", (session) => {
    if (session.stripped.appel)
      return;
    const { activated } = ctx.getSessionState(session);
    if (activated[session.userId])
      session.stripped.appel = true;
  });
  ctx2.middleware(async (session, next) => {
    return await triggerDialogue(ctx, session, next);
  });
  ctx.on("notice/poke", async (session) => {
    if (session.targetId !== session.selfId)
      return;
    const { flag } = await session.observeChannel(["flag"]);
    if (flag & import_koishi3.Channel.Flag.ignore)
      return;
    session.content = "hook:poke";
    await triggerDialogue(ctx, session);
  });
  async function triggerNotice(name2, session) {
    const { flag, assignee } = await session.observeChannel(["flag", "assignee"]);
    if (assignee !== session.selfId)
      return;
    if (flag & import_koishi3.Channel.Flag.ignore)
      return;
    session.content = "hook:" + name2 + (session.userId === session.selfId ? ":self" : ":others");
    await triggerDialogue(ctx, session);
  }
  __name(triggerNotice, "triggerNotice");
  ctx.on("notice/honor", async (session) => {
    await triggerNotice(session.subsubtype, session);
  });
  ctx.on("guild-member-added", triggerNotice.bind(null, "join"));
  ctx.on("guild-member-removed", triggerNotice.bind(null, "leave"));
  ctx.on("dialogue/receive", ({ session }) => {
    var _a;
    if (((_a = session.user) == null ? void 0 : _a.authority) < config.authority.receive)
      return true;
  });
  ctx.on("dialogue/receive", ({ session, test }) => {
    if (session.content.includes("<image "))
      return true;
    const { appel, content } = session.stripped;
    if (!content && !appel)
      return true;
    const { original, parsed, appellative, activated } = ctx.root.dialogue.stripQuestion(content);
    test.question = parsed;
    test.original = original;
    test.activated = activated;
    test.appellative = appellative || appel;
  });
  ctx.before("dialogue/attach-user", ({ dialogues, session }, userFields) => {
    for (const data of dialogues) {
      const { inters } = tokenizer.parseToken(data.answer);
      for (const argv of inters) {
        session.collect("user", argv, userFields);
      }
    }
  });
  ctx2.command("dialogue <message:text>").action(async ({ session }, message = "") => {
    if (session._redirected > maxRedirections)
      return;
    session.content = message;
    return await triggerDialogue(ctx, session);
  });
}
__name(receiver, "receiver");

// external/dialogue/packages/core/src/search.ts
function apply(ctx) {
  ctx.command("dialogue.stats").action(async ({ session }) => {
    const stats = await ctx.root.dialogue.stats();
    return session.text(".output", stats);
  });
  ctx.command("teach").option("page", "/ <page:posint>").option("autoMerge", "").option("recursive", "-R", { value: false }).option("pipe", "| <op:text>");
  ctx.on("dialogue/appendix", ({ _redirections }, output, prefix, argv) => {
    if (!_redirections)
      return;
    output.push(...formatAnswers(argv, _redirections, prefix + "= "));
  });
  ctx.on("dialogue/abstract", ({ flag }, output) => {
    if (flag & Dialogue.Flag.regexp) {
      output.questionType = "regexp";
    }
  });
  ctx.before("dialogue/search", ({ argv }, test) => {
    test.noRecursive = argv.options.recursive === false;
  });
  ctx.before("dialogue/search", ({ argv }, test) => {
    test.appellative = argv.options.appellative;
  });
  ctx.on("dialogue/search", async (session, test, dialogues) => {
    const { options } = session.argv;
    if (!options.questionMap) {
      options.questionMap = { [test.question]: dialogues };
    }
    for (const dialogue of dialogues) {
      const { answer } = dialogue;
      if (!answer.startsWith("%{dialogue "))
        continue;
      const { original, parsed } = ctx.root.dialogue.stripQuestion(answer.slice(11, -1).trimStart());
      if (parsed in options.questionMap)
        continue;
      const dialogues2 = options.questionMap[parsed] = await ctx.root.dialogue.get({
        ...test,
        regexp: null,
        question: parsed,
        original
      });
      Object.defineProperty(dialogue, "_redirections", { writable: true, value: dialogues2 });
      await ctx.parallel("dialogue/search", session, test, dialogues2);
    }
  });
  ctx.on("dialogue/action", (session) => {
    const { options } = session.argv;
    if (options.action !== "search")
      return;
    return showSearch(session);
  }, true);
}
__name(apply, "apply");
async function showSearch(session) {
  const app = session.app;
  const { options, args: [question, answer] } = session.argv;
  const { regexp, page = 1, original, pipe, recursive, autoMerge } = options;
  const { itemsPerPage = 30, mergeThreshold = 5 } = app.dialogue.config;
  const test = { question, answer, regexp, original };
  if (app.bail("dialogue/before-search", session, test))
    return "";
  const dialogues = await app.dialogue.get(test);
  if (pipe) {
    if (!dialogues.length)
      return session.text(".search.empty");
    const command2 = app.command("teach");
    const argv = { ...command2.parse(pipe), session, command: command2 };
    const target = argv.options["target"] = dialogues.map((d) => d.id).join(",");
    argv.source = `#${target} ${pipe}`;
    return command2.execute(argv);
  }
  if (recursive !== false && !autoMerge) {
    await app.parallel("dialogue/search", session, test, dialogues);
  }
  if (!original && !answer) {
    if (!dialogues.length)
      return sendEmpty(".search.empty-all");
    return sendResult2(".search.result-all", app.dialogue.list(session, dialogues));
  }
  if (!options.regexp) {
    const hint = options.regexp !== false ? session.text(".search.regexp-hint") : "";
    if (!original) {
      if (!dialogues.length)
        return sendEmpty(".search.empty-answer", hint);
      const output2 = dialogues.map((d) => `${formatPrefix(session, d)}${d.original}`);
      return sendResult2(".search.result-answer", output2);
    } else if (!answer) {
      if (!dialogues.length)
        return sendEmpty(".search.empty-question", hint);
      const output2 = formatAnswers(session, dialogues);
      const state = app.getSessionState(session);
      state.isSearch = true;
      state.test = test;
      state.dialogues = dialogues;
      const total = await getTotalWeight(app, state);
      const epilog = dialogues.length > 1 ? session.text(".search.probability") + Math.min(total, 1).toFixed(3) : "";
      return sendResult2(".search.result-question", output2, epilog);
    } else {
      if (!dialogues.length)
        return sendEmpty(".search.empty-dialogue", hint);
      const output2 = [dialogues.map((d) => d.id).join(", ")];
      return sendResult2(".search.result-dialogue", output2);
    }
  }
  let output;
  if (!autoMerge || question && answer) {
    output = app.dialogue.list(session, dialogues);
  } else {
    const idMap = {};
    for (const dialogue of dialogues) {
      const key = question ? dialogue.original : dialogue.answer;
      if (!idMap[key])
        idMap[key] = [];
      idMap[key].push(dialogue.id);
    }
    const type = session.text("commands.teach.messages.entity." + (question ? "answer" : "question"));
    output = Object.keys(idMap).map((key) => {
      const { length } = idMap[key];
      return length <= mergeThreshold ? `${key} (#${idMap[key].join(", #")})` : `${key} (${session.text(".search.count", [length])}${type})`;
    });
  }
  if (!original) {
    if (!dialogues.length)
      return sendEmpty(".search.empty-regexp-answer");
    return sendResult2(".search.result-regexp-answer", output);
  } else if (!answer) {
    if (!dialogues.length)
      return sendEmpty(".search.empty-regexp-question");
    return sendResult2(".search.result-regexp-question", output);
  } else {
    if (!dialogues.length)
      return sendEmpty(".search.empty-regexp-dialogue");
    return sendResult2(".search.result-regexp-dialogue", output);
  }
  function sendEmpty(path, hint) {
    return session.text(path, [original, answer, hint]);
  }
  __name(sendEmpty, "sendEmpty");
  function sendResult2(path, output2, suffix) {
    if (output2.length <= itemsPerPage) {
      output2.unshift(session.text(path, [original, answer]));
      if (suffix)
        output2.push(suffix);
    } else {
      const pageCount = Math.ceil(output2.length / itemsPerPage);
      output2 = output2.slice((page - 1) * itemsPerPage, page * itemsPerPage);
      const hint = session.text(".search.page-hint", [page, pageCount]);
      output2.unshift(session.text(path, [original, answer, hint]));
      if (suffix)
        output2.push(suffix);
      output2.push(session.text(".search.page-footer"));
    }
    return output2.join("\n");
  }
  __name(sendResult2, "sendResult");
}
__name(showSearch, "showSearch");

// external/dialogue/packages/core/src/update.ts
var import_koishi4 = require("koishi");
function apply2(ctx) {
  ctx.command("teach").option("action", "-r", { value: "remove" });
  ctx.on("dialogue/action", (session) => {
    const { options } = session.argv;
    if (!options.target)
      return;
    return analyze(session);
  }, true);
  ctx.on("dialogue/action", (session) => {
    return create(session);
  });
  ctx.before("dialogue/detail", async (session) => {
    const { action, dialogues } = session.argv.options;
    if (action === "modify")
      return;
    await ctx.parallel("dialogue/search", session, {}, dialogues);
  });
  ctx.on("dialogue/detail", ({ original, answer, flag }, detail, session) => {
    const entity = session.text(`.entity.${flag & Dialogue.Flag.regexp ? "regexp" : "question"}`);
    detail.add(session.text(".detail", [entity, import_koishi4.h.parse(original)]), 1100);
    detail.add(session.text(".detail", [session.text(".entity.answer"), import_koishi4.h.parse(answer)]), 1e3);
  });
}
__name(apply2, "apply");
async function handleError(session, callback) {
  try {
    return await callback(session);
  } catch (err) {
    const { action } = session.argv.options;
    session.app.logger("dialogue").warn(err);
    return session.text(".unknown-error", [session.text(`.operation.${action}`)]);
  }
}
__name(handleError, "handleError");
function prepareTargets(session, dialogues) {
  const { options } = session.argv;
  dialogues || (dialogues = options.dialogues);
  const targets = dialogues.filter((dialogue) => {
    return !session.app.bail("dialogue/permit", session, dialogue);
  });
  options.forbidden.unshift(...(0, import_koishi4.difference)(dialogues, targets).map((d) => d.id));
  return targets.map((dialogue) => (0, import_koishi4.observe)(dialogue));
}
__name(prepareTargets, "prepareTargets");
function prepareModifyOptions(session) {
  const { options } = session.argv;
  options.forbidden = [];
  options.updated = [];
  options.skipped = [];
}
__name(prepareModifyOptions, "prepareModifyOptions");
async function analyze(session) {
  const app = session.app;
  const { options, args } = session.argv;
  const { maxPreviews = 10, previewDelay = 500 } = app.dialogue.config;
  const { target, action } = options;
  if (!options.action && (Object.keys(options).length > 1 || args.length)) {
    options.action = "modify";
  } else if (!options.action && target.length > maxPreviews) {
    return session.text(".max-previews", [maxPreviews]);
  }
  prepareModifyOptions(session);
  const dialogues = options.dialogues = action === "review" || action === "revert" ? Object.values((0, import_koishi4.pick)(app.dialogue.history, target)).filter(Boolean) : await app.dialogue.get(target);
  options.dialogueMap = Object.fromEntries(dialogues.map((d) => [d.id, { ...d }]));
  const actualIds = options.dialogues.map((d) => d.id);
  options.unknown = (0, import_koishi4.difference)(target, actualIds);
  await app.serial("dialogue/before-detail", session);
  if (!options.action) {
    if (options.unknown.length) {
      await session.send(session.text(`.${options.action === "review" ? "revert" : "modify"}-unknown`, [options.unknown.join(", ")]));
    }
    for (let index = 0; index < dialogues.length; index++) {
      const type = session.text(`.entity.${options.action === "review" ? "history" : "detail"}`);
      const detail = new OrderedList();
      detail.add(session.text(".detail-header", [dialogues[index].id, type]), Infinity);
      app.emit("dialogue/detail", dialogues[index], detail, session);
      if (index)
        await (0, import_koishi4.sleep)(previewDelay);
      await session.send(detail.toString());
    }
    return "";
  }
  return handleError(session, async () => {
    const targets = prepareTargets(session);
    if (action === "revert") {
      const message = targets.length ? await app.dialogue.revert(targets, session) : "";
      return sendResult(session, message);
    }
    if (action === "remove") {
      let message = "";
      if (targets.length) {
        const editable = await app.dialogue.remove(targets, session);
        message = session.text(".remove-success", [editable.join(", ")]);
      }
      await app.serial("dialogue/after-modify", session);
      return sendResult(session, message);
    }
    if (targets.length) {
      const result = await app.serial("dialogue/before-modify", session);
      if (typeof result === "string")
        return result;
      for (const dialogue of targets) {
        app.emit("dialogue/modify", session, dialogue);
      }
      await app.dialogue.update(targets, session);
      await app.serial("dialogue/after-modify", session);
    }
    return await sendResult(session);
  });
}
__name(analyze, "analyze");
async function create(session) {
  const { options, args: [question, answer] } = session.argv;
  const app = session.app;
  options.action = "create";
  options.unknown = [];
  prepareModifyOptions(session);
  options.dialogues = await app.dialogue.get({ question, answer, regexp: false });
  await app.serial("dialogue/before-detail", session);
  const result = await app.serial("dialogue/before-modify", session);
  if (typeof result === "string")
    return result;
  if (options.dialogues.length) {
    options.target = options.dialogues.map((d) => d.id);
    options.dialogueMap = Object.fromEntries(options.dialogues.map((d) => [d.id, d]));
    const targets = prepareTargets(session);
    for (const dialogue2 of targets) {
      app.emit("dialogue/modify", session, dialogue2);
    }
    await app.dialogue.update(targets, session);
    await app.serial("dialogue/after-modify", session);
    return sendResult(session);
  }
  const dialogue = { flag: 0 };
  if (app.bail("dialogue/permit", session, dialogue)) {
    return session.text(".low-permission");
  }
  return handleError(session, async () => {
    app.emit("dialogue/modify", session, dialogue);
    const created = await app.database.create("dialogue", dialogue);
    app.dialogue.addHistory(dialogue, "create", session, false);
    options.dialogues = [created];
    await app.serial("dialogue/after-modify", session);
    return sendResult(session, session.text(".create-success", [options.dialogues[0].id]));
  });
}
__name(create, "create");
function sendResult(session, prolog, epilog) {
  const { prefix } = session.app.dialogue.config;
  const { action, forbidden, unknown, skipped, updated, target } = session.argv.options;
  const output = [];
  if (prolog)
    output.push(prolog);
  if (updated.length) {
    if (action === "create") {
      output.push(session.text(".create-modified", [updated.join(", ")]));
    } else {
      output.push(session.text(".modify-success", [updated.join(", ")]));
    }
  }
  if (skipped.length) {
    if (action === "create") {
      output.push(session.text(".create-unchanged", [target.join(", "), prefix + skipped.join(",")]));
    } else {
      output.push(session.text(".unchanged", [skipped.join(", ")]));
    }
  }
  if (forbidden.length) {
    const operation = session.text(".operation." + (action === "create" ? "modify" : action));
    output.push(session.text(".permission-denied", [forbidden.join(", "), operation]));
  }
  if (unknown.length) {
    output.push(session.text(`.${action === "revert" ? "revert" : "modify"}-unknown`, [unknown.join(", ")]));
  }
  if (epilog)
    output.push(epilog);
  return output.join("\n");
}
__name(sendResult, "sendResult");

// external/dialogue/packages/core/src/review.ts
var import_koishi5 = require("koishi");
function apply3(ctx) {
  ctx.command("teach").option("action", "-v", { value: "review" }).option("action", "-V", { value: "revert" }).option("includeLast", "-l [count]", { type: isIntegerOrInterval }).option("excludeLast", "-L [count]", { type: isIntegerOrInterval });
  ctx.on("dialogue/action", (session) => {
    const { options } = session.argv;
    const { includeLast, excludeLast, action, target } = options;
    if (action !== "review" && action !== "revert" || target)
      return;
    const now = Date.now(), includeTime = import_koishi5.Time.parseTime(includeLast), excludeTime = import_koishi5.Time.parseTime(excludeLast);
    const dialogues = Object.values(ctx.dialogue.history).filter((dialogue) => {
      if (dialogue._operator !== session.userId)
        return;
      const offset = now - dialogue._timestamp;
      if (includeTime && offset >= includeTime)
        return;
      if (excludeTime && offset < excludeTime)
        return;
      return true;
    }).sort((d1, d2) => d2._timestamp - d1._timestamp).filter((_, index, temp) => {
      if (!includeTime && includeLast && index >= +includeLast)
        return;
      if (!excludeTime && excludeLast && index < temp.length - +excludeLast)
        return;
      return true;
    });
    if (!dialogues.length)
      return session.text(".no-history");
    if (action === "review") {
      const output = dialogues.map((dialogue) => {
        return session.app.dialogue.formatDialogue(session, dialogue);
      });
      output.unshift(session.text(".recent-history"));
      return output.join("\n");
    }
    return handleError(session, () => {
      return session.app.dialogue.revert(dialogues, session);
    });
  }, true);
  ctx.on("dialogue/abstract", ({ _type, _timestamp }, output, session) => {
    if (!_type)
      return;
    output.unshift(`${session.text(`.operation.${_type}`)}-${import_koishi5.Time.format(Date.now() - _timestamp)}`);
  });
  ctx.on("dialogue/detail", ({ _type, _timestamp }, detail, session) => {
    if (!_type)
      return;
    detail.add(session.text(".review", [
      session.text(`.operation.${_type}`),
      Date.now() - _timestamp
    ]), -100);
  });
}
__name(apply3, "apply");
function isIntegerOrInterval(source) {
  const n = +source;
  if (n * 0 === 0) {
    if ((0, import_koishi5.isInteger)(n) && n > 0)
      return n;
    throw new Error();
  } else {
    if (import_koishi5.Time.parseTime(source))
      return source;
    throw new Error();
  }
}
__name(isIntegerOrInterval, "isIntegerOrInterval");

// external/dialogue/packages/core/src/internal.ts
var import_koishi6 = require("koishi");
var import_fastest_levenshtein = require("fastest-levenshtein");
function apply4(ctx, config) {
  ctx.command("teach").option("ignoreHint", "-I").option("regexp", "-x", { authority: config.authority.regExp }).option("regexp", "-X", { value: false }).option("redirect", "=> <answer:string>");
  ctx.before("dialogue/action", (session) => {
    function parseArgument() {
      if (!args.length)
        return "";
      const arg = args.shift();
      if (!arg || arg === "~" || arg === "～")
        return "";
      return arg.trim();
    }
    __name(parseArgument, "parseArgument");
    const { options, args } = session.argv;
    let question = parseArgument();
    const answer = options.redirect ? `$(dialogue ${options.redirect})` : parseArgument();
    if (args.length)
      return session.text(".too-many-arguments");
    try {
      question = import_koishi6.segment.transform(question, {
        text: true,
        face: true,
        default() {
          throw new Error();
        }
      });
    } catch {
      return session.text(".prohibited-cq-code");
    }
    const { original, parsed, appellative } = options.regexp ? { original: import_koishi6.segment.unescape(question), parsed: question, appellative: false } : ctx.root.dialogue.stripQuestion(question);
    (0, import_koishi6.defineProperty)(options, "appellative", appellative);
    (0, import_koishi6.defineProperty)(options, "original", original);
    args[0] = parsed;
    args[1] = answer;
    if (!args[0] && !args[1])
      args.splice(0, Infinity);
  });
  function maybeAnswer(question, dialogues) {
    return dialogues.every((dialogue) => {
      const dist = (0, import_fastest_levenshtein.distance)(question, dialogue.answer);
      return dist < dialogue.answer.length / 2 && dist < (0, import_fastest_levenshtein.distance)(question, dialogue.question);
    });
  }
  __name(maybeAnswer, "maybeAnswer");
  function maybeRegExp(question) {
    return question.startsWith("^") || question.endsWith("$");
  }
  __name(maybeRegExp, "maybeRegExp");
  ctx.before("dialogue/modify", async (session) => {
    const { options, args } = session.argv;
    const { ignoreHint, regexp, target, dialogues } = options;
    const [question, answer] = args;
    function applySuggestion(session2) {
      const sess = session2.bot.session(session2.event);
      sess.user = session2.user;
      sess.channel = session2.channel;
      sess.guild = session2.guild;
      sess.argv = session2.argv;
      return sess.withScope("commands.teach.messages", () => {
        return session2.argv.options.target ? analyze(sess) : create(sess);
      });
    }
    __name(applySuggestion, "applySuggestion");
    if (target && !ignoreHint && question && !answer && maybeAnswer(question, dialogues)) {
      const dispose = session.middleware(({ content }, next) => {
        dispose();
        content = content.trim();
        if (content && content !== "." && content !== "。")
          return next();
        args[1] = options.original;
        args[0] = "";
        return applySuggestion(session);
      });
      return session.text(".probably-modify-answer");
    }
    if (question && !regexp && maybeRegExp(question) && !ignoreHint && (!target || !dialogues.every((d) => d.flag & Dialogue.Flag.regexp))) {
      const dispose = session.middleware(({ content }, next) => {
        dispose();
        content = content.trim();
        if (content && content !== "." && content !== "。")
          return next();
        options.regexp = true;
        return applySuggestion(session);
      });
      const operation = session.text(".operation", [target ? "modify" : "create"]);
      return session.text(".probably-regexp", [operation]);
    }
    if (regexp || regexp !== false && question && dialogues.some((d) => d.flag & Dialogue.Flag.regexp)) {
      const questions = question ? [question] : dialogues.map((d) => d.question);
      try {
        questions.forEach((q) => new RegExp(q));
      } catch (error) {
        return session.text(".illegal-regexp");
      }
    }
  });
  ctx.before("dialogue/modify", async (session) => {
    const { options, args } = session.argv;
    if (options.action === "create" && !options.target && !(args[0] && args[1])) {
      return session.text(".missing-question-or-answer");
    }
  });
  ctx.on("dialogue/modify", (session, data) => {
    const { args, options } = session.argv;
    if (args[1]) {
      data.answer = args[1];
    }
    if (options.regexp !== void 0) {
      data.flag = data.flag & ~Dialogue.Flag.regexp | +options.regexp * Dialogue.Flag.regexp;
    }
    if (args[0]) {
      data.question = args[0];
      data.original = options.original;
    }
  });
  ctx.on("dialogue/detail", async (dialogue, detail, session) => {
    var _a;
    if ((_a = dialogue._redirections) == null ? void 0 : _a.length) {
      detail.add([
        session.text(".redirections"),
        ...ctx.dialogue.list(session, dialogue._redirections)
      ].join("\n"), -1e3);
    }
  });
  ctx.before("command/execute", ({ command: command2, session }) => {
    if (command2.config.noInterp && session._redirected) {
      return session.text(".prohibited-command", [command2.name]);
    }
  });
  ctx.before("dialogue/modify", async (session) => {
    const { args } = session.argv;
    const assets = ctx.get("assets");
    if (!args[1] || !assets)
      return;
    try {
      args[1] = await assets.transform(args[1]);
    } catch (error) {
      ctx.logger("teach").warn(error);
      return session.text(".upload-failed");
    }
  });
  ctx.on("dialogue/query", ({ regexp, answer, question, original }, query) => {
    if (regexp) {
      if (answer)
        query.answer = { $regex: new RegExp(answer, "i") };
      if (original)
        query.original = { $regex: new RegExp(original, "i") };
      return;
    }
    if (answer)
      query.answer = answer;
    if (regexp === false) {
      if (question)
        query.question = question;
    } else if (original) {
      const $or = [{
        flag: { $bitsAllSet: Dialogue.Flag.regexp },
        original: { $regexFor: original }
      }];
      if (question)
        $or.push({ flag: { $bitsAllClear: Dialogue.Flag.regexp }, question });
      query.$and.push({ $or });
    }
  });
}
__name(apply4, "apply");

// external/dialogue/packages/core/src/probability.ts
function isZeroToOne(source) {
  const n = +source;
  if (n >= 0 && n <= 1)
    return n;
  throw new Error("commands.teach.messages.probability.zero-to-one");
}
__name(isZeroToOne, "isZeroToOne");
function probability(ctx, config) {
  const { appellationTimeout = 2e4 } = config;
  ctx.command("teach").option("probabilityStrict", "-p <prob>", { type: isZeroToOne }).option("probabilityAppellative", "-P <prob>", { type: isZeroToOne });
  ctx.on("dialogue/modify", (session, data) => {
    var _a, _b;
    const { options } = session.argv;
    if (options.action === "create") {
      data.probS = (_a = options.probabilityStrict) != null ? _a : 1 - +options.appellative;
      data.probA = (_b = options.probabilityAppellative) != null ? _b : +options.appellative;
    } else {
      if (options.probabilityStrict !== void 0) {
        data.probS = options.probabilityStrict;
      }
      if (options.probabilityAppellative !== void 0) {
        data.probA = options.probabilityAppellative;
      }
    }
  });
  ctx.on("dialogue/state", (state) => {
    state.activated = {};
  });
  ctx.on("dialogue/prepare", ({ test, userId, dialogues, activated }) => {
    const hasNormal = dialogues.some((d) => !(d.flag & Dialogue.Flag.regexp));
    dialogues.forEach((dialogue) => {
      if (hasNormal && dialogue.flag & Dialogue.Flag.regexp) {
        dialogue._weight = 0;
      } else if (userId in activated) {
        dialogue._weight = Math.max(dialogue.probS, dialogue.probA);
      } else if (!test.appellative || !(dialogue.flag & Dialogue.Flag.regexp)) {
        dialogue._weight = test.appellative ? dialogue.probA : dialogue.probS;
      } else {
        const regexp = new RegExp(dialogue.question);
        const queue = dialogue.probS >= dialogue.probA ? [[test.original, dialogue.probS], [test.question, dialogue.probA]] : [[test.question, dialogue.probA], [test.original, dialogue.probS]];
        for (const [question, weight] of queue) {
          dialogue._capture = regexp.exec(question);
          dialogue._weight = weight;
          if (dialogue._capture)
            break;
        }
      }
    });
  });
  ctx.before("dialogue/send", ({ test, activated, userId }) => {
    if (!test.activated)
      return;
    const time = activated[userId] = Date.now();
    setTimeout(() => {
      if (activated[userId] === time) {
        delete activated[userId];
      }
    }, appellationTimeout);
  });
  ctx.on("dialogue/detail", (dialogue, detail, session) => {
    const { probS, probA } = dialogue;
    if (probS < 1 || probA > 0) {
      detail.add(session.text(".probability.detail", dialogue), 900);
    }
  });
  ctx.on("dialogue/abstract", ({ probS, probA }, output) => {
    if (probS < 1)
      output.push(`p=${probS}`);
    if (probA > 0)
      output.push(`P=${probA}`);
  });
}
__name(probability, "probability");

// external/dialogue/packages/core/src/index.ts
var Dialogue;
((Dialogue2) => {
  let Flag;
  ((Flag2) => {
    Flag2[Flag2["frozen"] = 1] = "frozen";
    Flag2[Flag2["regexp"] = 2] = "regexp";
    Flag2[Flag2["context"] = 4] = "context";
    Flag2[Flag2["substitute"] = 8] = "substitute";
    Flag2[Flag2["complement"] = 16] = "complement";
  })(Flag = Dialogue2.Flag || (Dialogue2.Flag = {}));
})(Dialogue || (Dialogue = {}));
var schema = import_koishi7.Schema.intersect([
  import_koishi7.Schema.object({
    prefix: import_koishi7.Schema.string().description("教学指令的前缀。").default("#"),
    historyTimeout: import_koishi7.Schema.natural().role("ms").description("教学操作在内存中的保存时间。").default(import_koishi7.Time.minute * 10)
  }).description("通用设置"),
  import_koishi7.Schema.object({
    authority: import_koishi7.Schema.object({
      base: import_koishi7.Schema.natural().description("可访问教学系统的权限等级。").default(2),
      admin: import_koishi7.Schema.natural().description("可修改非自己创建的问答的权限等级。").default(3),
      context: import_koishi7.Schema.natural().description("可修改上下文设置的权限等级。").default(3),
      frozen: import_koishi7.Schema.natural().description("可修改锁定的问答的权限等级。").default(4),
      regExp: import_koishi7.Schema.natural().description("可使用正则表达式的权限等级。").default(3),
      writer: import_koishi7.Schema.natural().description("可设置作者或匿名的权限等级。").default(2)
    })
  }).description("权限设置"),
  import_koishi7.Schema.object({
    maxRedirections: import_koishi7.Schema.natural().description("问题重定向的次数上限。").default(3),
    successorTimeout: import_koishi7.Schema.natural().role("ms").description("问答触发后继问答的持续时间。").default(import_koishi7.Time.second * 20),
    appellationTimeout: import_koishi7.Schema.natural().role("ms").description("称呼作为问题触发的后续效果持续时间。").default(import_koishi7.Time.minute * 10)
  }).description("触发设置"),
  import_koishi7.Schema.object({
    maxPreviews: import_koishi7.Schema.natural().description("同时查看的最大问答数量。").default(10),
    previewDelay: import_koishi7.Schema.natural().role("ms").description("显示两个问答之间的时间间隔。").default(import_koishi7.Time.second * 0.5),
    itemsPerPage: import_koishi7.Schema.natural().description("搜索结果每一页显示的最大数量。").default(30),
    maxAnswerLength: import_koishi7.Schema.natural().description("搜索结果中回答显示的长度限制。").default(100),
    mergeThreshold: import_koishi7.Schema.natural().description("合并搜索模式中，相同的问题和回答被合并的最小数量。").default(5)
  }).description("显示设置")
]);
var name = "dialogue";
var inject = ["database"];
function apply5(ctx, config) {
  ctx.i18n.define("zh-CN", require_zh_CN());
  ctx.plugin(DialogueService, config);
  ctx.plugin(command, config);
  ctx.plugin(receiver, config);
  ctx.plugin(apply, config);
  ctx.plugin(apply2, config);
  ctx.plugin(apply3, config);
  ctx.plugin(apply4, config);
  ctx.plugin(probability, config);
}
__name(apply5, "apply");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Dialogue,
  DialogueService,
  MessageBuffer,
  OrderedList,
  RE_DIALOGUES,
  analyze,
  apply,
  create,
  equal,
  escapeAnswer,
  formatAbstract,
  formatAnswer,
  formatAnswers,
  formatPrefix,
  getAbstract,
  getTotalWeight,
  handleError,
  inject,
  isZeroToOne,
  name,
  prepareTargets,
  schema,
  sendResult,
  split,
  triggerDialogue,
  unescapeAnswer
});
//# sourceMappingURL=index.js.map
