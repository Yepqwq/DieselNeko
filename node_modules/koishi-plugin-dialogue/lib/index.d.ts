import * as Koishi from 'koishi';
import { Context, Observed, Service, Argv, Awaitable, Next, segment, Session, User, Dict, Fragment, Query, Schema } from 'koishi';
export function split(source: string): number[];
export function equal(array1: (string | number)[], array2: (string | number)[]): boolean;
export const RE_DIALOGUES: RegExp;
export class OrderedList {
    private output;
    add(text: string, order: number): void;
    toString(): string;
}
export interface Question {
    /** 被 unescape 处理后原本的句子 */
    original: string;
    /** 去除句首句尾标点符号，句中空格和句首称呼的句子 */
    parsed: string;
    /** 是否含有称呼 */
    appellative: boolean;
    /** 是否仅含有称呼 */
    activated: boolean;
}
export class DialogueService extends Service {
    config: Dialogue.Config;
    states: Record<string, SessionState>;
    history: Record<number, Dialogue>;
    nameRE: RegExp;
    constructor(ctx: Context, config: Dialogue.Config);
    flag(flag: keyof typeof Dialogue.Flag): void;
    stats(): Promise<Dialogue.Stats>;
    get(test: DialogueTest): Promise<Dialogue[]>;
    get<K extends Dialogue.Field>(ids: number[], fields?: K[]): Promise<Pick<Dialogue, K>[]>;
    update(dialogues: Observed<Dialogue>[], session: Dialogue.Session): Promise<void>;
    remove(dialogues: Dialogue[], session: Dialogue.Session, revert?: boolean): Promise<number[]>;
    revert(dialogues: Dialogue[], session: Dialogue.Session): Promise<string>;
    recover(dialogues: Dialogue[], session: Dialogue.Session): Promise<void>;
    addHistory(dialogue: Dialogue, type: Dialogue.ModifyType, session: Dialogue.Session, revert: boolean): boolean;
    stripQuestion(source: string): Question;
    formatDialogue(session: Dialogue.Session, dialogue: Dialogue): string;
    list(session: Dialogue.Session, dialogues: Dialogue[], prefix?: string): string[];
}
export function formatAnswer(source: string, { maxAnswerLength }: Dialogue.Config): string;
export interface Abstract extends Array<string> {
    questionType?: string;
    answerType?: string;
}
export function getAbstract(session: Dialogue.Session, dialogue: Dialogue): Abstract;
export function formatAbstract(dialogue: Dialogue, abstract: Abstract): string;
export function formatPrefix(session: Dialogue.Session, dialogue: Dialogue, showAnswerType?: boolean): string;
export function formatAnswers(session: Dialogue.Session, dialogues: Dialogue[], prefix?: string): string[];
declare module 'koishi' {
    interface Events {
        'dialogue/state'(state: SessionState): void;
        'dialogue/receive'(state: SessionState): void | boolean;
        'dialogue/prepare'(state: SessionState): void;
        'dialogue/before-attach-user'(state: SessionState, userFields: Set<User.Field>): void;
        'dialogue/attach-user'(state: SessionState): void | boolean;
        'dialogue/before-send'(state: SessionState): Awaitable<void | boolean>;
        'dialogue/send'(state: SessionState): void;
    }
    interface Context {
        getSessionState(this: Context, session: Session): SessionState;
    }
    interface Session {
        _redirected?: number;
    }
}
export namespace Dialogue {
    interface Config {
        appellationTimeout?: number;
        maxRedirections?: number;
    }
}
export interface SessionState {
    userId?: string;
    channelId?: string;
    answer?: string;
    session?: Session<User.Field>;
    test?: DialogueTest;
    dialogue?: Dialogue;
    dialogues?: Dialogue[];
    next?: Next;
    isSearch?: boolean;
}
export function escapeAnswer(message: string): string;
export function unescapeAnswer(message: string): string;
export function getTotalWeight(ctx: Context, state: SessionState): Promise<number>;
export class MessageBuffer {
    private session;
    private buffer;
    private original;
    hasData: boolean;
    send: Session['send'];
    sendQueued: Session['sendQueued'];
    constructor(session: Session);
    write(message: string): void;
    private _flush;
    flush(): Promise<string[]>;
    execute(argv: Argv): Promise<void>;
    end(message?: string): Promise<void>;
}
export function triggerDialogue(ctx: Context, session: Session, next?: Next): Promise<void | segment.Fragment>;
declare module 'koishi' {
    interface Events {
        'dialogue/before-search'(argv: Dialogue.Session, test: DialogueTest): void | boolean;
        'dialogue/search'(argv: Dialogue.Session, test: DialogueTest, dialogue: Dialogue[]): Promise<void>;
    }
}
export interface Dialogue {
    _redirections: Dialogue[];
}
export namespace Dialogue {
    interface Config {
        itemsPerPage?: number;
        mergeThreshold?: number;
        maxAnswerLength?: number;
    }
    interface Options {
        questionMap?: Dict<Dialogue[]>;
        autoMerge?: boolean;
        recursive?: boolean;
        page?: number;
        pipe?: string;
    }
}
declare module 'koishi' {
    interface Events {
        'dialogue/before-modify'(session: Dialogue.Session): Awaitable<void | string>;
        'dialogue/modify'(session: Dialogue.Session, dialogue: Dialogue): void;
        'dialogue/after-modify'(session: Dialogue.Session): void;
        'dialogue/before-detail'(session: Dialogue.Session): Awaitable<void>;
        'dialogue/detail'(dialogue: Dialogue, detail: OrderedList, session: Dialogue.Session): void;
    }
}
export namespace Dialogue {
    interface Config {
        previewDelay?: number;
        maxPreviews?: number;
    }
    interface Options {
        target?: number[];
    }
}
export function handleError(session: Dialogue.Session, callback: (session: Dialogue.Session) => Promise<string>): Promise<string>;
export function prepareTargets(session: Dialogue.Session, dialogues?: Dialogue[]): import("koishi").Observed<Dialogue, void>[];
export function analyze(session: Dialogue.Session): Promise<string>;
export function create(session: Dialogue.Session): Promise<string>;
export function sendResult(session: Dialogue.Session, prolog?: string, epilog?: string): string;
export namespace Dialogue {
    interface Options {
        includeLast?: any;
        excludeLast?: any;
    }
}
declare module 'koishi' {
    namespace Command {
        interface Config {
            noInterp?: boolean;
        }
    }
}
export namespace Dialogue {
    interface Options {
        ignoreHint?: boolean;
        regexp?: boolean;
        redirect?: string;
    }
}
export interface Dialogue {
    probS: number;
    probA: number;
}
export namespace Dialogue {
    interface Options {
        probabilityStrict?: number;
        probabilityAppellative?: number;
    }
}
export interface SessionState {
    activated?: Record<number, number>;
}
export function isZeroToOne(source: string): number;
declare module 'koishi' {
    interface Events {
        'dialogue/validate'(session: Dialogue.Session): void | string;
        'dialogue/action'(session: Dialogue.Session): Awaitable<void | Fragment>;
        'dialogue/before-action'(session: Dialogue.Session): Awaitable<void | string>;
        'dialogue/permit'(session: Dialogue.Session, dialogue: Dialogue): boolean;
        'dialogue/query'(test: DialogueTest, query: Query.Expr<Dialogue>): void;
        'dialogue/abstract'(dialogue: Dialogue, output: Abstract, session: Dialogue.Session): void;
        'dialogue/appendix'(dialogue: Dialogue, output: string[], prefix: string, session: Dialogue.Session): void;
        'dialogue/usage'(output: OrderedList, session: Dialogue.Session): void;
    }
    interface Context {
        dialogue: DialogueService;
    }
    interface Tables {
        dialogue: Dialogue;
    }
}
export interface Dialogue {
    id?: number;
    question: string;
    answer: string;
    original: string;
    flag: number;
    _weight?: number;
    _capture?: RegExpExecArray;
    _type?: Dialogue.ModifyType;
    _operator?: string;
    _timestamp?: number;
    _backup?: Readonly<Dialogue>;
}
export interface DialogueTest {
    original?: string;
    question?: string;
    answer?: string;
    regexp?: boolean;
    activated?: boolean;
    appellative?: boolean;
    noRecursive?: boolean;
}
export namespace Dialogue {
    type ModifyType = 'create' | 'modify' | 'remove';
    type Field = keyof Dialogue;
    interface Config {
        historyTimeout?: number;
    }
    interface Stats {
        questions: number;
        dialogues: number;
    }
    enum Flag {
        /** 冻结：只有 4 级以上权限者可修改 */
        frozen = 1,
        /** 正则：使用正则表达式进行匹配 */
        regexp = 2,
        /** 上下文：后继问答可以被上下文内任何人触发 */
        context = 4,
        /** 代行者：由教学者完成回答的执行 */
        substitute = 8,
        /** 补集：上下文匹配时取补集 */
        complement = 16
    }
    interface Options {
        help?: boolean;
        original?: string;
        appellative?: boolean;
        action?: 'review' | 'revert' | 'remove' | 'create' | 'search' | 'modify';
        skipped?: number[];
        updated?: number[];
        unknown?: number[];
        forbidden?: number[];
        dialogues?: Dialogue[];
        dialogueMap?: Record<number, Dialogue>;
    }
    interface Session extends Koishi.Session<'authority'> {
        argv: Argv<'authority', never, string[], Dialogue.Options>;
    }
}
export type Config = Dialogue.Config;
export const schema: Schema<Config>;
export const name = "dialogue";
export const inject: string[];
export function apply(ctx: Context, config: Config): void;
export namespace Dialogue {
    interface Config {
        prefix?: string;
        authority?: AuthorityConfig;
    }
}
export interface AuthorityConfig {
    /** 可访问教学系统，默认值为 2 */
    base?: number;
    /** 可修改非自己创建的问答，默认值为 3 */
    admin?: number;
    /** 可使用正则表达式，默认值为 3 */
    regExp?: number;
    /** 可触发教学问答，默认值为 1 */
    receive?: number;
}
