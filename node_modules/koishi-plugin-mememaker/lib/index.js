var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
    for (var name2 in all)
        __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
            if (!__hasOwnProp.call(to, key) && key !== except)
                __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
    Config: () => Config,
    RuDian: () => RuDian,
    apply: () => apply,
    inject: () => inject,
    name: () => name,
    usage: () => usage
});
module.exports = __toCommonJS(src_exports);
var import_koishi = require("koishi");
var logger = new import_koishi.Logger("mememaker");
var name = "mememaker";
/*
var usage = `
## ↓这里是效果图及使用方法
![img](http://ninjas-get.000.pe/Assets/MMMakerPreview/preview2.png)
（究竟是谁在迫害[风切](/market?keyword=email:2536810643@qq.com)啊
## 如你所见，你可以使用 \`入典 <文字1>\` 来使用自动翻译API来翻译文字，也可以使用 \`入典 <文字1> -n <文字2>\` 来直接输入翻译后的文字
## 你可以在下方的配置项处选择翻译的语言
`;
*/
var usage = `

---
## 项目效果图


<img src="http://ninjas-get.000.pe/Assets/MMMakerPreview/preview2.png" height="400" width="400">

（究竟是谁在迫害[风切](/market?keyword=email:2536810643@qq.com)啊

---
## 使用方法
如你所见，你可以通过以下命令使用本插件：
- 使用 自动翻译 来翻译文字：
  \`\`\`
  入典 <文字>
  \`\`\`
- 使用 \`-n\` 参数指定翻译后的文字：
  \`\`\`
  入典 <文字> -n <翻译的文字>
  \`\`\`
---
`;
var inject = {
    required: ["database", "canvas"]
};
var Config = import_koishi.Schema.object({
    isSendTimes: import_koishi.Schema.boolean().default(true).description(
        "这个开关用来确认是否向开发者反馈使用情况，自愿开启，可以用于鼓励开发者"
    ),
    transtolanguage: import_koishi.Schema.union([
        import_koishi.Schema.const("en").description("英语"),
        import_koishi.Schema.const("ja").description("日语"),
        import_koishi.Schema.const("ko").description("韩语")
        // Schema.string().description('其他语言')
    ]).role("radio").default("ja").description("这个选项用来选择翻译的语言"),
    loggerinfo: import_koishi.Schema.boolean().default(false).description("日志调试模式")
});
var RuDian = class {
    static {
        __name(this, "RuDian");
    }
    ctx;
    config;
    constructor(ctx) {
        this.ctx = ctx;
    }
    async RDOne(imageURL, cnt, jpt) {
        const ctx = this.ctx;
        const image = await ctx.canvas.loadImage(imageURL);
        let width = image.naturalWidth || image.width;
        let height = image.naturalHeight || image.height;
        if (width < 300) {
            height = Math.floor(300 * height / width);
            width = 300;
        } else if (height < 300) {
            width = Math.floor(300 * width / height);
            height = 300;
        }
        const canvas = await ctx.canvas.createCanvas(width, height + 0.1 * width);
        const context = canvas.getContext("2d");
        context.filter = "grayscale(100%)";
        context.drawImage(image, 0, 0, width, height);
        context.filter = "none";
        context.fillStyle = "black";
        context.fillRect(0, height, width, 0.1 * width);
        context.font = `${0.06 * width}px  Arial`;
        context.fillStyle = "white";
        context.textAlign = "center";
        context.textBaseline = "middle";
        context.fillText(cnt, width / 2, height + 0.04 * width);
        context.font = `${3 * width / 100}px Arial`;
        context.fillText(jpt, width / 2, height + 0.0833 * width);
        const outputbuffer = await canvas.toBuffer("image/png");
        return import_koishi.h.image(outputbuffer, "image/png");
    }
    /*
    //这个是个没写完的功能
    async RDTwo(imageURL: string, cnt: string, jpt: string) {
        //第二个 黑白 上方文字
        const ctx = this.ctx;
        const image = await ctx.canvas.loadImage(imageURL);
        //@ts-ignore
        const width = image.width;
        //@ts-ignore
        const height = image.height;
        console.log(width, height);
        const canvas = await ctx.canvas.createCanvas(width, height);
        const context = canvas.getContext("2d");
        context.drawImage(image, 0, 0, width, height);
        let captionHeight = width / 20;
        let captionWidth = width / 2;
        let captionX = width / 2 - captionWidth / 2; // 中心位置
        let captionY = height - 2.2 * captionHeight; // 4/5处
        // 创建一个渐变
        let gradient = context.createLinearGradient(
            captionX,
            0,
            captionX + captionWidth,
            0
        );
        gradient.addColorStop(0, "rgba(0,0,0,0)");
        gradient.addColorStop(0.1, "rgba(0,0,0,0.5)");
        gradient.addColorStop(0.9, "rgba(0,0,0,0.5)");
        gradient.addColorStop(1, "rgba(0,0,0,0)");
        // 设置渐变和模糊
        context.fillStyle = gradient;
        context.shadowColor = "black";
        context.shadowBlur = 100;
        // 绘制字幕区域
        context.fillRect(captionX, captionY, captionWidth, captionHeight);
        context.shadowBlur = 0; // 清除模糊，以免影响后续的绘制
        context.fillStyle = "white";
        context.textAlign = "center";
        context.textBaseline = "middle";
        const firstLine = cnt;
        const secondLine = jpt;
        context.font = `${(2 * width) / 100}px Arial`; //Arial
        context.fillText(firstLine, width / 2, captionY + width / 67);
        context.fillText(secondLine, width / 2, captionY + width / 28);
        let imageData = context.getImageData(0, 0, canvas.width, canvas.height);
        // let numNoisePoints = 100000;
        // for(let i = 0; i < numNoisePoints; i++) {
        //   let x = Math.random() * canvas.width;
        //   let y = Math.random() * canvas.height;
        //   context.fillStyle = 'rgba(128,128,128,' + Math.random() + ')';
        //   context.fillRect(x, y, 1, 1);
        // }
        context.globalCompositeOperation = "soft-light";
        context.fillStyle = "rgba(128,128,128,0.5)";
        context.fillRect(0, 0, canvas.width, canvas.height);
        // context.putImageData(imageData, 0, 0);
        const buffer = await canvas.toBuffer("image/png");
        return h.image(buffer, "image/png");
    }
    */
    //获取翻译
    async translate(cnt, target_lang = "ja") {
        let jpt = "";
        const trans = await this.ctx.database.get("rdTrans", {
            cnt,
            transtolanguage: target_lang
        });
        if (trans.length === 0) {
            let jpts;
            try {
                jpts = await this.ctx.http.get(
                    `https://translate.cloudflare.jaxing.cc/?text=${cnt}&source_lang=zh&target_lang=${target_lang}`
                );
            } catch (error) {
                logger.info(error);
                return "获取翻译失败...";
            }

            //打印测试
            //logger.info(`jpts\n ${JSON.stringify(jpts)}`);

            // 提取翻译后的文本
            jpt = jpts.response.translated_text;

            await this.ctx.database.create("rdTrans", {
                cnt,
                jpt,
                transtolanguage: target_lang
            });
        } else {
            jpt = trans[0].jpt;
        }
        return jpt;
    }

};
function apply(ctx, config) {
    ctx.database.extend(
        "rdTrans",
        {
            cnt: "string",
            jpt: "string",
            transtolanguage: "string"
        },
        {
            primary: ["cnt", "transtolanguage"]
        }
    );
    async function PostTimedata(command, times) {
        if (!config.isSendTimes)
            return;
        const url = `https://90008.top/KoiAPI/PluginsUse/${name}/koitime.php`;
        const data = { command, times };
        try {
            const request = await ctx.http.post(url, data, {
                headers: { "Content-Type": "application/json" }
            });
            if (config.loggerinfo) {
                logger.info(`数据统计： ` + request);
            }
        } catch (e) {
            logger.info(e);
        }
    }
    __name(PostTimedata, "PostTimedata");
    const rd = new RuDian(ctx);
    ctx.command("入典 <...cnt>").option("istrans", "-n <jpt>").action(async ({ session, options }, ...cntArr) => {
        if (cntArr.length === 0) {
            return "未输入标题！";
        }
        cntArr = cntArr.map((item) => {
            if (item.includes("<") && item.includes(">") && item.includes("http")) {
                return item.replace(/<.*?>/, "");
            }
            return item;
        });
        let quotemessage;
        let imageURL;
        let sessioncontent = session.content;
        try {
            quotemessage = session.quote.content;
            imageURL = import_koishi.h.select(quotemessage, "img").map((a) => a.attrs.src)[0];
            if (config.loggerinfo && imageURL) {
                logger.info("用户触发的内容为  " + cntArr);
                logger.info("用户回复的内容为  " + quotemessage);
            }
        } catch (e) {
            imageURL = import_koishi.h.select(sessioncontent, "img").map((a) => a.attrs.src)[0];
            if (!imageURL) {
                session.send("请在30s内发送图片");
                let usermessgae = await session.prompt(3e4);
                if (config.loggerinfo) {
                    logger.info("用户触发的内容为  " + cntArr);
                    logger.info("用户输入的内容为  " + usermessgae);
                }
                imageURL = import_koishi.h.select(usermessgae, "img").map((a) => a.attrs.src)[0];
            }
        }
        if (!imageURL) {
            return "请使用正确的图片内容";
        }
        const cnt = cntArr.join(" ");
        if (!options.istrans) {
            const jpt = await rd.translate(cnt, config.transtolanguage);
            if (config.loggerinfo) {
                logger.info(`翻译返回内容为` + jpt);
            }
            session.send(await rd.RDOne(imageURL, cnt, jpt));
        } else {
            if (options.istrans.includes("<") && options.istrans.includes(">") && options.istrans.includes("http")) {
                options.istrans = options.istrans.replace(/<.*?>/, "");
            }
            session.send(await rd.RDOne(imageURL, cnt, options.istrans));
        }
        await PostTimedata("入典", 1);
        return;
    });
}
__name(apply, "apply");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    Config,
    RuDian,
    apply,
    inject,
    name,
    usage
});
