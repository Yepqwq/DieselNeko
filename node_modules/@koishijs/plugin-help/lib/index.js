var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Config: () => Config,
  apply: () => apply,
  name: () => name
});
module.exports = __toCommonJS(src_exports);
var import_koishi = require("koishi");

// src/locales/zh-CN.yml
var zh_CN_default = { commands: { help: { description: "显示帮助信息", shortcuts: { help: "帮助" }, options: { help: "显示此信息", authority: "显示权限设置", showHidden: "查看隐藏的选项和指令" }, messages: { "not-found": "指令未找到。", "hint-authority": "括号内为对应的最低权限等级", "hint-subcommand": "标有星号的表示含有子指令", "command-title": "指令：{0}", "command-aliases": "别名：{0}。", "command-examples": "使用示例：", "command-authority": "最低权限：{0} 级。", "subcommand-prolog": "可用的子指令有{0}：", "global-prolog": "当前可用的指令有{0}：", "global-epilog": "输入“{0}help 指令名”查看特定指令的语法和使用示例。", "available-options": "可用的选项有：", "available-options-with-authority": "可用的选项有（括号内为额外要求的权限等级）：" } } } };

// src/locales/en-US.yml
var en_US_default = { commands: { help: { description: "Show help", shortcuts: { help: "<></>" }, options: { help: "show this message", authority: "show authority requirements", showHidden: "show hidden options and commands" }, messages: { "not-found": "Command not found.", "hint-authority": "this minimum authority is marked in parentheses", "hint-subcommand": "those marked with an asterisk have subcommands", "command-title": "Command: {0}", "command-aliases": "Aliases: {0}.", "command-examples": "Examples:", "command-authority": "Minimal authority: {0}.", "subcommand-prolog": "Available subcommands{0}:", "global-prolog": "Available commands{0}:", "global-epilog": 'Type "{0}help <command>" to see syntax and examples for a specific command.', "available-options": "Available options:", "available-options-with-authority": "Available options (parentheses indicate additional authority requirement):" } } } };

// src/index.ts
var Config = import_koishi.Schema.object({
  shortcut: import_koishi.Schema.boolean().default(true).description("是否启用快捷调用。"),
  options: import_koishi.Schema.boolean().default(true).description("是否为每个指令添加 `-h, --help` 选项。")
});
function executeHelp(session, name2) {
  if (!session.app.$commander.get("help"))
    return;
  return session.execute({
    name: "help",
    args: [name2]
  });
}
__name(executeHelp, "executeHelp");
var name = "help";
function apply(ctx, config) {
  ctx.i18n.define("zh-CN", zh_CN_default);
  ctx.i18n.define("en-US", en_US_default);
  function enableHelp(command) {
    command[import_koishi.Context.current] = ctx;
    command.option("help", "-h", {
      hidden: true,
      // @ts-ignore
      notUsage: true,
      descPath: "commands.help.options.help"
    });
  }
  __name(enableHelp, "enableHelp");
  ctx.schema.extend("command", import_koishi.Schema.object({
    hideOptions: import_koishi.Schema.boolean().description("是否隐藏所有选项。").default(false).hidden(),
    hidden: import_koishi.Schema.computed(import_koishi.Schema.boolean()).description("在帮助菜单中隐藏指令。").default(false),
    params: import_koishi.Schema.any().description("帮助信息的本地化参数。").hidden()
  }), 900);
  ctx.schema.extend("command-option", import_koishi.Schema.object({
    hidden: import_koishi.Schema.computed(import_koishi.Schema.boolean()).description("在帮助菜单中隐藏选项。").default(false),
    params: import_koishi.Schema.any().description("帮助信息的本地化参数。").hidden()
  }), 900);
  if (config.options !== false) {
    ctx.$commander._commandList.forEach(enableHelp);
    ctx.on("command-added", enableHelp);
  }
  ctx.before("command/execute", (argv) => {
    const { command, options, session } = argv;
    if (options["help"] && command._options.help) {
      return executeHelp(session, command.name);
    }
    if (command["_actions"].length)
      return;
    return executeHelp(session, command.name);
  });
  const $ = ctx.$commander;
  function findCommand(target, session) {
    const command = $.resolve(target);
    if (command?.ctx.filter(session))
      return command;
    const data = ctx.i18n.find("commands.(name).shortcuts.(variant)", target).map((item) => ({ ...item, command: $.resolve(item.data.name) })).filter((item) => item.command?.match(session));
    const perfect = data.filter((item) => item.similarity === 1);
    if (!perfect.length)
      return data;
    return perfect[0].command;
  }
  __name(findCommand, "findCommand");
  const createCollector = /* @__PURE__ */ __name((key) => (argv, fields) => {
    const { args: [target], session } = argv;
    const result = findCommand(target, session);
    if (!Array.isArray(result)) {
      session.collect(key, { ...argv, command: result, args: [], options: { help: true } }, fields);
      return;
    }
    for (const { command } of result) {
      session.collect(key, { ...argv, command, args: [], options: { help: true } }, fields);
    }
  }, "createCollector");
  async function inferCommand(target, session) {
    const result = findCommand(target, session);
    if (!Array.isArray(result))
      return result;
    const expect = $.available(session).filter((name3) => {
      return name3 && session.app.i18n.compare(name3, target);
    });
    for (const item of result) {
      if (expect.includes(item.data.name))
        continue;
      expect.push(item.data.name);
    }
    const cache = /* @__PURE__ */ new Map();
    const name2 = await session.suggest({
      expect,
      prefix: session.text(".not-found"),
      suffix: session.text("internal.suggest-command"),
      filter: (name3) => {
        name3 = $.resolve(name3).name;
        return ctx.permissions.test(`command:${name3}`, session, cache);
      }
    });
    return $.resolve(name2);
  }
  __name(inferCommand, "inferCommand");
  const cmd = ctx.command("help [command:string]", { authority: 0, ...config }).userFields(["authority"]).userFields(createCollector("user")).channelFields(createCollector("channel")).option("showHidden", "-H").action(async ({ session, options }, target) => {
    if (!target) {
      const prefix = session.resolve(session.app.koishi.config.prefix)[0] ?? "";
      const commands = $._commandList.filter((cmd2) => cmd2.parent === null);
      const output = await formatCommands(".global-prolog", session, commands, options);
      const epilog = session.text(".global-epilog", [prefix]);
      if (epilog)
        output.push(epilog);
      return output.filter(Boolean).join("\n");
    }
    const command = await inferCommand(target, session);
    if (!command)
      return;
    if (!await ctx.permissions.test(`command:${command.name}`, session)) {
      return session.text("internal.low-authority");
    }
    return showHelp(command, session, options);
  });
  if (config.shortcut !== false)
    cmd.shortcut("help", { i18n: true, fuzzy: true });
}
__name(apply, "apply");
function* getCommands(session, commands, showHidden = false) {
  for (const command of commands) {
    if (!showHidden && session.resolve(command.config.hidden))
      continue;
    if (command.match(session)) {
      yield command;
    } else {
      yield* getCommands(session, command.children, showHidden);
    }
  }
}
__name(getCommands, "getCommands");
async function formatCommands(path, session, children, options) {
  const cache = /* @__PURE__ */ new Map();
  children = Array.from(getCommands(session, children, options.showHidden));
  children = (await Promise.all(children.map(async (command) => {
    return [command, await session.app.permissions.test(`command:${command.name}`, session, cache)];
  }))).filter(([, result]) => result).map(([command]) => command);
  children.sort((a, b) => a.displayName > b.displayName ? 1 : -1);
  if (!children.length)
    return [];
  const prefix = session.resolve(session.app.koishi.config.prefix)[0] ?? "";
  const output = children.map(({ name: name2, displayName, config }) => {
    let output2 = "    " + prefix + displayName.replace(/\./g, " ");
    output2 += "  " + session.text([`commands.${name2}.description`, ""], config.params);
    return output2;
  });
  const hints = [];
  const hintText = hints.length ? session.text("general.paren", [hints.join(session.text("general.comma"))]) : "";
  output.unshift(session.text(path, [hintText]));
  return output;
}
__name(formatCommands, "formatCommands");
function getOptionVisibility(option, session) {
  if (session.user && option.authority > session.user.authority)
    return false;
  return !session.resolve(option.hidden);
}
__name(getOptionVisibility, "getOptionVisibility");
function getOptions(command, session, config) {
  if (command.config.hideOptions && !config.showHidden)
    return [];
  const options = config.showHidden ? Object.values(command._options) : Object.values(command._options).filter((option) => getOptionVisibility(option, session));
  if (!options.length)
    return [];
  const output = [];
  Object.values(command._options).forEach((option) => {
    function pushOption(option2, name2) {
      if (!config.showHidden && !getOptionVisibility(option2, session))
        return;
      let line = `${import_koishi.h.escape(option2.syntax)}`;
      const description = session.text(option2.descPath ?? [`commands.${command.name}.options.${name2}`, ""], option2.params);
      if (description)
        line += "  " + description;
      line = command.ctx.chain("help/option", line, option2, command, session);
      output.push("    " + line);
    }
    __name(pushOption, "pushOption");
    if (!("value" in option))
      pushOption(option, option.name);
    for (const value in option.variants) {
      pushOption(option.variants[value], `${option.name}.${value}`);
    }
  });
  if (!output.length)
    return [];
  output.unshift(session.text(".available-options"));
  return output;
}
__name(getOptions, "getOptions");
async function showHelp(command, session, config) {
  const output = [session.text(".command-title", [command.displayName.replace(/\./g, " ") + command.declaration])];
  const description = session.text([`commands.${command.name}.description`, ""], command.config.params);
  if (description)
    output.push(description);
  if (session.app.database) {
    const argv = { command, args: [], options: { help: true } };
    const userFields = session.collect("user", argv);
    await session.observeUser(userFields);
    if (!session.isDirect) {
      const channelFields = session.collect("channel", argv);
      await session.observeChannel(channelFields);
    }
  }
  if (Object.keys(command._aliases).length > 1) {
    output.push(session.text(".command-aliases", [Array.from(Object.keys(command._aliases).slice(1)).join("，")]));
  }
  session.app.emit(session, "help/command", output, command, session);
  if (command._usage) {
    output.push(typeof command._usage === "string" ? command._usage : await command._usage(session));
  } else {
    const text = session.text([`commands.${command.name}.usage`, ""], command.config.params);
    if (text)
      output.push(text);
  }
  output.push(...getOptions(command, session, config));
  if (command._examples.length) {
    output.push(session.text(".command-examples"), ...command._examples.map((example) => "    " + example));
  } else {
    const text = session.text([`commands.${command.name}.examples`, ""], command.config.params);
    if (text)
      output.push(...text.split("\n").map((line) => "    " + line));
  }
  output.push(...await formatCommands(".subcommand-prolog", session, command.children, config));
  return output.filter(Boolean).join("\n");
}
__name(showHelp, "showHelp");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Config,
  apply,
  name
});
//# sourceMappingURL=index.js.map
