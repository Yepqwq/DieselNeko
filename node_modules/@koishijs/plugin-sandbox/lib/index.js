var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Config: () => Config,
  apply: () => apply,
  filter: () => filter,
  inject: () => inject,
  name: () => name
});
module.exports = __toCommonJS(src_exports);
var import_koishi3 = require("koishi");
var import_console = require("@koishijs/console");
var import_path = require("path");

// src/bot.ts
var import_koishi2 = require("koishi");

// src/message.ts
var import_koishi = require("koishi");
var SandboxMessenger = class extends import_koishi.MessageEncoder {
  static {
    __name(this, "SandboxMessenger");
  }
  buffer = "";
  rules = Object.fromEntries(["image", "img", "audio", "video", "file"].map((type) => {
    return [type, async (attrs) => {
      const src = attrs.src || attrs.url;
      const type1 = type === "image" ? "img" : type;
      if (src.startsWith("file:") && this.bot.ctx.assets) {
        return (0, import_koishi.h)(type1, { ...attrs, src: await this.bot.ctx.assets.upload(src, src) });
      }
      return (0, import_koishi.h)(type1, { ...attrs, src });
    }];
  }));
  async flush() {
    if (!this.buffer.trim())
      return;
    const content = await import_koishi.h.transformAsync(this.buffer.trim(), this.rules);
    const session = this.bot.session(this.session.event);
    session.messageId = import_koishi.Random.id();
    for (const client of this.bot.clients) {
      client.send({
        type: "sandbox/message",
        body: {
          content,
          user: "Koishi",
          channel: session.channelId,
          id: session.messageId,
          platform: session.platform
        }
      });
    }
    this.results.push(session.event.message);
    this.buffer = "";
  }
  async visit(element) {
    const { type, children } = element;
    if (type === "message" || type === "figure") {
      await this.flush();
      await this.render(children);
      await this.flush();
    } else {
      this.buffer += element.toString();
    }
  }
};

// src/bot.ts
var SandboxBot = class extends import_koishi2.Bot {
  static {
    __name(this, "SandboxBot");
  }
  static MessageEncoder = SandboxMessenger;
  hidden = true;
  internal = {};
  clients = /* @__PURE__ */ new Set();
  constructor(ctx, config) {
    super(ctx, config);
    this.selfId = config.selfId;
    this.platform = config.platform;
    this.user.name = "koishi";
  }
  async request(method, data = {}) {
    const client = [...this.clients][0];
    const nonce = Math.random().toString(36).slice(2);
    return new Promise((resolve2, reject) => {
      const dispose1 = this.ctx.on("sandbox/response", (nonce2, data2) => {
        if (nonce !== nonce2)
          return;
        dispose1();
        dispose2();
        resolve2(data2);
      });
      const dispose2 = this.ctx.setTimeout(() => {
        dispose1();
        dispose2();
        reject(new Error("timeout"));
      }, import_koishi2.Time.second * 5);
      client.send({
        type: "sandbox/request",
        body: { method, data, nonce }
      });
    });
  }
  async createDirectChannel(userId) {
    return { id: "@" + userId, type: import_koishi2.Universal.Channel.Type.DIRECT };
  }
  async deleteMessage(channelId, messageId) {
    return this.request("deleteMessage", { channelId, messageId });
  }
  async getMessage(channelId, messageId) {
    return this.request("getMessage", { channelId, messageId });
  }
  async getChannel(channelId, guildId) {
    return this.request("getChannel", { channelId, guildId });
  }
  async getChannelList(guildId) {
    return this.request("getChannelList", { guildId });
  }
  async getGuild(guildId) {
    return this.request("getGuild", { guildId });
  }
  async getGuildList() {
    return this.request("getGuildList");
  }
  async getGuildMember(guildId, userId) {
    return this.request("getGuildMember", { guildId, userId });
  }
  async getGuildMemberList(guildId) {
    return this.request("getGuildMemberList", { guildId });
  }
};

// src/locales/zh-CN.yml
var zh_CN_default = { commands: { clear: { description: "清空聊天记录" } } };

// src/index.ts
var import_meta = {};
var filter = false;
var name = "sandbox";
var inject = ["console"];
var Config = import_koishi3.Schema.object({});
var SandboxService = class extends import_console.DataService {
  static {
    __name(this, "SandboxService");
  }
  static inject = ["database"];
  constructor(ctx) {
    super(ctx, "sandbox");
  }
  async get() {
    const data = await this.ctx.database.select("binding").groupBy("platform", {
      count: (row) => import_koishi3.$.count(row.pid)
    }).execute();
    return Object.fromEntries(data.map(({ platform, count }) => [platform, count]));
  }
};
function apply(ctx, config) {
  ctx.plugin(SandboxService);
  ctx.console.addEntry(process.env.KOISHI_BASE ? [
    process.env.KOISHI_BASE + "/dist/index.js",
    process.env.KOISHI_BASE + "/dist/style.css"
  ] : process.env.KOISHI_ENV === "browser" ? [
    // @ts-ignore
    import_meta.url.replace(/\/src\/[^/]+$/, "/client/index.ts")
  ] : {
    dev: (0, import_path.resolve)(__dirname, "../client/index.ts"),
    prod: (0, import_path.resolve)(__dirname, "../dist")
  });
  const bots = {};
  const createEvent = /* @__PURE__ */ __name((userId, channelId) => {
    const isDirect = channelId === "@" + userId;
    return {
      user: { id: userId, name: userId },
      channel: { id: channelId, type: isDirect ? import_koishi3.Universal.Channel.Type.DIRECT : import_koishi3.Universal.Channel.Type.TEXT },
      guild: isDirect ? void 0 : { id: channelId },
      timestamp: Date.now()
    };
  }, "createEvent");
  ctx.console.addListener("sandbox/send-message", async function(platform, userId, channel, content, quote) {
    const bot = bots[platform] ||= new SandboxBot(ctx, {
      platform,
      selfId: "koishi"
    });
    bot.clients.add(this);
    const id = import_koishi3.Random.id();
    this.send({
      type: "sandbox/message",
      body: { id, content, user: userId, channel, platform, quote }
    });
    const session = bot.session(createEvent(userId, channel));
    session.type = "message";
    session.messageId = id;
    session.quote = quote && {
      content: quote.content,
      id: quote.id
    };
    session.content = content;
    bot.dispatch(session);
  }, { authority: 4 });
  ctx.console.addListener("sandbox/delete-message", async function(platform, userId, channel, messageId) {
    const bot = bots[platform] ||= new SandboxBot(ctx, {
      platform,
      selfId: "koishi"
    });
    bot.clients.add(this);
    const session = bot.session(createEvent(userId, channel));
    session.type = "message-deleted";
    session.messageId = messageId;
    bot.dispatch(session);
  }, { authority: 4 });
  ctx.console.addListener("sandbox/get-user", async function(platform, pid) {
    const database = ctx.get("database");
    if (!database)
      return;
    const [binding] = await database.get("binding", { platform, pid }, ["aid"]);
    if (binding)
      return database.getUser(platform, pid);
    return database.createUser(platform, pid, {
      authority: 1
    });
  }, { authority: 4 });
  ctx.console.addListener("sandbox/set-user", async function(platform, pid, data) {
    const database = ctx.get("database");
    if (!database)
      return;
    const [binding] = await database.get("binding", { platform, pid }, ["aid"]);
    if (!binding) {
      if (!data)
        return;
      await database.createUser(platform, pid, {
        authority: 1,
        ...data
      });
    } else if (!data) {
      await database.remove("user", binding.aid);
      await database.remove("binding", { platform, pid });
    } else {
      await database.upsert("user", [{
        id: binding.aid,
        ...data
      }]);
    }
  }, { authority: 4 });
  ctx.console.addListener("sandbox/response", (nonce, data) => {
    ctx.emit("sandbox/response", nonce, data);
  }, { authority: 4 });
  ctx.on("console/connection", async (client) => {
    if (ctx.console.clients[client.id])
      return;
    for (const platform of Object.keys(bots)) {
      const bot = bots[platform];
      bot.clients.delete(client);
      if (!bot.clients.size) {
        delete bots[platform];
        delete ctx.bots[bot.sid];
      }
    }
  });
  ctx.i18n.define("zh-CN", zh_CN_default);
  ctx.intersect((session) => session.platform.startsWith("sandbox:")).command("clear").action(({ session }) => {
    for (const client of session.bot.clients) {
      client.send({
        type: "sandbox/clear"
      });
    }
  });
}
__name(apply, "apply");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Config,
  apply,
  filter,
  inject,
  name
});
//# sourceMappingURL=index.js.map
