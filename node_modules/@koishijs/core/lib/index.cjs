var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Adapter: () => import_core12.Adapter,
  App: () => Context,
  Argv: () => Argv,
  Bot: () => import_core12.Bot,
  Channel: () => Channel,
  Command: () => Command,
  Commander: () => Commander,
  Context: () => Context,
  Element: () => import_core12.Element,
  FilterService: () => FilterService,
  HTTP: () => import_core12.HTTP,
  I18n: () => I18n,
  Logger: () => import_core12.Logger,
  MessageEncoder: () => import_core12.MessageEncoder,
  Messenger: () => import_core12.Messenger,
  Next: () => Next,
  Permissions: () => Permissions,
  Processor: () => Processor,
  Quester: () => import_core12.Quester,
  Schema: () => import_core12.Schema,
  SchemaService: () => SchemaService,
  Service: () => Service3,
  SessionError: () => SessionError,
  SharedCache: () => SharedCache,
  Universal: () => import_core12.Universal,
  User: () => User,
  createMatch: () => createMatch,
  defineConfig: () => defineConfig,
  h: () => import_core12.h,
  resolveConfig: () => import_cordis.resolveConfig,
  segment: () => import_core12.segment,
  version: () => import_package.version,
  z: () => import_core12.z
});
module.exports = __toCommonJS(src_exports);
var import_package = require("../package.json");
__reExport(src_exports, require("@koishijs/utils"), module.exports);
__reExport(src_exports, require("minato"), module.exports);

// src/context.ts
var import_cosmokit12 = require("cosmokit");
var import_core11 = require("@satorijs/core");
var satori = __toESM(require("@satorijs/core"));
var cordis = __toESM(require("cordis"));
var minato = __toESM(require("minato"));

// src/filter.ts
var import_cosmokit = require("cosmokit");
function property(ctx, key, ...values) {
  return ctx.intersect((session) => {
    return values.length ? values.includes(session[key]) : !!session[key];
  });
}
__name(property, "property");
var FilterService = class {
  constructor(ctx) {
    this.ctx = ctx;
    (0, import_cosmokit.defineProperty)(this, Context.current, ctx);
    ctx.filter = () => true;
    ctx.on("internal/runtime", (runtime) => {
      if (!runtime.uid)
        return;
      runtime.ctx.filter = (session) => {
        return runtime.children.some((p) => p.ctx.filter(session));
      };
    });
  }
  static {
    __name(this, "FilterService");
  }
  any() {
    return this.ctx.extend({ filter: () => true });
  }
  never() {
    return this.ctx.extend({ filter: () => false });
  }
  union(arg) {
    const filter2 = typeof arg === "function" ? arg : arg.filter;
    return this.ctx.extend({ filter: (s) => this.ctx.filter(s) || filter2(s) });
  }
  intersect(arg) {
    const filter2 = typeof arg === "function" ? arg : arg.filter;
    return this.ctx.extend({ filter: (s) => this.ctx.filter(s) && filter2(s) });
  }
  exclude(arg) {
    const filter2 = typeof arg === "function" ? arg : arg.filter;
    return this.ctx.extend({ filter: (s) => this.ctx.filter(s) && !filter2(s) });
  }
  user(...values) {
    return property(this.ctx, "userId", ...values);
  }
  self(...values) {
    return property(this.ctx, "selfId", ...values);
  }
  guild(...values) {
    return property(this.ctx, "guildId", ...values);
  }
  channel(...values) {
    return property(this.ctx, "channelId", ...values);
  }
  platform(...values) {
    return property(this.ctx, "platform", ...values);
  }
  private() {
    return this.ctx.intersect((session) => session.isDirect);
  }
};

// src/command/index.ts
var import_cosmokit6 = require("cosmokit");
var import_core5 = require("@satorijs/core");

// src/command/command.ts
var import_cosmokit4 = require("cosmokit");
var import_utils3 = require("@koishijs/utils");
var import_core4 = require("@satorijs/core");

// src/command/parser.ts
var import_cosmokit2 = require("cosmokit");
var import_utils = require("@koishijs/utils");
var import_core = require("@satorijs/core");
var leftQuotes = `"'“‘`;
var rightQuotes = `"'”’`;
var Argv;
((Argv2) => {
  const bracs = {};
  function interpolate(initiator, terminator, parse2) {
    bracs[initiator] = { terminator, parse: parse2 };
  }
  Argv2.interpolate = interpolate;
  __name(interpolate, "interpolate");
  interpolate("$(", ")");
  let whitespace;
  ((whitespace2) => {
    whitespace2.unescape = /* @__PURE__ */ __name((source) => source.replace(/@__KOISHI_SPACE__@/g, " ").replace(/@__KOISHI_NEWLINE__@/g, "\n").replace(/@__KOISHI_RETURN__@/g, "\r").replace(/@__KOISHI_TAB__@/g, "	"), "unescape");
    whitespace2.escape = /* @__PURE__ */ __name((source) => source.replace(/ /g, "@__KOISHI_SPACE__@").replace(/\n/g, "@__KOISHI_NEWLINE__@").replace(/\r/g, "@__KOISHI_RETURN__@").replace(/\t/g, "@__KOISHI_TAB__@"), "escape");
  })(whitespace = Argv2.whitespace || (Argv2.whitespace = {}));
  class Tokenizer {
    static {
      __name(this, "Tokenizer");
    }
    bracs;
    constructor() {
      this.bracs = Object.create(bracs);
    }
    interpolate(initiator, terminator, parse2) {
      this.bracs[initiator] = { terminator, parse: parse2 };
    }
    parseToken(source, stopReg = "$") {
      const parent = { inters: [] };
      const index = leftQuotes.indexOf(source[0]);
      const quote = rightQuotes[index];
      let content = "";
      if (quote) {
        source = source.slice(1);
        stopReg = `${quote}(?=${stopReg})|$`;
      }
      stopReg += `|${Object.keys({ ...this.bracs, ...bracs }).map(import_utils.escapeRegExp).join("|")}`;
      const regExp = new RegExp(stopReg);
      while (true) {
        const capture = regExp.exec(source);
        content += whitespace.unescape(source.slice(0, capture.index));
        if (capture[0] in this.bracs) {
          source = source.slice(capture.index + capture[0].length).trimStart();
          const { parse: parse2, terminator } = this.bracs[capture[0]];
          const argv = parse2?.(source) || this.parse(source, terminator);
          source = argv.rest;
          parent.inters.push({ ...argv, pos: content.length, initiator: capture[0] });
        } else {
          const quoted = capture[0] === quote;
          const rest = source.slice(capture.index + +quoted);
          parent.rest = rest.trimStart();
          parent.quoted = quoted;
          parent.terminator = capture[0];
          if (quoted) {
            parent.terminator += rest.slice(0, -parent.rest.length);
          } else if (quote) {
            content = leftQuotes[index] + content;
            parent.inters.forEach((inter) => inter.pos += 1);
          }
          parent.content = content;
          if (quote === "'")
            Argv2.revert(parent);
          return parent;
        }
      }
    }
    parse(source, terminator = "") {
      const tokens = [];
      source = import_core.h.parse(source).map((el) => {
        return el.type === "text" ? el.toString() : whitespace.escape(el.toString());
      }).join("");
      let rest = source, term = "";
      const stopReg = `\\s+|[${(0, import_utils.escapeRegExp)(terminator)}]|$`;
      while (rest && !(terminator && rest.startsWith(terminator))) {
        const token = this.parseToken(rest, stopReg);
        tokens.push(token);
        rest = token.rest;
        term = token.terminator;
        delete token.rest;
      }
      if (rest.startsWith(terminator))
        rest = rest.slice(1);
      source = source.slice(0, -(rest + term).length);
      rest = whitespace.unescape(rest);
      source = whitespace.unescape(source);
      return { tokens, rest, source };
    }
    stringify(argv) {
      const output = argv.tokens.reduce((prev, token) => {
        if (token.quoted)
          prev += leftQuotes[rightQuotes.indexOf(token.terminator[0])] || "";
        return prev + token.content + token.terminator;
      }, "");
      if (argv.rest && !rightQuotes.includes(output[output.length - 1]) || argv.initiator) {
        return output.slice(0, -1);
      }
      return output;
    }
  }
  Argv2.Tokenizer = Tokenizer;
  const defaultTokenizer = new Tokenizer();
  function parse(source, terminator = "") {
    return defaultTokenizer.parse(source, terminator);
  }
  Argv2.parse = parse;
  __name(parse, "parse");
  function stringify(argv) {
    return defaultTokenizer.stringify(argv);
  }
  Argv2.stringify = stringify;
  __name(stringify, "stringify");
  function revert(token) {
    while (token.inters.length) {
      const { pos, source, initiator } = token.inters.pop();
      token.content = token.content.slice(0, pos) + initiator + source + bracs[initiator].terminator + token.content.slice(pos);
    }
  }
  Argv2.revert = revert;
  __name(revert, "revert");
  class CommandBase {
    constructor(name, declaration, ctx, config) {
      this.name = name;
      this.ctx = ctx;
      this.config = config;
      if (!name)
        throw new Error("expect a command name");
      const declList = this._arguments = ctx.$commander.parseDecl(declaration);
      this.declaration = declList.stripped;
      for (const decl of declList) {
        this._disposables.push(this.ctx.i18n.define("", `commands.${this.name}.arguments.${decl.name}`, decl.name));
      }
    }
    static {
      __name(this, "CommandBase");
    }
    declaration;
    _arguments;
    _options = {};
    _disposables = [];
    _namedOptions = {};
    _symbolicOptions = {};
    _createOption(name, def, config) {
      const cap = /^((?:-[\w-]*|[^,\s\w\x80-\uffff]+)(?:,\s*(?:-[\w-]*|[^,\s\w\x80-\uffff]+))*(?=\s|$))?((?:\s*\[[^\]]+?\]|\s*<[^>]+?>)*)(.*)$/.exec(def);
      const param = (0, import_cosmokit2.paramCase)(name);
      let syntax = cap[1] || "--" + param;
      const bracket = cap[2] || "";
      const desc = cap[3].trim();
      const aliases = config.aliases ?? [];
      const symbols = config.symbols ?? [];
      for (let param2 of syntax.trim().split(",")) {
        param2 = param2.trimStart();
        const name2 = param2.replace(/^-+/, "");
        if (!name2 || !param2.startsWith("-")) {
          symbols.push(import_core.h.escape(param2));
        } else {
          aliases.push(name2);
        }
      }
      if (!("value" in config) && !aliases.includes(param)) {
        syntax += ", --" + param;
      }
      const declList = this.ctx.$commander.parseDecl(bracket.trimStart());
      if (declList.stripped)
        syntax += " " + declList.stripped;
      const option = this._options[name] ||= {
        ...declList[0],
        ...config,
        name,
        values: {},
        valuesSyntax: {},
        variants: {},
        syntax
      };
      let path2 = `commands.${this.name}.options.${name}`;
      const fallbackType = typeof option.fallback;
      if ("value" in config) {
        path2 += "." + config.value;
        option.variants[config.value] = { ...config, syntax };
        option.valuesSyntax[config.value] = syntax;
        aliases.forEach((name2) => option.values[name2] = config.value);
      } else if (!bracket.trim()) {
        option.type = "boolean";
      } else if (!option.type && (fallbackType === "string" || fallbackType === "number")) {
        option.type = fallbackType;
      }
      this._disposables.push(this.ctx.i18n.define("", path2, desc));
      this._assignOption(option, aliases, this._namedOptions);
      this._assignOption(option, symbols, this._symbolicOptions);
      if (!this._namedOptions[param]) {
        this._namedOptions[param] = option;
      }
    }
    _assignOption(option, names, optionMap) {
      for (const name of names) {
        if (name in optionMap) {
          throw new Error(`duplicate option name "${name}" for command "${this.name}"`);
        }
        optionMap[name] = option;
      }
    }
    removeOption(name) {
      if (!this._options[name])
        return false;
      const option = this._options[name];
      delete this._options[name];
      for (const key in this._namedOptions) {
        if (this._namedOptions[key] === option) {
          delete this._namedOptions[key];
        }
      }
      for (const key in this._symbolicOptions) {
        if (this._symbolicOptions[key] === option) {
          delete this._symbolicOptions[key];
        }
      }
      return true;
    }
    parse(argv, terminator, args = [], options = {}) {
      if (typeof argv === "string")
        argv = Argv2.parse(argv, terminator);
      if (!argv.source && argv.tokens) {
        argv.source = this.name + " " + Argv2.stringify(argv);
      }
      let lastArgDecl;
      while (!argv.error && argv.tokens?.length) {
        const token = argv.tokens[0];
        let { content, quoted } = token;
        const argDecl = this._arguments[args.length] || lastArgDecl || {};
        if (args.length === this._arguments.length - 1 && argDecl.variadic) {
          lastArgDecl = argDecl;
        }
        if (content[0] !== "-" && this.ctx.$commander.resolveDomain(argDecl.type).greedy) {
          args.push(this.ctx.$commander.parseValue(Argv2.stringify(argv), "argument", argv, argDecl));
          break;
        }
        argv.tokens.shift();
        let option;
        let names;
        let param;
        if (!quoted && (option = this._symbolicOptions[content])) {
          names = [(0, import_cosmokit2.paramCase)(option.name)];
        } else {
          if (content[0] !== "-" || quoted || +content * 0 === 0 && this.ctx.$commander.resolveDomain(argDecl.type).numeric) {
            args.push(this.ctx.$commander.parseValue(content, "argument", argv, argDecl));
            continue;
          }
          let i = 0;
          for (; i < content.length; ++i) {
            if (content.charCodeAt(i) !== 45)
              break;
          }
          let j = i + 1;
          for (; j < content.length; j++) {
            if (content.charCodeAt(j) === 61)
              break;
          }
          const name = content.slice(i, j);
          if (this.config.strictOptions && !this._namedOptions[name]) {
            args.push(this.ctx.$commander.parseValue(content, "argument", argv, argDecl));
            continue;
          }
          if (i > 1 && name.startsWith("no-") && !this._namedOptions[name]) {
            options[(0, import_cosmokit2.camelCase)(name.slice(3))] = false;
            continue;
          }
          names = i > 1 ? [name] : name;
          param = content.slice(++j);
          option = this._namedOptions[names[names.length - 1]];
        }
        quoted = false;
        if (!param) {
          const { type, values } = option || {};
          if (this.ctx.$commander.resolveDomain(type).greedy) {
            param = Argv2.stringify(argv);
            quoted = true;
            argv.tokens = [];
          } else {
            const isValued = names[names.length - 1] in (values || {}) || type === "boolean";
            if (!isValued && argv.tokens.length && (type || argv.tokens[0]?.content !== "-")) {
              const token2 = argv.tokens.shift();
              param = token2.content;
              quoted = token2.quoted;
            }
          }
        }
        for (let j = 0; j < names.length; j++) {
          const name = names[j];
          const optDecl = this._namedOptions[name];
          const key = optDecl ? optDecl.name : (0, import_cosmokit2.camelCase)(name);
          if (optDecl && name in optDecl.values) {
            options[key] = optDecl.values[name];
          } else {
            const source = j + 1 < names.length ? "" : param;
            options[key] = this.ctx.$commander.parseValue(source, "option", argv, optDecl);
          }
          if (argv.error)
            break;
        }
      }
      for (const { name, fallback: fallback2 } of Object.values(this._options)) {
        if (fallback2 !== void 0 && !(name in options)) {
          options[name] = fallback2;
        }
      }
      delete argv.tokens;
      return { ...argv, options, args, error: argv.error || "", command: this };
    }
    stringifyArg(value) {
      value = "" + value;
      return value.includes(" ") ? `"${value}"` : value;
    }
    stringify(args, options) {
      let output = this.name;
      for (const key in options) {
        const value = options[key];
        if (value === true) {
          output += ` --${key}`;
        } else if (value === false) {
          output += ` --no-${key}`;
        } else {
          output += ` --${key} ${this.stringifyArg(value)}`;
        }
      }
      for (const arg of args) {
        output += " " + this.stringifyArg(arg);
      }
      return output;
    }
  }
  Argv2.CommandBase = CommandBase;
})(Argv || (Argv = {}));

// src/middleware.ts
var import_utils2 = require("@koishijs/utils");
var import_cosmokit3 = require("cosmokit");
var import_core3 = require("@satorijs/core");

// src/database.ts
var import_core2 = require("@satorijs/core");
var User;
((User2) => {
  let Flag;
  ((Flag2) => {
    Flag2[Flag2["ignore"] = 1] = "ignore";
  })(Flag = User2.Flag || (User2.Flag = {}));
})(User || (User = {}));
var Channel;
((Channel2) => {
  let Flag;
  ((Flag2) => {
    Flag2[Flag2["ignore"] = 1] = "ignore";
    Flag2[Flag2["silent"] = 4] = "silent";
  })(Flag = Channel2.Flag || (Channel2.Flag = {}));
})(Channel || (Channel = {}));
var KoishiDatabase = class {
  constructor(ctx) {
    this.ctx = ctx;
    ctx.mixin(this, {
      getUser: "database.getUser",
      setUser: "database.setUser",
      createUser: "database.createUser",
      getChannel: "database.getChannel",
      getAssignedChannels: "database.getAssignedChannels",
      setChannel: "database.setChannel",
      createChannel: "database.createChannel",
      broadcast: "broadcast"
    });
    ctx.model.extend("user", {
      id: "unsigned(8)",
      name: { type: "string", length: 255 },
      flag: "unsigned(8)",
      authority: "unsigned(4)",
      locales: "list(255)",
      permissions: "list",
      createdAt: "timestamp"
    }, {
      autoInc: true
    });
    ctx.model.extend("binding", {
      aid: "unsigned(8)",
      bid: "unsigned(8)",
      pid: "string(255)",
      platform: "string(255)"
    }, {
      primary: ["pid", "platform"]
    });
    ctx.model.extend("channel", {
      id: "string(255)",
      platform: "string(255)",
      flag: "unsigned(8)",
      assignee: "string(255)",
      guildId: "string(255)",
      locales: "list(255)",
      permissions: "list",
      createdAt: "timestamp"
    }, {
      primary: ["id", "platform"]
    });
    ctx.on("login-added", ({ platform }) => {
      if (platform in ctx.model.tables.user.fields)
        return;
      ctx.model.migrate("user", { [platform]: "string(255)" }, async (db) => {
        const users = await db.get("user", { [platform]: { $exists: true } }, ["id", platform]);
        await db.upsert("binding", users.filter((u) => u[platform]).map((user) => ({
          aid: user.id,
          bid: user.id,
          pid: user[platform],
          platform
        })));
      });
    });
  }
  static {
    __name(this, "KoishiDatabase");
  }
  async getUser(platform, pid, modifier) {
    const [binding] = await this.get("binding", { platform, pid }, ["aid"]);
    if (!binding)
      return;
    const [user] = await this.get("user", { id: binding.aid }, modifier);
    return user;
  }
  async setUser(platform, pid, data) {
    const [binding] = await this.get("binding", { platform, pid }, ["aid"]);
    if (!binding)
      throw new Error("user not found");
    return this.set("user", binding.aid, data);
  }
  async createUser(platform, pid, data) {
    const user = await this.create("user", data);
    await this.create("binding", { aid: user.id, bid: user.id, pid, platform });
    return user;
  }
  async getChannel(platform, id, modifier) {
    const data = await this.get("channel", { platform, id }, modifier);
    if (Array.isArray(id))
      return data;
    if (data[0])
      Object.assign(data[0], { platform, id });
    return data[0];
  }
  getSelfIds(platforms) {
    const selfIdMap = /* @__PURE__ */ Object.create(null);
    for (const bot of this.ctx.bots) {
      if (platforms && !platforms.includes(bot.platform))
        continue;
      (selfIdMap[bot.platform] ||= []).push(bot.selfId);
    }
    return selfIdMap;
  }
  async getAssignedChannels(fields, selfIdMap = this.getSelfIds()) {
    return this.get("channel", {
      $or: Object.entries(selfIdMap).map(([platform, assignee]) => ({ platform, assignee }))
    }, fields);
  }
  setChannel(platform, id, data) {
    return this.set("channel", { platform, id }, data);
  }
  createChannel(platform, id, data) {
    return this.create("channel", { platform, id, ...data });
  }
  async broadcast(...args) {
    let channels, platforms;
    if (Array.isArray(args[0])) {
      channels = args.shift();
      platforms = channels.map((c) => c.split(":")[0]);
    }
    const [content, forced] = args;
    if (!content)
      return [];
    const selfIdMap = this.getSelfIds(platforms);
    const data = await this.getAssignedChannels(["id", "assignee", "flag", "platform", "guildId", "locales"], selfIdMap);
    const assignMap = {};
    for (const channel of data) {
      const { platform, id, assignee, flag } = channel;
      if (channels) {
        const index = channels?.indexOf(`${platform}:${id}`);
        if (index < 0)
          continue;
        channels.splice(index, 1);
      }
      if (!forced && flag & 4 /* silent */)
        continue;
      ((assignMap[platform] ||= {})[assignee] ||= []).push(channel);
    }
    if (channels?.length) {
      this.ctx.logger("app").warn("broadcast", "channel not found: ", channels.join(", "));
    }
    return (await Promise.all(this.ctx.bots.map((bot) => {
      const targets = assignMap[bot.platform]?.[bot.selfId];
      if (!targets)
        return Promise.resolve([]);
      const sessions = targets.map(({ id, guildId, locales }) => {
        const session = bot.session({
          type: "message",
          channel: { id, type: import_core2.Universal.Channel.Type.TEXT },
          guild: { id: guildId }
        });
        session.locales = locales;
        return session;
      });
      return bot.broadcast(sessions, content);
    }))).flat(1);
  }
};
var database_default = KoishiDatabase;

// src/middleware.ts
var SessionError = class extends Error {
  constructor(path2, param) {
    super((0, import_utils2.makeArray)(path2)[0]);
    this.path = path2;
    this.param = param;
  }
  static {
    __name(this, "SessionError");
  }
};
var Next;
((Next2) => {
  Next2.MAX_DEPTH = 64;
  async function compose(callback, next) {
    return typeof callback === "function" ? callback(next) : callback;
  }
  Next2.compose = compose;
  __name(compose, "compose");
})(Next || (Next = {}));
var Processor = class {
  constructor(ctx) {
    this.ctx = ctx;
    (0, import_cosmokit3.defineProperty)(this, Context.current, ctx);
    this.middleware(this.attach.bind(this), true);
    ctx.on("message", this._handleMessage.bind(this));
    ctx.before("attach-user", (session, fields) => {
      session.collect("user", session.argv, fields);
    });
    ctx.before("attach-channel", (session, fields) => {
      session.collect("channel", session.argv, fields);
    });
    ctx.component("execute", async (attrs, children, session) => {
      return session.execute(children.join(""), true);
    }, { session: true });
    ctx.component("prompt", async (attrs, children, session) => {
      await session.send(children);
      return session.prompt();
    }, { session: true });
    ctx.component("i18n", async (attrs, children, session) => {
      return session.i18n(attrs.path, children);
    }, { session: true });
    ctx.component("random", async (attrs, children) => {
      return import_utils2.Random.pick(children);
    });
    ctx.component("plural", async (attrs, children) => {
      const path2 = attrs.count in children ? attrs.count : children.length - 1;
      return children[path2];
    });
    const units = ["day", "hour", "minute", "second"];
    ctx.component("i18n:time", (attrs, children, session) => {
      let ms = +attrs.value;
      for (let index = 0; index < 3; index++) {
        const major = import_cosmokit3.Time[units[index]];
        const minor = import_cosmokit3.Time[units[index + 1]];
        if (ms >= major - minor / 2) {
          ms += minor / 2;
          let result = Math.floor(ms / major) + " " + session.text("general." + units[index]);
          if (ms % major > minor) {
            result += ` ${Math.floor(ms % major / minor)} ` + session.text("general." + units[index + 1]);
          }
          return result;
        }
      }
      return Math.round(ms / import_cosmokit3.Time.second) + " " + session.text("general.second");
    }, { session: true });
    ctx.before("attach", (session) => {
      for (const matcher of this._matchers) {
        this._executeMatcher(session, matcher);
        if (session.response)
          return;
      }
    });
  }
  static {
    __name(this, "Processor");
  }
  _hooks = [];
  _sessions = /* @__PURE__ */ Object.create(null);
  _userCache = new SharedCache();
  _channelCache = new SharedCache();
  _matchers = /* @__PURE__ */ new Set();
  middleware(middleware, options) {
    if (typeof options !== "object") {
      options = { prepend: options };
    }
    return this.ctx.lifecycle.register("middleware", this._hooks, middleware, options);
  }
  match(pattern, response, options) {
    const matcher = { ...options, context: this.ctx, pattern, response };
    this._matchers.add(matcher);
    return this.ctx.collect("shortcut", () => {
      return this._matchers.delete(matcher);
    });
  }
  _executeMatcher(session, matcher) {
    const { stripped, quote } = session;
    const { appel, context, i18n, regex, fuzzy, pattern, response } = matcher;
    if ((appel || stripped.hasAt) && !stripped.appel)
      return;
    if (!context.filter(session))
      return;
    let content = stripped.content;
    if (quote?.content)
      content += " " + quote.content;
    let params = null;
    const match = /* @__PURE__ */ __name((pattern2) => {
      if (!pattern2)
        return;
      if (typeof pattern2 === "string") {
        if (!fuzzy && content !== pattern2 || !content.startsWith(pattern2))
          return;
        params = [content, content.slice(pattern2.length)];
        if (fuzzy && !stripped.appel && params[1].match(/^\S/)) {
          params = null;
        }
      } else {
        params = pattern2.exec(content);
      }
    }, "match");
    if (!i18n) {
      match(pattern);
    } else {
      for (const locale of this.ctx.i18n.fallback([])) {
        const store = this.ctx.i18n._data[locale];
        let value = store?.[pattern];
        if (!value)
          continue;
        if (regex) {
          const rest = fuzzy ? `(?:${stripped.appel ? "" : "\\s+"}([\\s\\S]*))?` : "";
          value = new RegExp(`^(?:${value})${rest}$`);
        }
        match(value);
        if (!params)
          continue;
        session.locales = [locale];
        break;
      }
    }
    if (!params)
      return;
    session.response = async () => {
      const output = await session.resolve(response, params);
      return import_core3.h.normalize(output, params.map((source) => source ? import_core3.h.parse(source) : ""));
    };
  }
  async attach(session, next) {
    this.ctx.emit(session, "before-attach", session);
    if (this.ctx.database) {
      if (!session.isDirect) {
        const channelFields = /* @__PURE__ */ new Set(["flag", "assignee", "guildId", "permissions", "locales"]);
        this.ctx.emit("before-attach-channel", session, channelFields);
        const channel = await session.observeChannel(channelFields);
        channel.guildId = session.guildId;
        if (await this.ctx.serial(session, "attach-channel", session))
          return;
        if (channel.flag & Channel.Flag.ignore)
          return;
        if (channel.assignee !== session.selfId && !session.stripped.atSelf)
          return;
      }
      const userFields = /* @__PURE__ */ new Set(["id", "flag", "authority", "permissions", "locales"]);
      this.ctx.emit("before-attach-user", session, userFields);
      const user = await session.observeUser(userFields);
      if (await this.ctx.serial(session, "attach-user", session))
        return;
      if (user.flag & User.Flag.ignore)
        return;
    }
    this.ctx.emit(session, "attach", session);
    if (session.response)
      return session.response();
    return next();
  }
  async _handleMessage(session) {
    if (session.selfId === session.userId)
      return;
    this._sessions[session.id] = session;
    const queue = this.ctx.lifecycle.filterHooks(this._hooks, session).map(({ callback }) => callback.bind(null, session));
    let index = 0;
    const next = /* @__PURE__ */ __name(async (callback) => {
      try {
        if (!this._sessions[session.id]) {
          throw new Error("isolated next function detected");
        }
        if (callback !== void 0) {
          queue.push((next2) => Next.compose(callback, next2));
          if (queue.length > Next.MAX_DEPTH) {
            throw new Error(`middleware stack exceeded ${Next.MAX_DEPTH}`);
          }
        }
        return await queue[index++]?.(next);
      } catch (error) {
        if (error instanceof SessionError) {
          return session.text(error.path, error.param);
        }
        const stack = (0, import_utils2.coerce)(error);
        this.ctx.logger("session").warn(`${session.content}
${stack}`);
      }
    }, "next");
    try {
      const result = await next();
      if (result)
        await session.send(result);
    } finally {
      delete this._sessions[session.id];
      this._userCache.delete(session.id);
      this._channelCache.delete(session.id);
      await session.user?.$update();
      await session.channel?.$update();
      await session.guild?.$update();
      this.ctx.emit(session, "middleware", session);
    }
  }
};
var SharedCache = class {
  static {
    __name(this, "SharedCache");
  }
  #keyMap = /* @__PURE__ */ new Map();
  get(ref, key) {
    const entry = this.#keyMap.get(key);
    if (!entry)
      return;
    entry.refs.add(ref);
    return entry.value;
  }
  set(ref, key, value) {
    let entry = this.#keyMap.get(key);
    if (entry) {
      entry.value = value;
    } else {
      entry = { value, key, refs: /* @__PURE__ */ new Set() };
      this.#keyMap.set(key, entry);
    }
    entry.refs.add(ref);
  }
  delete(ref) {
    for (const key of [...this.#keyMap.keys()]) {
      const { refs } = this.#keyMap.get(key);
      refs.delete(ref);
      if (!refs.size) {
        this.#keyMap.delete(key);
      }
    }
  }
};

// src/command/command.ts
var logger = new import_core4.Logger("command");
var Command = class extends Argv.CommandBase {
  static {
    __name(this, "Command");
  }
  children = [];
  _parent = null;
  _aliases = /* @__PURE__ */ Object.create(null);
  _examples = [];
  _usage;
  _userFields = [["locales"]];
  _channelFields = [["locales"]];
  _actions = [];
  _checkers = [async (argv) => {
    return this.ctx.serial(argv.session, "command/before-execute", argv);
  }];
  constructor(name, decl, ctx, config) {
    super(name, decl, ctx, {
      showWarning: true,
      handleError: true,
      slash: true,
      ...config
    });
    this.config.permissions ??= [`authority:${config?.authority ?? 1}`];
    this._registerAlias(name);
    ctx.$commander._commandList.push(this);
  }
  get caller() {
    return this[Context.current] || this.ctx;
  }
  get displayName() {
    return Object.keys(this._aliases)[0];
  }
  set displayName(name) {
    this._registerAlias(name, true);
  }
  get parent() {
    return this._parent;
  }
  set parent(parent) {
    if (this._parent === parent)
      return;
    if (this._parent) {
      (0, import_cosmokit4.remove)(this._parent.children, this);
    }
    this._parent = parent;
    if (parent) {
      parent.children.push(this);
    }
  }
  _registerAlias(name, prepend = false, options = {}) {
    name = name.toLowerCase();
    if (name.startsWith("."))
      name = this.parent.name + name;
    const previous = this.ctx.$commander.get(name);
    if (previous && previous !== this) {
      throw new Error(`duplicate command names: "${name}"`);
    }
    const existing = this._aliases[name];
    if (existing) {
      if (prepend) {
        this._aliases = { [name]: existing, ...this._aliases };
      }
    } else if (prepend) {
      this._aliases = { [name]: options, ...this._aliases };
    } else {
      this._aliases[name] = options;
    }
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `Command <${this.name}>`;
  }
  userFields(fields) {
    this._userFields.push(fields);
    return this;
  }
  channelFields(fields) {
    this._channelFields.push(fields);
    return this;
  }
  alias(...args) {
    if (typeof args[1] === "object") {
      this._registerAlias(args[0], false, args[1]);
    } else {
      for (const name of args) {
        this._registerAlias(name);
      }
    }
    this.caller.emit("command-updated", this);
    return this;
  }
  _escape(source) {
    if (typeof source !== "string")
      return source;
    return source.replace(/\$\$/g, "@@__PLACEHOLDER__@@").replace(/\$\d/g, (s) => `{${s[1]}}`).replace(/@@__PLACEHOLDER__@@/g, "$");
  }
  shortcut(pattern, config = {}) {
    let content = this.displayName;
    for (const key in config.options || {}) {
      content += ` --${(0, import_cosmokit4.camelize)(key)}`;
      const value = config.options[key];
      if (value !== true) {
        content += " " + this._escape(value);
      }
    }
    for (const arg of config.args || []) {
      content += " " + this._escape(arg);
    }
    if (config.fuzzy)
      content += " {1}";
    const regex = config.i18n;
    if (typeof pattern === "string") {
      if (config.i18n) {
        pattern = `commands.${this.name}.shortcuts.${pattern}`;
      } else {
        config.i18n = true;
        const key = `commands.${this.name}.shortcuts._${Math.random().toString(36).slice(2)}`;
        this.ctx.i18n.define("", key, pattern);
        pattern = key;
      }
    }
    const dispose = this.ctx.match(pattern, `<execute>${content}</execute>`, {
      appel: config.prefix,
      fuzzy: config.fuzzy,
      i18n: config.i18n,
      regex
    });
    this._disposables.push(dispose);
    return this;
  }
  subcommand(def, ...args) {
    def = this.name + (def.charCodeAt(0) === 46 ? "" : "/") + def;
    const desc = typeof args[0] === "string" ? args.shift() : "";
    const config = args[0] || {};
    return this.ctx.command(def, desc, config);
  }
  usage(text) {
    this._usage = text;
    return this;
  }
  example(example) {
    this._examples.push(example);
    return this;
  }
  option(name, ...args) {
    let desc = "";
    if (typeof args[0] === "string") {
      desc = args.shift();
    }
    const config = { ...args[0] };
    config.permissions ??= [`authority:${config.authority ?? 0}`];
    this._createOption(name, desc, config);
    this.caller.emit("command-updated", this);
    this.caller.collect("option", () => this.removeOption(name));
    return this;
  }
  match(session) {
    return this.ctx.filter(session);
  }
  check(callback, append = false) {
    return this.before(callback, append);
  }
  before(callback, append = false) {
    if (append) {
      this._checkers.push(callback);
    } else {
      this._checkers.unshift(callback);
    }
    this.caller.scope.disposables?.push(() => (0, import_cosmokit4.remove)(this._checkers, callback));
    return this;
  }
  action(callback, prepend = false) {
    if (prepend) {
      this._actions.unshift(callback);
    } else {
      this._actions.push(callback);
    }
    this.caller.scope.disposables?.push(() => (0, import_cosmokit4.remove)(this._actions, callback));
    return this;
  }
  /** @deprecated */
  use(callback, ...args) {
    return callback(this, ...args);
  }
  async execute(argv, fallback2 = Next.compose) {
    argv.command ??= this;
    argv.args ??= [];
    argv.options ??= {};
    const { args, options, error } = argv;
    if (error)
      return error;
    if (logger.level >= 3)
      logger.debug(argv.source ||= this.stringify(args, options));
    for (const validator of this._checkers) {
      const result = await validator.call(this, argv, ...args);
      if (!(0, import_cosmokit4.isNullable)(result))
        return result;
    }
    if (!this._actions.length)
      return "";
    let index = 0;
    const queue = this._actions.map((action) => async () => {
      return await action.call(this, argv, ...args);
    });
    queue.push(fallback2);
    const length = queue.length;
    argv.next = async (callback) => {
      if (callback !== void 0) {
        queue.push((next) => Next.compose(callback, next));
        if (queue.length > Next.MAX_DEPTH) {
          throw new Error(`middleware stack exceeded ${Next.MAX_DEPTH}`);
        }
      }
      return queue[index++]?.(argv.next);
    };
    try {
      const result = await argv.next();
      if (!(0, import_cosmokit4.isNullable)(result))
        return result;
    } catch (error2) {
      if (index === length)
        throw error2;
      if (error2 instanceof SessionError) {
        return argv.session.text(error2.path, error2.param);
      }
      const stack = (0, import_utils3.coerce)(error2);
      logger.warn(`${argv.source ||= this.stringify(args, options)}
${stack}`);
      this.ctx.emit(argv.session, "command-error", argv, error2);
      if (typeof this.config.handleError === "function") {
        const result = await this.config.handleError(error2, argv);
        if (!(0, import_cosmokit4.isNullable)(result))
          return result;
      } else if (this.config.handleError) {
        return argv.session.text("internal.error-encountered");
      }
    }
    return "";
  }
  dispose() {
    this._disposables.splice(0).forEach((dispose) => dispose());
    this.ctx.emit("command-removed", this);
    for (const cmd of this.children.slice()) {
      cmd.dispose();
    }
    (0, import_cosmokit4.remove)(this.ctx.$commander._commandList, this);
    this.parent = null;
  }
  toJSON() {
    return {
      name: this.name,
      description: this.ctx.i18n.get(`commands.${this.name}.description`),
      arguments: this._arguments.map((arg) => ({
        name: arg.name,
        type: toStringType(arg.type),
        description: this.ctx.i18n.get(`commands.${this.name}.arguments.${arg.name}`),
        required: arg.required
      })),
      options: Object.entries(this._options).map(([name, option]) => ({
        name,
        type: toStringType(option.type),
        description: this.ctx.i18n.get(`commands.${this.name}.options.${name}`),
        required: option.required
      })),
      children: this.children.filter((child) => child.name.includes(".")).map((child) => child.toJSON())
    };
  }
};
function toStringType(type) {
  return typeof type === "string" ? type : "string";
}
__name(toStringType, "toStringType");
((Command2) => {
  Command2.Config = import_core4.Schema.object({
    permissions: import_core4.Schema.array(String).role("perms").default(["authority:1"]).description("权限继承。"),
    dependencies: import_core4.Schema.array(String).role("perms").description("权限依赖。"),
    slash: import_core4.Schema.boolean().description("启用斜线指令功能。").default(true),
    checkUnknown: import_core4.Schema.boolean().description("是否检查未知选项。").default(false).hidden(),
    checkArgCount: import_core4.Schema.boolean().description("是否检查参数数量。").default(false).hidden(),
    showWarning: import_core4.Schema.boolean().description("是否显示警告。").default(true).hidden(),
    handleError: import_core4.Schema.union([import_core4.Schema.boolean(), import_core4.Schema.function()]).description("是否处理错误。").default(true).hidden()
  });
})(Command || (Command = {}));

// src/command/validate.ts
var import_cosmokit5 = require("cosmokit");
function validate(ctx) {
  ctx.permissions.define("command:(name)", {
    depends: ({ name }) => {
      const command = ctx.$commander.get(name);
      if (!command)
        return;
      const depends = [...command.config.dependencies ?? []];
      if (command.parent)
        depends.push(`command:${command.parent.name}`);
      return depends;
    },
    inherits: ({ name }) => {
      return ctx.$commander.get(name)?.config.permissions;
    },
    list: () => {
      return ctx.$commander._commandList.map((command) => `command:${command.name}`);
    }
  });
  ctx.permissions.define("command:(name):option:(name2)", {
    depends: ({ name, name2 }) => {
      return ctx.$commander.get(name)?._options[name2]?.dependencies;
    },
    inherits: ({ name, name2 }) => {
      return ctx.$commander.get(name)?._options[name2]?.permissions;
    },
    list: () => {
      return ctx.$commander._commandList.flatMap((command) => {
        return Object.keys(command._options).map((name) => `command:${command.name}:option:${name}`);
      });
    }
  });
  ctx.before("command/execute", async (argv) => {
    const { session, options, command } = argv;
    if (!session.user)
      return;
    function sendHint(message, ...param) {
      return command.config.showWarning ? session.text(message, param) : "";
    }
    __name(sendHint, "sendHint");
    const permissions = [`command:${command.name}`];
    for (const option of Object.values(command._options)) {
      if (option.name in options) {
        permissions.push(`command:${command.name}:option:${option.name}`);
      }
    }
    if (!await ctx.permissions.test(permissions, session)) {
      return sendHint("internal.low-authority");
    }
  }, true);
  ctx.before("command/execute", async (argv) => {
    const { args, options, command, session } = argv;
    function sendHint(message, ...param) {
      return command.config.showWarning ? session.text(message, param) : "";
    }
    __name(sendHint, "sendHint");
    if (command.config.checkArgCount) {
      let index = args.length;
      while (command._arguments[index]?.required) {
        const decl = command._arguments[index];
        await session.send(session.text("internal.prompt-argument", [
          session.text(`commands.${command.name}.arguments.${decl.name}`)
        ]));
        const source = await session.prompt();
        if ((0, import_cosmokit5.isNullable)(source)) {
          return sendHint("internal.insufficient-arguments", decl.name);
        }
        args.push(ctx.$commander.parseValue(source, "argument", argv, decl));
        index++;
      }
      const finalArg = command._arguments[command._arguments.length - 1] || {};
      if (args.length > command._arguments.length && !finalArg.variadic) {
        return sendHint("internal.redunant-arguments");
      }
    }
    if (command.config.checkUnknown) {
      const unknown = Object.keys(options).filter((key) => !command._options[key]);
      if (unknown.length) {
        return sendHint("internal.unknown-option", unknown.join(", "));
      }
    }
  }, true);
}
__name(validate, "validate");

// src/command/index.ts
var isArray = Array.isArray;
var BRACKET_REGEXP = /<[^>]+>|\[[^\]]+\]/g;
var Commander = class {
  constructor(ctx, config = {}) {
    this.ctx = ctx;
    this.config = config;
    (0, import_cosmokit6.defineProperty)(this, Context.current, ctx);
    ctx.plugin(validate);
    ctx.before("parse", (content, session) => {
      const { quote, isDirect, stripped: { prefix, appel } } = session;
      if (!isDirect && typeof prefix !== "string" && !appel)
        return;
      const argv = Argv.parse(content);
      if (quote?.content) {
        argv.tokens.push({
          content: quote.content,
          quoted: true,
          inters: [],
          terminator: ""
        });
      }
      return argv;
    });
    ctx.on("interaction/command", (session) => {
      if (session.event?.argv) {
        const { name, options, arguments: args } = session.event.argv;
        session.execute({ name, args, options });
      } else {
        session.stripped.hasAt = true;
        session.stripped.appel = true;
        session.stripped.atSelf = true;
        session.stripped.prefix = "";
        (0, import_cosmokit6.defineProperty)(session, "argv", ctx.bail("before-parse", session.content, session));
        if (!session.argv) {
          ctx.logger("command").warn("failed to parse interaction command:", session.content);
          return;
        }
        session.argv.root = true;
        session.argv.session = session;
        session.execute(session.argv);
      }
    });
    ctx.before("attach", (session) => {
      const { hasAt, appel } = session.stripped;
      if (!appel && hasAt)
        return;
      let content = session.stripped.content;
      for (const prefix of this._resolvePrefixes(session)) {
        if (!content.startsWith(prefix))
          continue;
        session.stripped.prefix = prefix;
        content = content.slice(prefix.length);
        break;
      }
      (0, import_cosmokit6.defineProperty)(session, "argv", ctx.bail("before-parse", content, session));
      if (!session.argv)
        return;
      session.argv.root = true;
      session.argv.session = session;
    });
    ctx.middleware((session, next) => {
      if (!this.resolveCommand(session.argv))
        return next();
      return session.execute(session.argv, next);
    });
    ctx.middleware((session, next) => {
      const { argv, quote, isDirect, stripped: { prefix, appel } } = session;
      if (argv?.command || !isDirect && !prefix && !appel)
        return next();
      const content = session.stripped.content.slice((prefix ?? "").length);
      const actual = content.split(/\s/, 1)[0].toLowerCase();
      if (!actual)
        return next();
      return next(async (next2) => {
        const cache = /* @__PURE__ */ new Map();
        const name = await session.suggest({
          actual,
          expect: this.available(session),
          suffix: session.text("internal.suggest-command"),
          filter: (name2) => {
            name2 = this.resolve(name2).name;
            return ctx.permissions.test(`command:${name2}`, session, cache);
          }
        });
        if (!name)
          return next2();
        const message = name + content.slice(actual.length) + (quote?.content ? " " + quote.content : "");
        return session.execute(message, next2);
      });
    });
    ctx.schema.extend("command", Command.Config, 1e3);
    ctx.schema.extend("command-option", import_core5.Schema.object({
      permissions: import_core5.Schema.array(String).role("perms").default(["authority:0"]).description("权限继承。"),
      dependencies: import_core5.Schema.array(String).role("perms").description("权限依赖。")
    }), 1e3);
    ctx.on("ready", () => {
      const bots = ctx.bots.filter((v) => v.status === import_core5.Universal.Status.ONLINE && v.updateCommands);
      bots.forEach((bot) => this.updateCommands(bot));
    });
    ctx.on("bot-status-updated", async (bot) => {
      if (bot.status !== import_core5.Universal.Status.ONLINE || !bot.updateCommands)
        return;
      this.updateCommands(bot);
    });
    this.domain("el", (source) => import_core5.h.parse(source), { greedy: true });
    this.domain("elements", (source) => import_core5.h.parse(source), { greedy: true });
    this.domain("string", (source) => import_core5.h.unescape(source));
    this.domain("text", (source) => import_core5.h.unescape(source), { greedy: true });
    this.domain("rawtext", (source) => (0, import_core5.h)("", import_core5.h.parse(source)).toString(true), { greedy: true });
    this.domain("boolean", () => true);
    this.domain("number", (source, session) => {
      const value = +source.replace(/[,_]/g, "");
      if (Number.isFinite(value))
        return value;
      throw new Error("internal.invalid-number");
    }, { numeric: true });
    this.domain("integer", (source, session) => {
      const value = +source;
      if (value * 0 === 0 && Math.floor(value) === value)
        return value;
      throw new Error("internal.invalid-integer");
    }, { numeric: true });
    this.domain("posint", (source, session) => {
      const value = +source;
      if (value * 0 === 0 && Math.floor(value) === value && value > 0)
        return value;
      throw new Error("internal.invalid-posint");
    }, { numeric: true });
    this.domain("natural", (source, session) => {
      const value = +source;
      if (value * 0 === 0 && Math.floor(value) === value && value >= 0)
        return value;
      throw new Error("internal.invalid-natural");
    }, { numeric: true });
    this.domain("bigint", (source, session) => {
      try {
        return BigInt(source);
      } catch {
        throw new Error("internal.invalid-integer");
      }
    }, { numeric: true });
    this.domain("date", (source, session) => {
      const timestamp = import_cosmokit6.Time.parseDate(source);
      if (+timestamp)
        return timestamp;
      throw new Error("internal.invalid-date");
    });
    this.domain("user", (source, session) => {
      if (source.startsWith("@")) {
        source = source.slice(1);
        if (source.includes(":"))
          return source;
        return `${session.platform}:${source}`;
      }
      const code = import_core5.h.from(source);
      if (code && code.type === "at") {
        return `${session.platform}:${code.attrs.id}`;
      }
      throw new Error("internal.invalid-user");
    });
    this.domain("channel", (source, session) => {
      if (source.startsWith("#")) {
        source = source.slice(1);
        if (source.includes(":"))
          return source;
        return `${session.platform}:${source}`;
      }
      const code = import_core5.h.from(source);
      if (code && code.type === "sharp") {
        return `${session.platform}:${code.attrs.id}`;
      }
      throw new Error("internal.invalid-channel");
    });
    this.defineElementDomain("image", "image", "img");
    this.defineElementDomain("img", "image", "img");
    this.defineElementDomain("audio");
    this.defineElementDomain("video");
    this.defineElementDomain("file");
  }
  static {
    __name(this, "Commander");
  }
  _commandList = [];
  defineElementDomain(name, key = name, type = name) {
    this.domain(name, (source, session) => {
      const code = import_core5.h.from(source);
      if (code && code.type === type) {
        return code.attrs;
      }
      throw new Error(`internal.invalid-${key}`);
    });
  }
  get(name, session) {
    return this._commandList.find((cmd) => {
      const alias = cmd._aliases[name];
      return alias && (session?.resolve(alias.filter) ?? true);
    });
  }
  updateCommands(bot) {
    return bot.updateCommands(this._commandList.filter((cmd) => !cmd.name.includes(".") && cmd.config.slash).map((cmd) => cmd.toJSON()));
  }
  _resolvePrefixes(session) {
    const value = session.resolve(this.config.prefix);
    const result = Array.isArray(value) ? value : [value || ""];
    return result.map((source) => import_core5.h.escape(source)).sort().reverse();
  }
  available(session) {
    return this._commandList.filter((cmd) => cmd.match(session)).flatMap((cmd) => Object.keys(cmd._aliases));
  }
  resolve(key) {
    return this._resolve(key).command;
  }
  _resolve(key) {
    if (!key)
      return {};
    const segments = key.toLowerCase().split(".");
    let i = 1, name = segments[0], command;
    while ((command = this.get(name)) && i < segments.length) {
      name = command.name + "." + segments[i++];
    }
    return { command, name };
  }
  inferCommand(argv) {
    if (!argv)
      return;
    if (argv.command)
      return argv.command;
    if (argv.name)
      return argv.command = this.resolve(argv.name);
    const { stripped, isDirect } = argv.session;
    const isStrict = this.config.prefixMode === "strict" || !isDirect && !stripped.appel;
    if (argv.root && stripped.prefix === null && isStrict)
      return;
    const segments = [];
    while (argv.tokens.length) {
      const { content } = argv.tokens[0];
      segments.push(content);
      const { name, command } = this._resolve(segments.join("."));
      if (!command)
        break;
      argv.tokens.shift();
      argv.command = command;
      argv.args = command._aliases[name].args;
      argv.options = command._aliases[name].options;
      if (command._arguments.length)
        break;
    }
    return argv.command;
  }
  resolveCommand(argv) {
    if (!this.inferCommand(argv))
      return;
    if (argv.tokens?.every((token) => !token.inters.length)) {
      const { options, args, error } = argv.command.parse(argv);
      argv.options = { ...argv.options, ...options };
      argv.args = [...argv.args || [], ...args];
      argv.error = error;
    }
    return argv.command;
  }
  command(def, ...args) {
    const desc = typeof args[0] === "string" ? args.shift() : "";
    const config = args[0];
    const path2 = def.split(" ", 1)[0].toLowerCase();
    const decl = def.slice(path2.length);
    const segments = path2.split(/(?=[./])/g);
    let parent;
    let root;
    const created = [];
    segments.forEach((segment2, index) => {
      const code = segment2.charCodeAt(0);
      const name = code === 46 ? parent.name + segment2 : code === 47 ? segment2.slice(1) : segment2;
      let command = this.get(name);
      if (command) {
        if (parent) {
          if (command === parent) {
            throw new Error(`cannot set a command (${command.name}) as its own subcommand`);
          }
          if (command.parent) {
            if (command.parent !== parent) {
              throw new Error(`cannot create subcommand ${path2}: ${command.parent.name}/${command.name} already exists`);
            }
          } else {
            command.parent = parent;
          }
        }
        return parent = command;
      }
      const isLast = index === segments.length - 1;
      command = new Command(name, isLast ? decl : "", this.ctx, isLast ? config : {});
      command._disposables.push(this.ctx.i18n.define("", {
        [`commands.${command.name}.$`]: "",
        [`commands.${command.name}.description`]: isLast ? desc : ""
      }));
      created.push(command);
      root ||= command;
      if (parent) {
        command.parent = parent;
      }
      parent = command;
    });
    Object.assign(parent.config, config);
    created.forEach((command) => this.ctx.emit("command-added", command));
    parent[Context.current] = this.ctx;
    if (root)
      this.ctx.collect(`command <${root.name}>`, () => root.dispose());
    return parent;
  }
  domain(name, transform, options) {
    const service = "domain:" + name;
    if (!transform)
      return this.ctx.get(service);
    return this.ctx.set(service, { transform, ...options });
  }
  resolveDomain(type) {
    if (typeof type === "function") {
      return { transform: type };
    } else if (type instanceof RegExp) {
      const transform = /* @__PURE__ */ __name((source) => {
        if (type.test(source))
          return source;
        throw new Error();
      }, "transform");
      return { transform };
    } else if (isArray(type)) {
      const transform = /* @__PURE__ */ __name((source) => {
        if (type.includes(source))
          return source;
        throw new Error();
      }, "transform");
      return { transform };
    } else if (typeof type === "object") {
      return type ?? {};
    }
    return this.ctx.get(`domain:${type}`) ?? {};
  }
  parseValue(source, kind, argv, decl = {}) {
    const { name, type = "string" } = decl;
    const domain = this.resolveDomain(type);
    try {
      return domain.transform(source, argv.session);
    } catch (err) {
      if (!argv.session) {
        argv.error = `internal.invalid-${kind}`;
      } else {
        const message = argv.session.text(err["message"] || "internal.check-syntax");
        argv.error = argv.session.text(`internal.invalid-${kind}`, [name, message]);
      }
    }
  }
  parseDecl(source) {
    let cap;
    const result = [];
    while (cap = BRACKET_REGEXP.exec(source)) {
      let rawName = cap[0].slice(1, -1);
      let variadic = false;
      if (rawName.startsWith("...")) {
        rawName = rawName.slice(3);
        variadic = true;
      }
      const [name, rawType] = rawName.split(":");
      const type = rawType ? rawType.trim() : void 0;
      result.push({
        name,
        variadic,
        type,
        required: cap[0][0] === "<"
      });
    }
    result.stripped = source.replace(/:[\w-]+(?=[>\]])/g, (str) => {
      const domain = this.ctx.get(`domain:${str.slice(1)}`);
      return domain?.greedy ? "..." : "";
    }).trimEnd();
    return result;
  }
};

// src/i18n.ts
var import_fastest_levenshtein = require("fastest-levenshtein");
var import_cosmokit7 = require("cosmokit");
var import_i18n_utils = require("@koishijs/i18n-utils");
var import_core6 = require("@satorijs/core");

// src/locales/zh-CN.yml
var zh_CN_default = { general: { $: "通用设置", name: "中文", paren: "（{0}）", quote: "“{0}”", comma: "，", and: "和", or: "或", day: "天", hour: "小时", minute: "分钟", second: "秒" }, internal: { $: "核心文本", "error-encountered": "发生未知错误。", "low-authority": "权限不足。", "prompt-argument": "请发送{0}。", "insufficient-arguments": "缺少参数，输入帮助以查看用法。", "redunant-arguments": "存在多余参数，输入帮助以查看用法。", "invalid-argument": "参数 {0} 输入无效，{1}", "unknown-option": "存在未知选项 {0}，输入帮助以查看用法。", "invalid-option": "选项 {0} 输入无效，{1}", "check-syntax": "输入帮助以查看用法。", "invalid-number": "请提供一个数字。", "invalid-integer": "请提供一个整数。", "invalid-posint": "请提供一个正整数。", "invalid-natural": "请提供一个非负整数。", "invalid-date": "请输入合法的时间。", "invalid-user": "请指定正确的用户。", "invalid-channel": "请指定正确的频道。", "invalid-image": "请上传图片。", "invalid-audio": "请上传音频。", "invalid-video": "请上传视频。", "invalid-file": "请上传文件。", "suggest-hint": "您要找的是不是{0}？", "suggest-command": "回复句号以使用推测的指令。" }, commands: { $: "指令系统" } };

// src/locales/en-US.yml
var en_US_default = { general: { $: "General Settings", name: "English", paren: " ({0}) ", quote: '"{0}"', comma: "，", and: "and", or: "or", day: "day", hour: "hour", minute: "minute", second: "second" }, internal: { $: "Internal Text", "error-encountered": "An unknown error has occurred.", "low-authority": "Low authority.", "prompt-argument": "请发送{0}。", "insufficient-arguments": "Insufficient arguments, type help to see usage.", "redunant-arguments": "Redunant arguments, type help to see usage.", "invalid-argument": "Invalid argument {0}, {1}", "unknown-option": "Unknown option {0}, type help to see usage.", "invalid-option": "Invalid option {0}, {1}", "check-syntax": "Type help to see usage.", "invalid-number": "Expect a number.", "invalid-integer": "Expect an integer.", "invalid-posint": "Expect a positive integer.", "invalid-natural": "Expect a non-negative integer.", "invalid-date": "Expect a valid date.", "invalid-user": "Expect a valid user.", "invalid-channel": "Expect a valid channel.", "invalid-image": "Expect an image.", "invalid-audio": "Expect an audio.", "invalid-video": "Expect a video.", "invalid-file": "Expect a file.", "suggest-hint": "Do you mean {0}?", "suggest-command": "Send a period to apply the suggestion." }, commands: { $: "Command System" } };

// src/i18n.ts
var logger2 = new import_core6.Logger("i18n");
var kTemplate = Symbol("template");
function createMatch(pattern) {
  const groups = [];
  const source = pattern.replace(/\(([^)]+)\)/g, (_, name) => {
    groups.push(name);
    return "(.+)";
  });
  const regexp = new RegExp(`^${source}$`);
  return (string) => {
    const capture = regexp.exec(string);
    if (!capture)
      return;
    const data = {};
    for (let i = 0; i < groups.length; i++) {
      data[groups[i]] = capture[i + 1];
    }
    return data;
  };
}
__name(createMatch, "createMatch");
var I18n = class {
  constructor(ctx, config) {
    this.ctx = ctx;
    this.locales = import_i18n_utils.LocaleTree.from(config.locales);
    this.define("", { "": "" });
    this.define("zh-CN", zh_CN_default);
    this.define("en-US", en_US_default);
  }
  static {
    __name(this, "I18n");
  }
  _data = {};
  _presets = {};
  locales;
  fallback(locales) {
    return (0, import_i18n_utils.fallback)(this.locales, locales);
  }
  compare(expect, actual, options = {}) {
    const value = 1 - (0, import_fastest_levenshtein.distance)(expect, actual) / expect.length;
    const threshold = options.minSimilarity ?? this.ctx.root.config.minSimilarity;
    return value >= threshold ? value : 0;
  }
  get(key, locales = []) {
    const result = {};
    for (const locale of this.fallback(locales)) {
      const value = this._data[locale]?.[key];
      if (value)
        result[locale] = value;
    }
    return result;
  }
  *set(locale, prefix, value) {
    if (typeof value === "object" && value && !prefix.includes("@")) {
      for (const key in value) {
        if (key.startsWith("_"))
          continue;
        yield* this.set(locale, prefix + key + ".", value[key]);
      }
    } else if (prefix.includes("@")) {
      throw new Error("preset is deprecated");
    } else if (typeof value === "string") {
      const dict = this._data[locale];
      const path2 = prefix.slice(0, -1);
      if (!(0, import_cosmokit7.isNullable)(dict[path2]) && !locale.startsWith("$") && dict[path2] !== value) {
        logger2.warn("override", locale, path2);
      }
      dict[path2] = value;
      yield path2;
    } else {
      delete this._data[locale][prefix.slice(0, -1)];
    }
  }
  define(locale, ...args) {
    const dict = this._data[locale] ||= {};
    const paths = [...typeof args[0] === "string" ? this.set(locale, args[0] + ".", args[1]) : this.set(locale, "", args[0])];
    this.ctx.emit("internal/i18n");
    return this.ctx.collect("i18n", () => {
      for (const path2 of paths) {
        delete dict[path2];
      }
      this.ctx.emit("internal/i18n");
    });
  }
  find(pattern, actual, options = {}) {
    if (!actual)
      return [];
    const match = createMatch(pattern);
    const results = [];
    for (const locale in this._data) {
      for (const path2 in this._data[locale]) {
        const data = match(path2);
        if (!data)
          continue;
        const expect = this._data[locale][path2];
        if (typeof expect !== "string")
          continue;
        const similarity = this.compare(expect, actual, options);
        if (!similarity)
          continue;
        results.push({ locale, data, similarity });
      }
    }
    return results;
  }
  _render(value, params, locale) {
    if (value === void 0)
      return;
    if (typeof value !== "string") {
      const preset = value[kTemplate];
      const render = this._presets[preset];
      if (!render)
        throw new Error(`Preset "${preset}" not found`);
      return [import_core6.h.text(render(value, params, locale))];
    }
    return import_core6.h.parse(value, params);
  }
  /** @deprecated */
  text(locales, paths, params) {
    return this.render(locales, paths, params).join("");
  }
  render(locales, paths, params) {
    locales = this.fallback(locales);
    for (const path2 of paths) {
      for (const locale of locales) {
        for (const key of ["$" + locale, locale]) {
          const value = this._data[key]?.[path2];
          if (value === void 0 || !value && !locale && path2 !== "")
            continue;
          return this._render(value, params, locale);
        }
      }
    }
    logger2.warn("missing", paths[0]);
    return [import_core6.h.text(paths[0])];
  }
};
((I18n2) => {
  I18n2.Config = import_core6.Schema.object({
    locales: import_core6.Schema.array(String).role("table").default(["zh-CN", "en-US", "fr-FR", "ja-JP", "de-DE", "ru-RU"]).description("可用的语言列表。按照回退顺序排列。"),
    output: import_core6.Schema.union([
      import_core6.Schema.const("prefer-user").description("优先使用用户语言"),
      import_core6.Schema.const("prefer-channel").description("优先使用频道语言")
    ]).default("prefer-channel").description("输出语言偏好设置。")
  }).description("国际化设置");
})(I18n || (I18n = {}));

// src/session.ts
var import_utils4 = require("@koishijs/utils");
var import_cosmokit8 = require("cosmokit");
var import_core7 = require("@satorijs/core");
var import_minato = require("minato");
var logger3 = new import_core7.Logger("session");
function collectFields(argv, collectors, fields) {
  for (const collector of collectors) {
    if (typeof collector === "function") {
      collector(argv, fields);
      continue;
    }
    for (const field of collector) {
      fields.add(field);
    }
  }
  return fields;
}
__name(collectFields, "collectFields");
var KoishiSession = class {
  static {
    __name(this, "KoishiSession");
  }
  constructor(ctx) {
    ctx.mixin(this, {
      resolve: "session.resolve",
      stripped: "session.stripped",
      username: "session.username",
      send: "session.send",
      cancelQueued: "session.cancelQueued",
      sendQueued: "session.sendQueued",
      getChannel: "session.getChannel",
      observeChannel: "session.observeChannel",
      getUser: "session.getUser",
      observeUser: "session.observeUser",
      withScope: "session.withScope",
      resolveScope: "session.resolveScope",
      text: "session.text",
      i18n: "session.i18n",
      collect: "session.collect",
      execute: "session.execute",
      middleware: "session.middleware",
      prompt: "session.prompt",
      suggest: "session.suggest"
    });
  }
  resolve(source, ...params) {
    if (typeof source === "function") {
      return Reflect.apply(source, null, [this, ...params]);
    }
    if (!(0, import_minato.isEvalExpr)(source))
      return source;
    return (0, import_minato.executeEval)({ _: this }, source);
  }
  _stripNickname(content) {
    if (content.startsWith("@"))
      content = content.slice(1);
    for (const nickname of this.resolve(this.app.koishi.config.nickname) ?? []) {
      if (!content.startsWith(nickname))
        continue;
      const rest = content.slice(nickname.length);
      const capture = /^([,，]\s*|\s+)/.exec(rest);
      if (!capture)
        continue;
      return rest.slice(capture[0].length);
    }
  }
  /** @deprecated */
  get parsed() {
    return this.stripped;
  }
  get stripped() {
    if (this._stripped)
      return this._stripped;
    if (!this.elements)
      return {};
    let atSelf = false, appel = false;
    let hasAt = false;
    const elements = this.elements.slice();
    while (elements[0]?.type === "at") {
      const { attrs } = elements.shift();
      if (attrs.id === this.selfId) {
        atSelf = appel = true;
      }
      if (!this.quote?.user?.id || this.quote.user.id !== attrs.id) {
        hasAt = true;
      }
      if (elements[0]?.type === "text" && !elements[0].attrs.content.trim()) {
        elements.shift();
      }
    }
    let content = elements.join("").trim();
    if (!hasAt) {
      const result = this._stripNickname(content);
      if (result) {
        appel = true;
        content = result;
      }
    }
    return this._stripped = { hasAt, content, appel, atSelf, prefix: null };
  }
  get username() {
    return this.user && this.user["name"] ? this.user["name"] : this.author.nick || this.author.name || this.userId;
  }
  async send(fragment, options = {}) {
    if (!fragment)
      return;
    options.session = this;
    return this.bot.sendMessage(this.channelId, fragment, this.guildId, options).catch((error) => {
      logger3.warn(error);
      return [];
    });
  }
  cancelQueued(delay = this.app.koishi.config.delay.cancel) {
    clearTimeout(this._queuedTimeout);
    this._queuedTasks = [];
    this._queuedTimeout = setTimeout(() => this._next(), delay);
  }
  _next() {
    const task = this._queuedTasks?.shift();
    if (!task) {
      this._queuedTimeout = null;
      return;
    }
    this.send(task.content).then(task.resolve, task.reject);
    this._queuedTimeout = setTimeout(() => this._next(), task.delay);
  }
  async sendQueued(content, delay) {
    const text = import_core7.h.normalize(content).join("");
    if (!text)
      return;
    if ((0, import_cosmokit8.isNullable)(delay)) {
      const { message, character } = this.app.koishi.config.delay;
      delay = Math.max(message, character * text.length);
    }
    return new Promise((resolve, reject) => {
      (this._queuedTasks ??= []).push({ content, delay, resolve, reject });
      if (!this._queuedTimeout)
        this._next();
    });
  }
  async getChannel(id = this.channelId, fields = []) {
    const { app, platform, guildId } = this;
    if (!fields.length)
      return { platform, id, guildId };
    const channel = await app.database.getChannel(platform, id, fields);
    if (channel)
      return channel;
    const assignee = this.resolve(app.koishi.config.autoAssign) ? this.selfId : "";
    if (assignee) {
      return app.database.createChannel(platform, id, { assignee, guildId, createdAt: /* @__PURE__ */ new Date() });
    } else {
      const channel2 = app.model.tables.channel.create();
      Object.assign(channel2, { platform, id, guildId, $detached: true });
      return channel2;
    }
  }
  async _observeChannelLike(channelId, fields = []) {
    const fieldSet = new Set(fields);
    const { platform } = this;
    const key = `${platform}:${channelId}`;
    let cache = this.app.$processor._channelCache.get(this.id, key);
    if (cache) {
      for (const key2 in cache) {
        fieldSet.delete(key2);
      }
      if (!fieldSet.size)
        return cache;
    }
    const data = await this.getChannel(channelId, [...fieldSet]);
    cache = this.app.$processor._channelCache.get(this.id, key);
    if (cache) {
      cache.$merge(data);
    } else {
      cache = (0, import_utils4.observe)(data, async (diff) => {
        if (data["$detached"])
          return;
        await this.app.database.setChannel(platform, channelId, diff);
      }, `channel ${key}`);
      this.app.$processor._channelCache.set(this.id, key, cache);
    }
    return cache;
  }
  async observeChannel(fields) {
    const tasks = [this._observeChannelLike(this.channelId, fields)];
    if (this.channelId !== this.guildId) {
      tasks.push(this._observeChannelLike(this.guildId, fields));
    }
    const [channel, guild = channel] = await Promise.all(tasks);
    this.guild = guild;
    this.channel = channel;
    return channel;
  }
  async getUser(userId = this.userId, fields = []) {
    const { app, platform } = this;
    if (!fields.length)
      return {};
    const user = await app.database.getUser(platform, userId, fields);
    if (user)
      return user;
    const authority = this.resolve(app.koishi.config.autoAuthorize);
    const data = { locales: this.locales, authority, createdAt: /* @__PURE__ */ new Date() };
    if (authority) {
      return app.database.createUser(platform, userId, data);
    } else {
      const user2 = app.model.tables.user.create();
      Object.assign(user2, { ...data, $detached: true });
      return user2;
    }
  }
  async observeUser(fields) {
    const fieldSet = new Set(fields);
    const { userId } = this;
    let cache = this.user || this.app.$processor._userCache.get(this.id, this.uid);
    if (cache) {
      for (const key in cache) {
        fieldSet.delete(key);
      }
      if (!fieldSet.size)
        return this.user = cache;
    }
    if (this.author?.["anonymous"]) {
      const fallback2 = this.app.model.tables.user.create();
      fallback2.authority = this.resolve(this.app.koishi.config.autoAuthorize);
      const user = (0, import_utils4.observe)(fallback2, () => Promise.resolve());
      return this.user = user;
    }
    const data = await this.getUser(userId, [...fieldSet]);
    cache = this.user || this.app.$processor._userCache.get(this.id, this.uid);
    if (cache) {
      cache.$merge(data);
    } else {
      cache = (0, import_utils4.observe)(data, async (diff) => {
        if (data["$detached"])
          return;
        await this.app.database.setUser(this.platform, userId, diff);
      }, `user ${this.uid}`);
      this.app.$processor._userCache.set(this.id, this.uid, cache);
    }
    return this.user = cache;
  }
  async withScope(scope, callback) {
    const oldScope = this.scope;
    try {
      this.scope = scope;
      const result = await callback();
      return import_core7.h.transform(result, {
        i18n: (params, children) => import_core7.h.i18n({
          ...params,
          path: this.resolveScope(params.path)
        }, children)
      }, this);
    } finally {
      this.scope = oldScope;
    }
  }
  resolveScope(path2) {
    if (!path2.startsWith("."))
      return path2;
    if (!this.scope) {
      this.app.logger("i18n").warn(new Error(`missing scope for "${path2}"`));
      return "";
    }
    return this.scope + path2;
  }
  text(path2, params = {}) {
    return this.i18n(path2, params).join("");
  }
  i18n(path2, params = {}) {
    const locales = [
      ...this.channel?.locales || [],
      ...this.guild?.locales || []
    ];
    if (this.app.koishi.config.i18n.output === "prefer-user") {
      locales.unshift(...this.user?.locales || []);
    } else {
      locales.push(...this.user?.locales || []);
    }
    locales.unshift(...this.locales || []);
    const paths = (0, import_cosmokit8.makeArray)(path2).map((path3) => this.resolveScope(path3));
    return this.app.i18n.render(locales, paths, params);
  }
  collect(key, argv, fields = /* @__PURE__ */ new Set()) {
    const collect = /* @__PURE__ */ __name((argv2) => {
      argv2.session = this;
      if (argv2.tokens) {
        for (const { inters } of argv2.tokens) {
          inters.forEach(collect);
        }
      }
      if (!this.app.$commander.resolveCommand(argv2))
        return;
      this.app.emit(argv2.session, `command/before-attach-${key}`, argv2, fields);
      collectFields(argv2, argv2.command[`_${key}Fields`], fields);
    }, "collect");
    if (argv)
      collect(argv);
    return fields;
  }
  async execute(argv, next) {
    if (typeof argv === "string")
      argv = Argv.parse(argv);
    argv.session = this;
    if (argv.tokens) {
      for (const arg of argv.tokens) {
        const { inters } = arg;
        const output = [];
        for (let i = 0; i < inters.length; ++i) {
          const execution = await this.execute(inters[i], true);
          const transformed = await this.transform(import_core7.h.normalize(execution));
          output.push(transformed.join(""));
        }
        for (let i = inters.length - 1; i >= 0; --i) {
          const { pos } = inters[i];
          arg.content = arg.content.slice(0, pos) + output[i] + arg.content.slice(pos);
        }
        arg.inters = [];
      }
      if (!this.app.$commander.resolveCommand(argv))
        return "";
    } else {
      argv.command ||= this.app.$commander.get(argv.name);
      if (!argv.command) {
        logger3.warn(new Error(`cannot find command ${argv.name}`));
        return "";
      }
    }
    const { command } = argv;
    if (!command.ctx.filter(this))
      return "";
    if (this.app.database) {
      if (!this.isDirect) {
        await this.observeChannel(this.collect("channel", argv, /* @__PURE__ */ new Set(["permissions", "locales"])));
      }
      await this.observeUser(this.collect("user", argv, /* @__PURE__ */ new Set(["authority", "permissions", "locales"])));
    }
    let shouldEmit = true;
    if (next === true) {
      shouldEmit = false;
      next = void 0;
    }
    return this.withScope(`commands.${command.name}.messages`, async () => {
      const result = await command.execute(argv, next);
      if (!shouldEmit) {
        if (typeof result === "string")
          return result;
        return (0, import_core7.h)(null, result).toString();
      }
      await this.send(result);
      return "";
    });
  }
  middleware(middleware) {
    const id = this.fid;
    return this.app.middleware(async (session, next) => {
      if (id && session.fid !== id)
        return next();
      return middleware(session, next);
    }, true);
  }
  prompt(...args) {
    const callback = typeof args[0] === "function" ? args.shift() : (session) => {
      const elements = session.elements.slice();
      if (elements[0]?.type === "at" && elements[0].attrs.id === session.selfId) {
        elements.shift();
      }
      return elements.join("").trim();
    };
    const options = typeof args[0] === "number" ? { timeout: args[0] } : args[0] ?? {};
    return new Promise((resolve) => {
      const dispose = this.middleware(async (session, next) => {
        clearTimeout(timer);
        dispose();
        const value = await callback(session);
        resolve(value);
        if ((0, import_cosmokit8.isNullable)(value))
          return next();
      });
      const timer = setTimeout(() => {
        dispose();
        resolve(void 0);
      }, options.timeout ?? this.app.koishi.config.delay.prompt);
    });
  }
  async suggest(options) {
    let { expect, filter: filter2, prefix = "" } = options;
    if (options.actual) {
      expect = expect.filter((name) => {
        return name && this.app.i18n.compare(name, options.actual, options);
      });
      if (filter2) {
        expect = (await Promise.all(expect.map(async (name) => [name, await filter2(name)]))).filter(([, result]) => result).map(([name]) => name);
      }
    }
    if (!expect.length) {
      await this.send(prefix);
      return;
    }
    prefix += this.text("internal.suggest-hint", [expect.map((text) => {
      return this.text("general.quote", [text]);
    }).join(this.text("general.or"))]);
    if (expect.length > 1) {
      await this.send(prefix);
      return;
    }
    await this.send(prefix + options.suffix);
    return this.prompt((session) => {
      const { content, atSelf, hasAt } = session.stripped;
      if (!atSelf && hasAt)
        return;
      if (content === "." || content === "。") {
        return expect[0];
      }
    }, options);
  }
};
var session_default = KoishiSession;

// src/permission.ts
var import_core8 = require("@satorijs/core");
var import_cosmokit9 = require("cosmokit");
var logger4 = new import_core8.Logger("app");
var Permissions = class {
  constructor(ctx) {
    this.ctx = ctx;
    (0, import_cosmokit9.defineProperty)(this, Context.current, ctx);
    ctx.alias("permissions", ["perms"]);
    this.define("authority:(value)", {
      check: ({ value }, { user }) => {
        return !user || user.authority >= +value;
      },
      list: () => Array(5).fill(0).map((_, i) => `authority:${i}`)
    });
    this.provide("(name)", ({ name }, session) => {
      return session.bot?.checkPermission(name, session);
    });
    this.provide("(name)", ({ name }, session) => {
      return session.permissions?.includes(name) || session.user?.permissions?.includes(name) || session.channel?.permissions?.includes(name);
    });
  }
  static {
    __name(this, "Permissions");
  }
  store = [];
  define(pattern, options) {
    const entry = {
      ...options,
      match: createMatch(pattern)
    };
    if (!pattern.includes("("))
      entry.list ||= () => [pattern];
    return this.ctx.effect(() => {
      this.store.push(entry);
      return () => (0, import_cosmokit9.remove)(this.store, entry);
    });
  }
  provide(pattern, check) {
    return this.define(pattern, { check });
  }
  inherit(pattern, inherits) {
    return this.define(pattern, { inherits });
  }
  depend(pattern, depends) {
    return this.define(pattern, { depends });
  }
  list(result = /* @__PURE__ */ new Set()) {
    for (const { list } of this.store) {
      if (!list)
        continue;
      for (const name of list()) {
        result.add(name);
      }
    }
    return [...result];
  }
  async check(name, session) {
    const results = await Promise.all(this.store.map(async ({ match, check }) => {
      if (!check)
        return false;
      const data = match(name);
      if (!data)
        return false;
      try {
        return await check(data, session);
      } catch (error) {
        logger4.warn(error);
        return false;
      }
    }));
    return results.some(Boolean);
  }
  subgraph(type, parents, result = /* @__PURE__ */ new Set()) {
    let name;
    const queue = [...parents];
    while (name = queue.shift()) {
      if (result.has(name))
        continue;
      result.add(name);
      for (const entry of this.store) {
        const data = entry.match(name);
        if (!data)
          continue;
        let links = entry[type];
        if (typeof links === "function")
          links = links(data);
        if (Array.isArray(links))
          queue.push(...links);
      }
    }
    return result;
  }
  async test(names, session = {}, cache = /* @__PURE__ */ new Map()) {
    session = session[Context.shadow] || session;
    if (typeof names === "string")
      names = [names];
    for (const name of this.subgraph("depends", names)) {
      const parents = [...this.subgraph("inherits", [name])];
      const results = await Promise.all(parents.map((parent) => {
        let result = cache.get(parent);
        if (!result) {
          result = this.check(parent, session);
          cache.set(parent, result);
        }
        return result;
      }));
      if (results.some((result) => result))
        continue;
      return false;
    }
    return true;
  }
};

// src/bot.ts
var import_utils5 = require("@koishijs/utils");
var import_cosmokit10 = require("cosmokit");
var import_core9 = require("@satorijs/core");
(0, import_cosmokit10.defineProperty)(import_core9.Bot, "filter", false);
(0, import_cosmokit10.defineProperty)(import_core9.Adapter, "filter", false);
var KoishiBot = class {
  static {
    __name(this, "KoishiBot");
  }
  constructor(ctx) {
    ctx.mixin(this, {
      getGuildMemberMap: "bot.getGuildMemberMap",
      broadcast: "bot.broadcast"
    });
  }
  async getGuildMemberMap(guildId) {
    const result = {};
    for await (const member of this.getGuildMemberIter(guildId)) {
      result[member.user.id] = member.name || member.user.name;
    }
    return result;
  }
  async broadcast(channels, content, delay = this.ctx.root.config.delay.broadcast) {
    const ids = [];
    for (let index = 0; index < channels.length; index++) {
      if (index && delay)
        await (0, import_utils5.sleep)(delay);
      try {
        const value = channels[index];
        ids.push(...typeof value === "string" ? await this.sendMessage(value, content) : Array.isArray(value) ? await this.sendMessage(value[0], content, value[1]) : await this.sendMessage(value.channelId, content, value.guildId, { session: value }));
      } catch (error) {
        this.ctx.logger("bot").warn(error);
      }
    }
    return ids;
  }
};
var bot_default = KoishiBot;

// src/schema.ts
var import_cosmokit11 = require("cosmokit");
var import_core10 = require("@satorijs/core");
import_core10.Schema.dynamic = /* @__PURE__ */ __name(function dynamic(name) {
  return import_core10.Schema.any().role("dynamic", { name });
}, "dynamic");
import_core10.Schema.filter = /* @__PURE__ */ __name(function filter() {
  return import_core10.Schema.any().role("filter");
}, "filter");
import_core10.Schema.computed = /* @__PURE__ */ __name(function computed(inner, options = {}) {
  return import_core10.Schema.union([
    import_core10.Schema.from(inner),
    import_core10.Schema.object({
      $switch: import_core10.Schema.object({
        branches: import_core10.Schema.array(import_core10.Schema.object({
          case: import_core10.Schema.any(),
          then: import_core10.Schema.from(inner)
        })),
        default: import_core10.Schema.from(inner)
      })
    }).hidden(),
    import_core10.Schema.any().hidden()
  ]).role("computed", options);
}, "computed");
import_core10.Schema.path = /* @__PURE__ */ __name(function path(options = {}) {
  return import_core10.Schema.string().role("path", options);
}, "path");
import_core10.Schema.prototype.computed = /* @__PURE__ */ __name(function computed2(options = {}) {
  return import_core10.Schema.computed(this, options).default(this.meta.default);
}, "computed");
var kSchemaOrder = Symbol("schema-order");
var SchemaService = class {
  constructor(ctx) {
    this.ctx = ctx;
    this.extend("intercept.http", import_core10.Schema.object({
      timeout: import_core10.Schema.natural().role("ms").description("等待连接建立的最长时间。"),
      proxyAgent: import_core10.Schema.string().description("使用的代理服务器地址。"),
      keepAlive: import_core10.Schema.boolean().description("是否保持连接。")
    }));
  }
  static {
    __name(this, "SchemaService");
  }
  _data = /* @__PURE__ */ Object.create(null);
  extend(name, schema, order = 0) {
    const caller = this[Context.current];
    const target = this.get(name);
    const index = target.list.findIndex((a) => a[kSchemaOrder] < order);
    schema[kSchemaOrder] = order;
    if (index >= 0) {
      target.list.splice(index, 0, schema);
    } else {
      target.list.push(schema);
    }
    this.ctx.emit("internal/schema", name);
    caller?.on("dispose", () => {
      (0, import_cosmokit11.remove)(target.list, schema);
      this.ctx.emit("internal/schema", name);
    });
  }
  get(name) {
    return this._data[name] ||= import_core10.Schema.intersect([]);
  }
  set(name, schema) {
    const caller = this[Context.current];
    this._data[name] = schema;
    this.ctx.emit("internal/schema", name);
    caller?.on("dispose", () => {
      delete this._data[name];
      this.ctx.emit("internal/schema", name);
    });
  }
};

// src/context.ts
var import_core12 = require("@satorijs/core");
var import_cordis = require("cordis");
var Context = class extends satori.Context {
  static {
    __name(this, "Context");
  }
  static shadow = Symbol.for("session.shadow");
  constructor(config = {}) {
    super(config);
    this.mixin("$processor", ["match", "middleware"]);
    this.mixin("$filter", [
      "any",
      "never",
      "union",
      "intersect",
      "exclude",
      "user",
      "self",
      "guild",
      "channel",
      "platform",
      "private"
    ]);
    this.mixin("$commander", ["command"]);
    this.provide("$filter", new FilterService(this), true);
    this.provide("schema", new SchemaService(this), true);
    this.provide("$processor", new Processor(this), true);
    this.provide("i18n", new I18n(this, this.config.i18n), true);
    this.provide("permissions", new Permissions(this), true);
    this.provide("model", void 0, true);
    this.provide("http", void 0, true);
    this.provide("$commander", new Commander(this, this.config), true);
    this.plugin(minato.Database);
    this.plugin(Koishi, this.config);
  }
  /** @deprecated use `ctx.root` instead */
  get app() {
    return this.root;
  }
  /** @deprecated use `koishi.config` instead */
  get options() {
    return this.root.config;
  }
  async waterfall(...args) {
    const thisArg = typeof args[0] === "object" || typeof args[0] === "function" ? args.shift() : null;
    const name = args.shift();
    for (const hook of this.lifecycle.filterHooks(this.lifecycle._hooks[name] || [], thisArg)) {
      const result = await hook.callback.apply(thisArg, args);
      args[0] = result;
    }
    return args[0];
  }
  chain(...args) {
    const thisArg = typeof args[0] === "object" || typeof args[0] === "function" ? args.shift() : null;
    const name = args.shift();
    for (const hook of this.lifecycle.filterHooks(this.lifecycle._hooks[name] || [], thisArg)) {
      const result = hook.callback.apply(thisArg, args);
      args[0] = result;
    }
    return args[0];
  }
  /* eslint-enable max-len */
  before(name, listener, append = false) {
    const seg = name.split("/");
    seg[seg.length - 1] = "before-" + seg[seg.length - 1];
    return this.on(seg.join("/"), listener, !append);
  }
};
var Koishi = class extends cordis.Service {
  constructor(ctx, config) {
    super(ctx, "koishi", true);
    this.config = config;
  }
  static {
    __name(this, "Koishi");
  }
  bot = new bot_default(this.ctx);
  database = new database_default(this.ctx);
  session = new session_default(this.ctx);
};
satori.Session.prototype[Context.filter] = function(ctx) {
  return ctx.filter(this);
};
((Context3) => {
  Context3.Config = import_core11.Schema.intersect([
    import_core11.Schema.object({})
  ]);
})(Context || (Context = {}));
(0, import_cosmokit12.defineProperty)(Context.Config, "Basic", import_core11.Schema.object({
  prefix: import_core11.Schema.array(import_core11.Schema.string().default("")).default([""]).role("table").computed().description("指令前缀字符构成的数组。将被用于指令的匹配。"),
  prefixMode: import_core11.Schema.union([
    import_core11.Schema.const("auto").description("默认：当存在称呼时允许无前缀触发。"),
    import_core11.Schema.const("strict").description("严格：只有在指令前缀匹配时才允许触发。")
  ]).experimental().role("radio").default("auto").description("指令前缀匹配模式。"),
  nickname: import_core11.Schema.array(String).role("table").computed().description("机器人昵称构成的数组。将被用于指令的匹配。"),
  autoAssign: import_core11.Schema.boolean().default(true).computed().description("当获取不到频道数据时，是否使用接受者作为受理人。"),
  autoAuthorize: import_core11.Schema.natural().default(1).computed().description("当获取不到用户数据时默认使用的权限等级。"),
  minSimilarity: import_core11.Schema.percent().default(1).description("用于模糊匹配的相似系数，应该是一个 0 到 1 之间的数值。数值越高，模糊匹配越严格。设置为 1 可以完全禁用模糊匹配。")
}).description("基础设置"));
(0, import_cosmokit12.defineProperty)(Context.Config, "I18n", I18n.Config);
(0, import_cosmokit12.defineProperty)(Context.Config, "Delay", import_core11.Schema.object({
  character: import_core11.Schema.natural().role("ms").default(0).description("调用 `session.sendQueued()` 时消息间发送的最小延迟，按前一条消息的字数计算。"),
  message: import_core11.Schema.natural().role("ms").default(0.1 * import_cosmokit12.Time.second).description("调用 `session.sendQueued()` 时消息间发送的最小延迟，按固定值计算。"),
  cancel: import_core11.Schema.natural().role("ms").default(0).description("调用 `session.cancelQueued()` 时默认的延迟。"),
  broadcast: import_core11.Schema.natural().role("ms").default(0.5 * import_cosmokit12.Time.second).description("调用 `bot.broadcast()` 时默认的延迟。"),
  prompt: import_core11.Schema.natural().role("ms").default(import_cosmokit12.Time.minute).description("调用 `session.prompt()` 时默认的等待时间。")
}));
(0, import_cosmokit12.defineProperty)(Context.Config, "Advanced", import_core11.Schema.object({
  maxListeners: import_core11.Schema.natural().default(64).description("每种监听器的最大数量。如果超过这个数量，Koishi 会认定为发生了内存泄漏，将产生一个警告。")
}).description("高级设置"));
Context.Config.list.push(Context.Config.Basic);
Context.Config.list.push(import_core11.Schema.object({
  i18n: I18n.Config
}));
Context.Config.list.push(import_core11.Schema.object({
  delay: Context.Config.Delay
}).description("延迟设置"));
Context.Config.list.push(Context.Config.Advanced);
Context.Config.list.push(import_core11.Schema.object({
  request: import_core11.HTTP.Config
}));
var Service3 = class extends satori.Service {
  static {
    __name(this, "Service");
  }
  [satori.Service.setup]() {
    this.ctx = new Context();
  }
};
function defineConfig(config) {
  return config;
}
__name(defineConfig, "defineConfig");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Adapter,
  App,
  Argv,
  Bot,
  Channel,
  Command,
  Commander,
  Context,
  Element,
  FilterService,
  HTTP,
  I18n,
  Logger,
  MessageEncoder,
  Messenger,
  Next,
  Permissions,
  Processor,
  Quester,
  Schema,
  SchemaService,
  Service,
  SessionError,
  SharedCache,
  Universal,
  User,
  createMatch,
  defineConfig,
  h,
  resolveConfig,
  segment,
  version,
  z,
  ...require("@koishijs/utils"),
  ...require("minato")
});
//# sourceMappingURL=index.cjs.map
