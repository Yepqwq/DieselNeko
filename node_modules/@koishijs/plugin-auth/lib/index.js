var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// external/webui/plugins/auth/src/locales/zh-CN.yml
var require_zh_CN = __commonJS({
  "external/webui/plugins/auth/src/locales/zh-CN.yml"(exports, module2) {
    module2.exports = [{ $description: "管理员设置", admin: { enabled: "启用管理员账号。", username: "管理员用户名。", password: "管理员密码。" } }, { $description: "高级设置", authTokenExpire: "用户令牌有效期。", loginTokenExpire: "登录令牌有效期。" }];
  }
});

// external/webui/plugins/auth/src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => src_default,
  randomId: () => randomId
});
module.exports = __toCommonJS(src_exports);
var import_koishi = require("koishi");
var import_crypto = require("crypto");
var import_path = require("path");
var letters = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
function randomId(length = 40) {
  return Array(length).fill(0).map(() => letters[Math.floor(Math.random() * letters.length)]).join("");
}
__name(randomId, "randomId");
function toHash(password) {
  return (0, import_crypto.createHash)("sha256").update(password).digest("hex");
}
__name(toHash, "toHash");
var _AuthService = class _AuthService extends import_koishi.Service {
  constructor(ctx, config) {
    super(ctx, "auth");
    this.config = config;
    ctx.model.extend("user", {
      password: "string(255)",
      config: {
        type: "json",
        length: 65535,
        initial: null
      }
    });
    ctx.model.extend("token", {
      inc: "unsigned",
      id: "unsigned",
      type: "string(255)",
      token: "string(255)",
      expiredAt: "unsigned(8)",
      createdAt: "timestamp",
      lastUsedAt: "timestamp",
      userAgent: "string(255)",
      address: "string(255)"
    }, {
      primary: "inc",
      autoInc: true,
      unique: ["token"]
    });
    ctx.console.addEntry({
      dev: (0, import_path.resolve)(__dirname, "../client/index.ts"),
      prod: (0, import_path.resolve)(__dirname, "../dist")
    });
    this.initLogin();
  }
  async start() {
    const { enabled, username, password } = this.config.admin;
    if (!enabled)
      return;
    this.logger.info("creating admin account");
    await this.ctx.database.upsert("user", [{
      id: 0,
      name: username,
      authority: 5,
      password: toHash(password),
      createdAt: /* @__PURE__ */ new Date()
    }]);
  }
  async setAuth(client, auth = client.auth, passive = false) {
    client.auth = auth;
    if (passive)
      return;
    if (auth) {
      const bindings = await this.ctx.database.get("binding", { aid: auth.id });
      bindings.forEach((binding) => delete binding.aid);
      const tokens = await this.ctx.database.get("token", { id: auth.id });
      tokens.reverse().forEach((login) => (delete login.id, delete login.token));
      client.send({ type: "data", body: { key: "user", value: { ...auth, bindings, tokens } } });
    } else {
      client.send({ type: "data", body: { key: "user", value: null } });
    }
    client.ctx.emit("console/connection", client);
    client.refresh();
  }
  async createToken(client, type, user) {
    var _a, _b;
    const { headers, socket } = client.request;
    const createdAt = /* @__PURE__ */ new Date();
    const lastUsedAt = /* @__PURE__ */ new Date();
    const userAgent = (_a = headers["user-agent"]) == null ? void 0 : _a.toString();
    const address = ((_b = headers["x-forwarded-for"]) == null ? void 0 : _b.toString()) || socket.remoteAddress;
    const expiredAt = Date.now() + this.config.authTokenExpire;
    const token = randomId();
    await this.ctx.database.create("token", { id: user.id, type, expiredAt, token, createdAt, lastUsedAt, userAgent, address });
    await this.setAuth(client, { ...user, expiredAt, token });
  }
  initLogin() {
    const self = this;
    const { ctx, config } = this;
    const states = {};
    ctx.console.addListener("login/password", async function(name, password) {
      password = toHash(password);
      const [user] = await ctx.database.get("user", { name }, ["password", "name", "id", "authority", "config"]);
      if (!user || user.password !== password)
        throw new Error("用户名或密码错误。");
      await self.createToken(this, "password", (0, import_koishi.omit)(user, ["password"]));
    });
    ctx.console.addListener("login/token", async function(aid, token) {
      const [data] = await ctx.database.get("token", { id: aid, token }, ["expiredAt"]);
      if (!data || data.expiredAt <= Date.now())
        throw new Error("令牌已失效。");
      const [user] = await ctx.database.get("user", { id: aid }, ["id", "name", "authority", "config"]);
      if (!user)
        throw new Error("用户不存在。");
      await ctx.database.set("token", { token }, { lastUsedAt: /* @__PURE__ */ new Date() });
      await self.setAuth(this, { ...user, ...data, token });
    });
    ctx.console.addListener("login/platform", async function(platform, userId) {
      var _a;
      const user = await ctx.database.getUser(platform, userId, ["id", "name"]);
      if (!user)
        throw new Error("找不到此账户。");
      if (((_a = this.auth) == null ? void 0 : _a.id) === user.id)
        throw new Error("你已经绑定了此账户。");
      const key = `${platform}:${userId}`;
      const token = Math.random().toString().slice(2, 8);
      const expiredAt = Date.now() + config.loginTokenExpire;
      states[key] = [token, expiredAt, this];
      const listener = /* @__PURE__ */ __name(() => {
        delete states[key];
        dispose();
        this.socket.removeEventListener("close", dispose);
      }, "listener");
      const dispose = ctx.setTimeout(() => {
        var _a2;
        if (((_a2 = states[key]) == null ? void 0 : _a2[1]) >= Date.now())
          listener();
      }, config.loginTokenExpire);
      this.socket.addEventListener("close", listener);
      return { id: user.id, name: user.name, token, expiredAt };
    });
    ctx.middleware(async (session, next) => {
      const state = states[session.uid];
      if (!state || state[0] !== session.stripped.content) {
        return next();
      }
      const { platform, userId: pid } = session;
      if (state[2].auth) {
        await ctx.database.set("binding", { platform, pid }, { aid: state[2].auth.id });
        return self.setAuth(state[2], state[2].auth);
      } else {
        const user = await session.observeUser(["id", "name", "authority", "config"]);
        return self.createToken(state[2], "platform", user);
      }
    }, true);
    ctx.on("console/intercept", async (client, listener) => {
      if (!listener.authority)
        return false;
      if (!client.auth)
        return true;
      if (client.auth.expiredAt <= Date.now())
        return true;
      if (client.auth.authority < listener.authority)
        return true;
    });
    ctx.console.addListener("user/delete-token", async function(inc) {
      if (!this.auth)
        throw new Error("请先登录。");
      const [data] = await ctx.database.get("token", { id: this.auth.id, inc });
      if (!data)
        throw new Error("令牌不存在。");
      await ctx.database.remove("token", { inc });
      await self.setAuth(this);
    });
    ctx.console.addListener("user/logout", async function() {
      if (this.auth) {
        await ctx.database.remove("token", { token: this.auth.token });
      }
      await self.setAuth(this, null);
    });
    ctx.console.addListener("user/update", async function(data) {
      if (!this.auth)
        throw new Error("请先登录。");
      if (data.password)
        data.password = toHash(data.password);
      await ctx.database.set("user", { id: this.auth.id }, data);
      Object.assign(this.auth, data);
      await self.setAuth(this, void 0, true);
    });
    ctx.console.addListener("user/unbind", async function(platform, pid) {
      if (!this.auth)
        throw new Error("请先登录。");
      const bindings = await ctx.database.get("binding", { aid: this.auth.id });
      const binding = bindings.find((item) => item.platform === platform && item.pid === pid);
      if (binding.aid !== binding.bid) {
        await ctx.database.set("binding", { platform, pid }, { aid: binding.bid });
      } else if (bindings.filter((item) => item.aid === item.bid).length === 1) {
        throw new Error("无法解除绑定。");
      } else {
        await ctx.database.remove("binding", { platform, pid });
      }
      await self.setAuth(this);
    });
  }
};
__name(_AuthService, "AuthService");
__publicField(_AuthService, "inject", ["console", "database"]);
var AuthService = _AuthService;
((AuthService2) => {
  AuthService2.filter = false;
  AuthService2.Admin = import_koishi.Schema.intersect([
    import_koishi.Schema.object({
      enabled: import_koishi.Schema.boolean().default(true)
    }),
    import_koishi.Schema.union([
      import_koishi.Schema.object({
        enabled: import_koishi.Schema.const(true),
        username: import_koishi.Schema.string().default("admin"),
        password: import_koishi.Schema.string().role("secret").required()
      }),
      import_koishi.Schema.object({})
    ])
  ]);
  AuthService2.Config = import_koishi.Schema.intersect([
    import_koishi.Schema.object({
      admin: AuthService2.Admin
    }),
    import_koishi.Schema.object({
      authTokenExpire: import_koishi.Schema.natural().role("ms").default(import_koishi.Time.week).min(import_koishi.Time.hour),
      loginTokenExpire: import_koishi.Schema.natural().role("ms").default(import_koishi.Time.minute * 10).min(import_koishi.Time.minute)
    })
  ]).i18n({
    "zh-CN": require_zh_CN()
  });
})(AuthService || (AuthService = {}));
var src_default = AuthService;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  randomId
});
//# sourceMappingURL=index.js.map
