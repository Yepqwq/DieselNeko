var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Client: () => Client,
  Console: () => Console,
  DataService: () => DataService,
  Entry: () => Entry,
  EntryProvider: () => EntryProvider,
  default: () => src_default
});
module.exports = __toCommonJS(src_exports);
var import_koishi3 = require("koishi");

// src/service.ts
var import_koishi = require("koishi");
var DataService = class extends import_koishi.Service {
  constructor(ctx, key, options = {}) {
    super(ctx, `console.services.${key}`, options.immediate);
    this.ctx = ctx;
    this.key = key;
    this.options = options;
  }
  static {
    __name(this, "DataService");
  }
  static filter = false;
  static inject = ["console"];
  async get(forced, client) {
    return null;
  }
  start() {
    this.refresh();
  }
  async refresh(forced = true) {
    this.ctx.get("console")?.broadcast("data", async (client) => ({
      key: this.key,
      value: await this.get(forced, client)
    }), this.options);
  }
  patch(value) {
    this.ctx.get("console")?.broadcast("patch", {
      key: this.key,
      value
    }, this.options);
  }
};

// src/schema.ts
var SchemaProvider = class extends DataService {
  static {
    __name(this, "SchemaProvider");
  }
  constructor(ctx) {
    super(ctx, "schema", { immediate: true });
    ctx.on("internal/schema", () => this.refresh());
  }
  async get() {
    return this.ctx.schema._data;
  }
};

// src/permission.ts
var PermissionProvider = class extends DataService {
  static {
    __name(this, "PermissionProvider");
  }
  constructor(ctx) {
    super(ctx, "permissions", { immediate: true });
    ctx.on("internal/permission", () => this.refresh());
  }
  async get() {
    return this.ctx.permissions.list();
  }
};

// src/client.ts
var import_koishi2 = require("koishi");
var logger = new import_koishi2.Logger("console");
var Client = class {
  constructor(ctx, socket, request) {
    this.ctx = ctx;
    this.socket = socket;
    this.request = request;
    socket.addEventListener("message", this.receive);
    ctx.on("dispose", () => {
      socket.removeEventListener("message", this.receive);
    });
    this.refresh();
  }
  static {
    __name(this, "Client");
  }
  id = import_koishi2.Random.id();
  send(payload) {
    this.socket.send(JSON.stringify(payload));
  }
  receive = async (data) => {
    const { type, args, id } = JSON.parse(data.data.toString());
    const listener = this.ctx.get("console").listeners[type];
    if (!listener) {
      logger.info("unknown message:", type, ...args);
      return this.send({ type: "response", body: { id, error: "not implemented" } });
    }
    if (await this.ctx.serial("console/intercept", this, listener)) {
      return this.send({ type: "response", body: { id, error: "unauthorized" } });
    }
    try {
      const value = await listener.callback.call(this, ...args);
      return this.send({ type: "response", body: { id, value } });
    } catch (e) {
      logger.debug(e);
      const error = (0, import_koishi2.coerce)(e);
      return this.send({ type: "response", body: { id, error } });
    }
  };
  refresh() {
    Object.keys(this.ctx.root[import_koishi2.Context.internal]).forEach(async (name) => {
      if (!name.startsWith("console.services."))
        return;
      const key = name.slice(17);
      const service = this.ctx.get(name);
      if (!service)
        return;
      if (await this.ctx.serial("console/intercept", this, service.options)) {
        return this.send({ type: "data", body: { key, value: null } });
      }
      try {
        const value = await service.get(false, this);
        if (!value)
          return;
        this.send({ type: "data", body: { key, value } });
      } catch (error) {
        logger.warn(error);
      }
    });
  }
};

// src/entry.ts
var Entry = class {
  constructor(ctx, files, data) {
    this.ctx = ctx;
    this.files = files;
    this.data = data;
    ctx.console.entries[this.id] = this;
    ctx.console.refresh("entry");
    this.dispose = ctx.collect("entry", () => {
      delete this.ctx.console.entries[this.id];
      ctx.console.refresh("entry");
    });
  }
  static {
    __name(this, "Entry");
  }
  id = Math.random().toString(36).slice(2);
  dispose;
  refresh() {
    this.ctx.console.broadcast("entry-data", async (client) => ({
      id: this.id,
      data: await this.data(client)
    }));
  }
};

// src/index.ts
var EntryProvider = class extends DataService {
  static {
    __name(this, "EntryProvider");
  }
  static inject = [];
  constructor(ctx) {
    super(ctx, "entry", { immediate: true });
  }
  async get(forced, client) {
    return this.ctx.get("console").get(client);
  }
};
var Console = class extends import_koishi3.Service {
  constructor(ctx) {
    super(ctx, "console", true);
    this.ctx = ctx;
    ctx.plugin(EntryProvider);
    ctx.plugin(SchemaProvider);
    ctx.plugin(PermissionProvider);
    this.addListener("ping", () => "pong");
  }
  static {
    __name(this, "Console");
  }
  static filter = false;
  id = Math.random().toString(36).slice(2);
  entries = /* @__PURE__ */ Object.create(null);
  listeners = /* @__PURE__ */ Object.create(null);
  clients = /* @__PURE__ */ Object.create(null);
  services = new Proxy({}, {
    get: (target, key, receiver) => {
      if (typeof key === "symbol")
        return Reflect.get(target, key, receiver);
      return this.ctx.get(`console.services.${key}`);
    },
    set: (target, key, value, receiver) => {
      return false;
    }
  });
  accept(socket, request) {
    const client = new Client(this.ctx, socket, request);
    socket.addEventListener("close", () => {
      delete this.clients[client.id];
      this.ctx.emit("console/connection", client);
    });
    this.clients[client.id] = client;
    this.ctx.emit("console/connection", client);
  }
  async get(client) {
    const result = (0, import_koishi3.valueMap)(this.entries, ({ files, ctx, data }, key) => ({
      files: this.resolveEntry(files, key),
      paths: this.ctx.get("loader")?.paths(ctx.scope),
      data: data?.(client)
    }));
    result["_id"] = this.id;
    return result;
  }
  addEntry(files, data) {
    return new Entry(this[import_koishi3.Context.current], files, data);
  }
  addListener(event, callback, options) {
    this.listeners[event] = { callback, ...options };
  }
  async broadcast(type, body, options = {}) {
    const handles = Object.values(this.clients);
    if (!handles.length)
      return;
    await Promise.all(Object.values(this.clients).map(async (client) => {
      if (await this.ctx.serial("console/intercept", client, options))
        return;
      const data = { type, body };
      if (typeof body === "function")
        data.body = await body(client);
      client.socket.send(JSON.stringify(data));
    }));
  }
  refresh(type) {
    return this.ctx.get(`console.services.${type}`)?.refresh();
  }
  patch(type, value) {
    return this.ctx.get(`console.services.${type}`)?.patch(value);
  }
};
var src_default = Console;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Client,
  Console,
  DataService,
  Entry,
  EntryProvider
});
//# sourceMappingURL=index.js.map
