var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// external/webui/plugins/analytics/src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => src_default
});
module.exports = __toCommonJS(src_exports);
var import_koishi = require("koishi");
var import_console = require("@koishijs/console");
var import_path = require("path");
var logger = new import_koishi.Logger("analytics");
var _Analytics = class _Analytics extends import_console.DataService {
  constructor(ctx, config = {}) {
    super(ctx, "analytics");
    this.config = config;
    ctx.model.extend("analytics.message", {
      date: "integer",
      hour: "integer",
      type: "string(63)",
      selfId: "string(63)",
      platform: "string(63)",
      count: "integer"
    }, {
      primary: ["date", "hour", "type", "selfId", "platform"]
    });
    ctx.model.extend("analytics.command", {
      date: "integer",
      hour: "integer",
      name: "string(63)",
      selfId: "string(63)",
      userId: "integer",
      channelId: "string(63)",
      platform: "string(63)",
      count: "integer"
    }, {
      primary: ["date", "hour", "name", "selfId", "userId", "channelId", "platform"]
    });
    ctx.on("exit", () => this.upload(true));
    ctx.on("dispose", async () => {
      await this.upload(true);
    });
    ctx.on("message", (session) => {
      this.addAudit(this.messages, {
        ...this.createIndex(session),
        type: "receive"
      });
      this.upload();
    });
    ctx.on("send", (session) => {
      this.addAudit(this.messages, {
        ...this.createIndex(session),
        type: "send"
      });
      this.upload();
    });
    ctx.any().before("command/execute", ({ command, session }) => {
      this.addAudit(this.commands, {
        ...this.createIndex(session),
        name: command.name,
        userId: session.user["id"] || 0,
        channelId: session.channelId
      });
      this.upload();
    });
    ctx.console.addEntry({
      dev: (0, import_path.resolve)(__dirname, "../client/index.ts"),
      prod: (0, import_path.resolve)(__dirname, "../dist")
    });
  }
  lastUpdate = /* @__PURE__ */ new Date();
  updateHour = this.lastUpdate.getHours();
  cachedDate;
  cachedData;
  messages = [];
  commands = [];
  createIndex(session) {
    return {
      selfId: session.selfId,
      platform: session.platform,
      date: import_koishi.Time.getDateNumber(),
      hour: (/* @__PURE__ */ new Date()).getHours()
    };
  }
  addAudit(buffer, index) {
    const audit = buffer.find((data) => (0, import_koishi.deepEqual)((0, import_koishi.pick)(data, Object.keys(index)), index));
    if (audit) {
      audit.count += 1;
    } else {
      buffer.push({ ...index, count: 1 });
    }
  }
  async uploadAudit(table, buffer) {
    if (!buffer.length)
      return;
    await this.ctx.database.upsert(table, (row) => buffer.map((audit) => ({
      ...audit,
      count: import_koishi.$.add(import_koishi.$.ifNull(row.count, 0), audit.count)
    })));
    buffer.splice(0);
  }
  async upload(forced = false) {
    const date = /* @__PURE__ */ new Date();
    const dateHour = date.getHours();
    if (forced || +date - +this.lastUpdate > this.config.statsInternal || dateHour !== this.updateHour) {
      this.lastUpdate = date;
      this.updateHour = dateHour;
      await Promise.all([
        this.uploadAudit("analytics.message", this.messages),
        this.uploadAudit("analytics.command", this.commands)
      ]);
      logger.debug("analytics updated");
    }
  }
  queryRecent() {
    return {
      $gte: import_koishi.Time.getDateNumber() - this.config.recentDayCount,
      $lt: import_koishi.Time.getDateNumber()
    };
  }
  async getCommandRate(lengthTask) {
    const data = await this.ctx.database.select("analytics.command", {
      date: this.queryRecent()
    }).groupBy(["name"], {
      count: (row) => import_koishi.$.sum(row.count)
    }).execute();
    const length = await lengthTask;
    const result = {};
    data.forEach((stat) => {
      result[stat.name] = stat.count / length;
    });
    return result;
  }
  async getDauHistory() {
    const data = await this.ctx.database.select("analytics.command", {
      date: { $gte: import_koishi.Time.getDateNumber() - this.config.recentDayCount },
      userId: { $gt: 0 }
    }).groupBy(["date"], {
      count: (row) => import_koishi.$.count(row.userId)
    }).execute();
    const result = new Array(this.config.recentDayCount + 1).fill(0);
    const today = import_koishi.Time.getDateNumber();
    data.forEach((stat) => {
      result[today - stat.date] = stat.count;
    });
    return result;
  }
  async getMessageByBot(lengthTask) {
    const data = await this.ctx.database.select("analytics.message", {
      date: this.queryRecent()
    }).groupBy(["type", "platform", "selfId"], {
      count: (row) => import_koishi.$.sum(row.count)
    }).execute();
    const length = await lengthTask;
    const result = {};
    data.forEach((stat) => {
      var _a, _b, _c, _d;
      const entry = (_c = result[_a = stat.platform] || (result[_a] = {}))[_d = stat.selfId] || (_c[_d] = {
        ...(_b = this.ctx.bots[`${stat.platform}:${stat.selfId}`]) == null ? void 0 : _b.user,
        send: 0,
        receive: 0
      });
      entry[stat.type] = stat.count / length;
    });
    return result;
  }
  async getMessageByDate() {
    const data = await this.ctx.database.select("analytics.message", {
      date: { $lt: import_koishi.Time.getDateNumber() }
    }).groupBy(["type", "date"], {
      count: (row) => import_koishi.$.sum(row.count)
    }).orderBy("date", "desc").execute();
    const today = import_koishi.Time.getDateNumber();
    const result = [];
    data.forEach((stat) => {
      var _a;
      const entry = result[_a = today - stat.date] || (result[_a] = { send: 0, receive: 0 });
      entry[stat.type] = stat.count;
    });
    for (let i = 0; i < result.length; i++) {
      result[i] || (result[i] = { send: 0, receive: 0 });
    }
    return result;
  }
  async getMessageByHour(lengthTask) {
    const data = await this.ctx.database.select("analytics.message", {
      date: this.queryRecent()
    }).groupBy(["type", "hour"], {
      count: (row) => import_koishi.$.sum(row.count)
    }).execute();
    const length = await lengthTask;
    const result = new Array(24).fill(null).map(() => ({ send: 0, receive: 0 }));
    data.forEach((stat) => {
      result[stat.hour][stat.type] = stat.count / length;
    });
    return result;
  }
  async download() {
    const messageByDateTask = this.getMessageByDate();
    const lengthTask = messageByDateTask.then((data) => {
      return Math.min(Math.max(data.length - 1, 1), this.config.recentDayCount);
    });
    const [
      userCount,
      userIncrement,
      guildCount,
      guildIncrement,
      commandRate,
      dauHistory,
      messageByBot,
      messageByDate,
      messageByHour
    ] = await Promise.all([
      this.ctx.database.eval("user", (row) => import_koishi.$.count(row.id)),
      this.ctx.database.eval("user", (row) => import_koishi.$.count(row.id), {
        createdAt: {
          $gte: import_koishi.Time.fromDateNumber(import_koishi.Time.getDateNumber() - 1),
          $lt: import_koishi.Time.fromDateNumber(import_koishi.Time.getDateNumber())
        }
      }),
      this.ctx.database.eval("channel", (row) => import_koishi.$.sum(1), (row) => import_koishi.$.eq(row.id, row.guildId)),
      this.ctx.database.eval("channel", (row) => import_koishi.$.sum(1), (row) => import_koishi.$.and(
        import_koishi.$.eq(row.id, row.guildId),
        import_koishi.$.gte(row.createdAt, import_koishi.Time.fromDateNumber(import_koishi.Time.getDateNumber() - 1)),
        import_koishi.$.lt(row.createdAt, import_koishi.Time.fromDateNumber(import_koishi.Time.getDateNumber()))
      )),
      this.getCommandRate(lengthTask),
      this.getDauHistory(),
      this.getMessageByBot(lengthTask),
      messageByDateTask,
      this.getMessageByHour(lengthTask)
    ]);
    return {
      userCount,
      userIncrement,
      guildCount,
      guildIncrement,
      commandRate,
      dauHistory,
      messageByBot,
      messageByDate,
      messageByHour
    };
  }
  async get() {
    const date = /* @__PURE__ */ new Date();
    const dateNumber = import_koishi.Time.getDateNumber(date, date.getTimezoneOffset());
    if (dateNumber !== this.cachedDate) {
      this.cachedData = this.download();
      this.cachedDate = dateNumber;
    }
    return this.cachedData;
  }
};
__name(_Analytics, "Analytics");
__publicField(_Analytics, "inject", ["database", "console"]);
var Analytics = _Analytics;
((Analytics2) => {
  Analytics2.Config = import_koishi.Schema.object({
    statsInternal: import_koishi.Schema.natural().role("ms").description("统计数据推送的时间间隔。").default(import_koishi.Time.minute * 10),
    recentDayCount: import_koishi.Schema.natural().description("统计最近几天的数据。").default(7)
  });
})(Analytics || (Analytics = {}));
var src_default = Analytics;
//# sourceMappingURL=index.js.map
