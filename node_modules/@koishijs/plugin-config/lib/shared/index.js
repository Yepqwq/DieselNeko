var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/shared/index.ts
var shared_exports = {};
__export(shared_exports, {
  ConfigWriter: () => ConfigWriter,
  PackageProvider: () => PackageProvider,
  ServiceProvider: () => ServiceProvider
});
module.exports = __toCommonJS(shared_exports);

// src/shared/packages.ts
var import_koishi = require("koishi");
var import_console = require("@koishijs/console");
var logger = new import_koishi.Logger("config");
var PackageProvider = class extends import_console.DataService {
  constructor(ctx) {
    super(ctx, "packages", { authority: 4 });
    this.ctx = ctx;
    this.debouncedRefresh = ctx.debounce(() => this.refresh(false), 0);
    ctx.on("internal/runtime", (scope) => this.update(scope.runtime.plugin));
    ctx.on("internal/fork", (scope) => this.update(scope.runtime.plugin));
    ctx.on("internal/status", (scope) => this.update(scope.runtime.plugin));
    ctx.on("hmr/reload", (reloads) => {
      for (const [plugin] of reloads) {
        this.update(plugin);
      }
    });
    ctx.console.addListener("config/request-runtime", async (name) => {
      name = name.replace(/(koishi-|^@koishijs\/)plugin-/, "");
      this.cache[name] = await this.parseExports(name);
      this.refresh(false);
    }, { authority: 4 });
  }
  static {
    __name(this, "PackageProvider");
  }
  cache = {};
  debouncedRefresh;
  async update(plugin) {
    const name = this.ctx.loader.keyFor(plugin);
    if (!this.cache[name])
      return;
    this.cache[name] = await this.parseExports(name);
    this.debouncedRefresh();
  }
  parseRuntime(state, result) {
    result.id = state.runtime.uid;
    result.forkable = state.runtime.isForkable;
    result.forks = Object.fromEntries(state.children.filter((fork) => fork.key).map((fork) => [fork.key, { status: fork.status }]));
  }
  async get(forced = false) {
    const objects = (await this.collect(forced)).slice();
    for (const object of objects) {
      object.name = object.package?.name || "";
      if (!this.cache[object.shortname])
        continue;
      object.runtime = this.cache[object.shortname];
    }
    objects.unshift({
      name: "",
      runtime: {
        schema: import_koishi.Context.Config
      },
      package: { name: "" }
    });
    return Object.fromEntries(objects.map((data) => [data.name, data]));
  }
  async parseExports(name) {
    try {
      const exports = await this.ctx.loader.resolve(name);
      const result = {};
      result.schema = exports?.Config || exports?.schema;
      result.usage = exports?.usage;
      result.filter = exports?.filter;
      const inject = exports?.using || exports?.inject || [];
      if (Array.isArray(inject)) {
        result.required = inject;
        result.optional = [];
      } else {
        result.required = inject.required || [];
        result.optional = inject.optional || [];
      }
      JSON.stringify(result);
      const runtime = this.ctx.registry.get(exports);
      if (runtime)
        this.parseRuntime(runtime, result);
      return result;
    } catch (error) {
      logger.warn("failed to load %c", name);
      logger.warn(error);
      return { failed: true };
    }
  }
};

// src/shared/services.ts
var import_console2 = require("@koishijs/console");
var import_koishi2 = require("koishi");
var ServiceProvider = class extends import_console2.DataService {
  static {
    __name(this, "ServiceProvider");
  }
  constructor(ctx) {
    super(ctx, "services");
    ctx.on("internal/service", () => this.refresh());
  }
  async get() {
    const services = {};
    const attach = /* @__PURE__ */ __name((internal) => {
      if (!internal)
        return;
      attach(Object.getPrototypeOf(internal));
      for (const [key, { type }] of Object.entries(internal)) {
        if (type !== "service")
          continue;
        const instance = this.ctx.get(key);
        if (!(instance instanceof Object))
          continue;
        const ctx = Reflect.getOwnPropertyDescriptor(instance, import_koishi2.Context.current)?.value;
        if (!ctx)
          continue;
        const name = key.replace(/^__/, "").replace(/__$/, "");
        services[name] = ctx.scope.uid;
      }
    }, "attach");
    attach(this.ctx.root[import_koishi2.Context.internal]);
    return services;
  }
};

// src/shared/writer.ts
var import_console3 = require("@koishijs/console");
var import_koishi3 = require("koishi");
var import_loader = require("@koishijs/loader");
var logger2 = new import_koishi3.Logger("loader");
function insertKey(object, temp, rest) {
  for (const key of rest) {
    temp[key] = object[key];
    delete object[key];
  }
  Object.assign(object, temp);
}
__name(insertKey, "insertKey");
function rename(object, old, neo, value) {
  const keys = Object.keys(object);
  const index = keys.findIndex((key) => key === old || key === "~" + old);
  const rest = index < 0 ? [] : keys.slice(index + 1);
  const temp = { [neo]: value };
  delete object[old];
  delete object["~" + old];
  insertKey(object, temp, rest);
}
__name(rename, "rename");
function dropKey(plugins, name) {
  if (!(name in plugins)) {
    name = "~" + name;
  }
  const value = plugins[name];
  delete plugins[name];
  return { [name]: value };
}
__name(dropKey, "dropKey");
var ConfigWriter = class extends import_console3.DataService {
  static {
    __name(this, "ConfigWriter");
  }
  loader;
  constructor(ctx) {
    super(ctx, "config", { authority: 4 });
    this.loader = ctx.loader;
    ctx.console.addListener("manager/app-reload", (config) => {
      return this.reloadApp(config);
    }, { authority: 4 });
    for (const key of ["teleport", "reload", "unload", "remove", "meta"]) {
      ctx.console.addListener(`manager/${key}`, async (...args) => {
        try {
          await this[key].apply(this, args);
        } catch (error) {
          logger2.error(error);
          throw new Error("failed");
        }
      }, { authority: 4 });
    }
    ctx.on("config", () => this.refresh());
  }
  getGroup(plugins, ctx) {
    const result = { ...plugins };
    for (const key in plugins) {
      if (key.startsWith("$"))
        continue;
      const value = plugins[key];
      const name = key.split(":", 1)[0].replace(/^~/, "");
      if (!this.loader.isTruthyLike(value?.$if)) {
        delete result[key];
        continue;
      }
      const fork = ctx.scope[import_loader.Loader.kRecord][key];
      if (!fork)
        continue;
      if (name === "group") {
        result[key] = this.getGroup(value, fork.ctx);
      }
    }
    return result;
  }
  async get() {
    const result = { ...this.loader.config };
    result.plugins = this.getGroup(result.plugins, this.loader.entry);
    return result;
  }
  async reloadApp(config) {
    delete config.$paths;
    const plugins = this.loader.config.plugins;
    this.loader.config = config;
    this.loader.config.plugins = plugins;
    await this.loader.writeConfig();
    this.loader.fullReload();
  }
  resolveFork(ident) {
    if (!ident)
      return this.loader.entry.scope;
    for (const main of this.ctx.registry.values()) {
      for (const fork of main.children) {
        if (fork.key === ident)
          return fork;
      }
    }
  }
  resolveConfig(ident, config = this.loader.config.plugins) {
    for (const key in config) {
      const [name] = key.split(":", 1);
      if (key.slice(name.length + 1) === ident)
        return [config, key];
      if (name === "group" || name === "~group") {
        try {
          return this.resolveConfig(ident, config[key]);
        } catch {
        }
      }
    }
    throw new Error("plugin not found");
  }
  async meta(ident, config) {
    const [parent, key] = this.resolveConfig(ident);
    const target = parent[key];
    for (const key2 of Object.keys(config)) {
      delete target[key2];
      if (config[key2] === null) {
        delete config[key2];
      }
    }
    insertKey(target, config, Object.keys(target));
    await this.loader.writeConfig(true);
  }
  async reload(parent, key, config) {
    const scope = this.resolveFork(parent);
    await this.loader.reload(scope.ctx, key, config);
    rename(scope.config, key, key, config);
    await this.loader.writeConfig();
  }
  async unload(parent, key, config = {}, index) {
    const scope = this.resolveFork(parent);
    this.loader.unload(scope.ctx, key);
    if (index) {
      const rest = Object.keys(scope.config).slice(index);
      insertKey(scope.config, { ["~" + key]: config }, rest);
    } else {
      rename(scope.config, key, "~" + key, config);
    }
    await this.loader.writeConfig();
  }
  async remove(parent, key) {
    const scope = this.resolveFork(parent);
    this.loader.unload(scope.ctx, key);
    delete scope.config[key];
    delete scope.config["~" + key];
    await this.loader.writeConfig();
  }
  async teleport(source, key, target, index) {
    const parentS = this.resolveFork(source);
    const parentT = this.resolveFork(target);
    const fork = parentS?.[import_loader.Loader.kRecord]?.[key];
    if (fork && parentS !== parentT) {
      delete parentS[import_loader.Loader.kRecord][key];
      parentT[import_loader.Loader.kRecord][key] = fork;
      (0, import_koishi3.remove)(parentS.disposables, fork.dispose);
      parentT.disposables.push(fork.dispose);
      fork.parent = parentT.ctx;
      Object.setPrototypeOf(fork.ctx, parentT.ctx);
      fork.ctx.emit("internal/fork", fork);
      if (fork.runtime.using.some((name) => parentS[name] !== parentT[name])) {
        fork.restart();
      }
    }
    const temp = dropKey(parentS.config, key);
    const rest = Object.keys(parentT.config).slice(index);
    insertKey(parentT.config, temp, rest);
    await this.loader.writeConfig();
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ConfigWriter,
  PackageProvider,
  ServiceProvider
});
//# sourceMappingURL=index.js.map
