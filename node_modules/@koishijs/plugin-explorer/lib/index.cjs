var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => src_default
});
module.exports = __toCommonJS(src_exports);
var import_koishi = require("koishi");
var import_console = require("@koishijs/console");
var import_path = require("path");
var import_promises = require("fs/promises");
var import_chardet = require("chardet");
var import_file_type = __toESM(require("file-type"));
var import_anymatch = __toESM(require("anymatch"));

// src/locales/zh-CN.yml
var zh_CN_default = { root: "资源管理器的根目录，默认为当前工作路径。", ignored: "要忽略的文件或目录。支持 [Glob Patterns](https://github.com/micromatch/micromatch) 语法。" };

// src/index.ts
var import_meta = {};
var Explorer = class extends import_console.DataService {
  static {
    __name(this, "Explorer");
  }
  task;
  watchers = /* @__PURE__ */ Object.create(null);
  globFilter;
  root;
  constructor(ctx, config) {
    super(ctx, "explorer", { authority: 4 });
    ctx.console.addEntry(process.env.KOISHI_BASE ? [
      process.env.KOISHI_BASE + "/dist/index.js",
      process.env.KOISHI_BASE + "/dist/style.css"
    ] : process.env.KOISHI_ENV === "browser" ? [
      // @ts-ignore
      import_meta.url.replace(/\/src\/[^/]+$/, "/client/index.ts")
    ] : {
      dev: (0, import_path.resolve)(__dirname, "../client/index.ts"),
      prod: (0, import_path.resolve)(__dirname, "../dist")
    });
    this.globFilter = (0, import_anymatch.default)(config.ignored);
    this.root = (0, import_path.resolve)(ctx.baseDir, config.root);
    ctx.console.addListener("explorer/read", async (filename, binary) => {
      filename = (0, import_path.join)(this.root, filename);
      const buffer = await (0, import_promises.readFile)(filename);
      const result = await import_file_type.default.fromBuffer(buffer);
      return {
        base64: buffer.toString("base64"),
        mime: result?.mime,
        encoding: (0, import_chardet.detect)(buffer)
      };
    }, { authority: 4 });
    ctx.console.addListener("explorer/write", async (filename, content, binary) => {
      filename = (0, import_path.join)(this.root, filename);
      if (binary) {
        const buffer = Buffer.from(content, "base64");
        await (0, import_promises.writeFile)(filename, buffer);
      } else {
        await (0, import_promises.writeFile)(filename, content, "utf8");
      }
      this.refresh();
    }, { authority: 4 });
    ctx.console.addListener("explorer/mkdir", async (filename) => {
      filename = (0, import_path.join)(this.root, filename);
      await (0, import_promises.mkdir)(filename);
      this.refresh();
    }, { authority: 4 });
    ctx.console.addListener("explorer/remove", async (filename) => {
      filename = (0, import_path.join)(this.root, filename);
      await (0, import_promises.rm)(filename, { recursive: true });
      this.refresh();
    }, { authority: 4 });
    ctx.console.addListener("explorer/rename", async (oldValue, newValue) => {
      oldValue = (0, import_path.join)(this.root, oldValue);
      newValue = (0, import_path.join)(this.root, newValue);
      await (0, import_promises.rename)(oldValue, newValue);
      this.refresh();
    }, { authority: 4 });
    ctx.console.addListener("explorer/refresh", () => {
      this.refresh();
    }, { authority: 4 });
  }
  stop() {
    for (const watcher of Object.values(this.watchers)) {
      watcher.close();
    }
  }
  async traverse(root) {
    const dirents = await (0, import_promises.readdir)(root, { withFileTypes: true });
    return Promise.all(dirents.map(async (dirent) => {
      const filename = (0, import_path.join)(root, dirent.name);
      if (this.globFilter((0, import_path.relative)(this.root, filename)))
        return;
      if (dirent.isFile()) {
        return { type: "file", name: dirent.name };
      } else if (dirent.isDirectory()) {
        return { type: "directory", name: dirent.name, children: await this.traverse(filename) };
      } else if (dirent.isSymbolicLink()) {
        return { type: "symlink", name: dirent.name, target: await (0, import_promises.readlink)(filename) };
      }
    })).then((entries) => entries.filter(Boolean).sort((a, b) => {
      if (a.type !== b.type)
        return a.type === "directory" ? -1 : 1;
      return a.name.localeCompare(b.name);
    }));
  }
  async _get() {
    return this.traverse(this.root);
  }
  async get(forced = false) {
    if (!forced && this.task)
      return this.task;
    return this.task = this._get();
  }
};
((Explorer2) => {
  Explorer2.Config = import_koishi.Schema.object({
    root: import_koishi.Schema.string().default(""),
    ignored: import_koishi.Schema.array(String).role("table").default(["**/node_modules", "**/.*", "cache"])
  }).i18n({
    "zh-CN": zh_CN_default
  });
})(Explorer || (Explorer = {}));
var src_default = Explorer;
//# sourceMappingURL=index.cjs.map
