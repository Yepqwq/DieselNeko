var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// src/index.ts
import { Schema } from "koishi";
import { DataService } from "@koishijs/console";
import { join, relative, resolve } from "path";
import { mkdir, readdir, readFile, readlink, rename, rm, writeFile } from "fs/promises";
import { detect } from "chardet";
import FileType from "file-type";
import anymatch from "anymatch";

// src/locales/zh-CN.yml
var zh_CN_default = { root: "资源管理器的根目录，默认为当前工作路径。", ignored: "要忽略的文件或目录。支持 [Glob Patterns](https://github.com/micromatch/micromatch) 语法。" };

// src/index.ts
var Explorer = class extends DataService {
  static {
    __name(this, "Explorer");
  }
  task;
  watchers = /* @__PURE__ */ Object.create(null);
  globFilter;
  root;
  constructor(ctx, config) {
    super(ctx, "explorer", { authority: 4 });
    ctx.console.addEntry(process.env.KOISHI_BASE ? [
      process.env.KOISHI_BASE + "/dist/index.js",
      process.env.KOISHI_BASE + "/dist/style.css"
    ] : process.env.KOISHI_ENV === "browser" ? [
      // @ts-ignore
      import.meta.url.replace(/\/src\/[^/]+$/, "/client/index.ts")
    ] : {
      dev: resolve(__dirname, "../client/index.ts"),
      prod: resolve(__dirname, "../dist")
    });
    this.globFilter = anymatch(config.ignored);
    this.root = resolve(ctx.baseDir, config.root);
    ctx.console.addListener("explorer/read", async (filename, binary) => {
      filename = join(this.root, filename);
      const buffer = await readFile(filename);
      const result = await FileType.fromBuffer(buffer);
      return {
        base64: buffer.toString("base64"),
        mime: result?.mime,
        encoding: detect(buffer)
      };
    }, { authority: 4 });
    ctx.console.addListener("explorer/write", async (filename, content, binary) => {
      filename = join(this.root, filename);
      if (binary) {
        const buffer = Buffer.from(content, "base64");
        await writeFile(filename, buffer);
      } else {
        await writeFile(filename, content, "utf8");
      }
      this.refresh();
    }, { authority: 4 });
    ctx.console.addListener("explorer/mkdir", async (filename) => {
      filename = join(this.root, filename);
      await mkdir(filename);
      this.refresh();
    }, { authority: 4 });
    ctx.console.addListener("explorer/remove", async (filename) => {
      filename = join(this.root, filename);
      await rm(filename, { recursive: true });
      this.refresh();
    }, { authority: 4 });
    ctx.console.addListener("explorer/rename", async (oldValue, newValue) => {
      oldValue = join(this.root, oldValue);
      newValue = join(this.root, newValue);
      await rename(oldValue, newValue);
      this.refresh();
    }, { authority: 4 });
    ctx.console.addListener("explorer/refresh", () => {
      this.refresh();
    }, { authority: 4 });
  }
  stop() {
    for (const watcher of Object.values(this.watchers)) {
      watcher.close();
    }
  }
  async traverse(root) {
    const dirents = await readdir(root, { withFileTypes: true });
    return Promise.all(dirents.map(async (dirent) => {
      const filename = join(root, dirent.name);
      if (this.globFilter(relative(this.root, filename)))
        return;
      if (dirent.isFile()) {
        return { type: "file", name: dirent.name };
      } else if (dirent.isDirectory()) {
        return { type: "directory", name: dirent.name, children: await this.traverse(filename) };
      } else if (dirent.isSymbolicLink()) {
        return { type: "symlink", name: dirent.name, target: await readlink(filename) };
      }
    })).then((entries) => entries.filter(Boolean).sort((a, b) => {
      if (a.type !== b.type)
        return a.type === "directory" ? -1 : 1;
      return a.name.localeCompare(b.name);
    }));
  }
  async _get() {
    return this.traverse(this.root);
  }
  async get(forced = false) {
    if (!forced && this.task)
      return this.task;
    return this.task = this._get();
  }
};
((Explorer2) => {
  Explorer2.Config = Schema.object({
    root: Schema.string().default(""),
    ignored: Schema.array(String).role("table").default(["**/node_modules", "**/.*", "cache"])
  }).i18n({
    "zh-CN": zh_CN_default
  });
})(Explorer || (Explorer = {}));
var src_default = Explorer;
export {
  src_default as default
};
//# sourceMappingURL=index.mjs.map
