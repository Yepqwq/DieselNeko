var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// external/webui/plugins/status/src/index.ts
var src_exports = {};
__export(src_exports, {
  Config: () => Config,
  EnvInfoProvider: () => envinfo_default,
  ProfileProvider: () => profile_default,
  apply: () => apply,
  inject: () => inject,
  name: () => name
});
module.exports = __toCommonJS(src_exports);
var import_koishi3 = require("koishi");
var import_path = require("path");

// external/webui/plugins/status/src/envinfo.ts
var import_koishi = require("koishi");
var import_console = require("@koishijs/console");
var import_promises = require("fs/promises");
var import_envinfo = require("envinfo");
var import_which_pm_runs = __toESM(require("which-pm-runs"));
var _EnvInfoProvider = class _EnvInfoProvider extends import_console.DataService {
  constructor(ctx, config) {
    super(ctx, "envinfo");
    this.config = config;
  }
  task;
  async _get() {
    const [[, OS], [, CPU]] = await Promise.all([
      import_envinfo.helpers.getOSInfo(),
      import_envinfo.helpers.getCPUInfo()
    ]);
    const agent = (0, import_which_pm_runs.default)();
    const system = { OS, CPU };
    const binaries = {
      Node: process.versions.node
    };
    if (agent) {
      if (agent.name === "yarn") {
        agent.name = "Yarn";
      }
      binaries[agent.name] = agent.version;
    }
    const metapath = require.resolve("@koishijs/console/package.json");
    const meta = await (0, import_promises.readFile)(metapath, "utf8").then(JSON.parse);
    const koishi = {
      Core: import_koishi.version,
      Console: meta.version
    };
    if (process.env.KOISHI_AGENT) {
      const [name2, version2] = process.env.KOISHI_AGENT.split("/");
      koishi[name2] = version2;
    }
    return { system, binaries, koishi };
  }
  async get() {
    if (!this.task)
      this.task = this._get();
    return this.task;
  }
};
__name(_EnvInfoProvider, "EnvInfoProvider");
var EnvInfoProvider = _EnvInfoProvider;
((EnvInfoProvider2) => {
  EnvInfoProvider2.Config = import_koishi.Schema.object({});
})(EnvInfoProvider || (EnvInfoProvider = {}));
var envinfo_default = EnvInfoProvider;

// external/webui/plugins/status/src/profile.ts
var import_koishi2 = require("koishi");
var import_os = require("os");
var import_console2 = require("@koishijs/console");

// external/webui/plugins/status/src/locales/zh-CN.yml
var zh_CN_default = { commands: { status: { description: "查看运行状态", messages: { status: { "0": "离线", "1": "运行中", "2": "正在连接", "3": "正在断开", "4": "正在重连" }, bot: '<p>[{platform}] {user.name}：<i18n path={"commands.status.messages.status." + status}/></p>', epilog: "==========\nCPU 使用率：{ (cpu[0] * 100).toFixed() }% / { (cpu[1] * 100).toFixed() }%\n内存使用率：{ (memory[0] * 100).toFixed() }% / { (memory[1] * 100).toFixed() }%" } } } };

// external/webui/plugins/status/src/profile.ts
var _TickCounter = class _TickCounter {
  stop;
  data = new Array(60).fill(0);
  tick = () => {
    this.data.unshift(0);
    this.data.splice(-1, 1);
  };
  constructor(ctx) {
    this.stop = ctx.setInterval(() => this.tick(), import_koishi2.Time.second);
  }
  add(value = 1) {
    this.data[0] += value;
  }
  get() {
    return this.data.reduce((prev, curr) => prev + curr, 0);
  }
  static initialize(bot, ctx) {
    bot._messageSent = new _TickCounter(ctx);
    bot._messageReceived = new _TickCounter(ctx);
  }
};
__name(_TickCounter, "TickCounter");
var TickCounter = _TickCounter;
var usage = getCpuUsage();
var appRate;
var usedRate;
async function memoryRate() {
  const total = (0, import_os.totalmem)();
  return [process.memoryUsage().rss / total, 1 - (0, import_os.freemem)() / total];
}
__name(memoryRate, "memoryRate");
function getCpuUsage() {
  let totalIdle = 0, totalTick = 0;
  const cpuInfo = (0, import_os.cpus)();
  const usage2 = process.cpuUsage().user;
  for (const cpu of cpuInfo) {
    for (const type in cpu.times) {
      totalTick += cpu.times[type];
    }
    totalIdle += cpu.times.idle;
  }
  return {
    // microsecond values
    app: usage2 / 1e3,
    used: totalTick - totalIdle,
    total: totalTick
  };
}
__name(getCpuUsage, "getCpuUsage");
function updateCpuUsage() {
  const newUsage = getCpuUsage();
  const totalDifference = newUsage.total - usage.total;
  appRate = (newUsage.app - usage.app) / totalDifference;
  usedRate = (newUsage.used - usage.used) / totalDifference;
  usage = newUsage;
}
__name(updateCpuUsage, "updateCpuUsage");
var _ProfileProvider = class _ProfileProvider extends import_console2.DataService {
  constructor(ctx, config) {
    super(ctx, "status");
    this.config = config;
    ctx.i18n.define("zh-CN", zh_CN_default);
    const { tickInterval } = config;
    ctx.on("ready", () => {
      ctx.setInterval(() => {
        updateCpuUsage();
        this.refresh();
      }, tickInterval);
    });
    ctx.any().before("send", (session) => {
      var _a;
      (_a = session.bot._messageSent) == null ? void 0 : _a.add(1);
    });
    ctx.any().on("message", (session) => {
      var _a;
      (_a = session.bot._messageReceived) == null ? void 0 : _a.add(1);
    });
    ctx.bots.forEach((bot) => TickCounter.initialize(bot, ctx));
    const update = ctx.debounce(() => this.refresh(), 0);
    ctx.on("login-added", ({ bot }) => {
      TickCounter.initialize(bot, ctx);
      update();
    });
    ctx.on("login-removed", ({ bot }) => {
      bot._messageSent.stop();
      bot._messageReceived.stop();
      update();
    });
    ctx.on("login-updated", () => {
      update();
    });
    ctx.command("status").action(async ({ session }) => {
      const data = await this.get();
      const output = Object.values(data.bots).map((bot) => {
        return session.text(".bot", bot);
      });
      output.push(session.text(".epilog", data));
      return output.join("\n");
    });
  }
  cached;
  async get(forced = false) {
    var _a, _b;
    if (this.cached && !forced)
      return this.cached;
    const memory = await memoryRate();
    const cpu = [appRate, usedRate];
    const bots = {};
    for (const bot of this.ctx.bots) {
      if (bot.hidden)
        continue;
      bots[bot.sid] = {
        ...bot.toJSON(),
        paths: (_a = this.ctx.get("loader")) == null ? void 0 : _a.paths(bot.ctx.scope),
        error: (_b = bot.error) == null ? void 0 : _b.message,
        messageSent: bot._messageSent.get(),
        messageReceived: bot._messageReceived.get()
      };
    }
    return { memory, cpu, bots };
  }
};
__name(_ProfileProvider, "ProfileProvider");
var ProfileProvider = _ProfileProvider;
((ProfileProvider2) => {
  ProfileProvider2.Config = import_koishi2.Schema.object({
    tickInterval: import_koishi2.Schema.natural().role("ms").description("性能数据推送的时间间隔。").default(import_koishi2.Time.second * 5)
  });
})(ProfileProvider || (ProfileProvider = {}));
var profile_default = ProfileProvider;

// external/webui/plugins/status/src/index.ts
var name = "status";
var inject = ["console"];
var Config = import_koishi3.Schema.intersect([
  envinfo_default.Config,
  profile_default.Config
]);
function apply(ctx, config) {
  ctx.console.addEntry({
    dev: (0, import_path.resolve)(__dirname, "../client/index.ts"),
    prod: (0, import_path.resolve)(__dirname, "../dist")
  });
  ctx.plugin(envinfo_default, config);
  ctx.plugin(profile_default, config);
}
__name(apply, "apply");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Config,
  EnvInfoProvider,
  ProfileProvider,
  apply,
  inject,
  name
});
//# sourceMappingURL=index.js.map
