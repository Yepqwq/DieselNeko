var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// external/webui/plugins/admin/src/index.ts
var src_exports = {};
__export(src_exports, {
  Admin: () => Admin,
  default: () => src_default
});
module.exports = __toCommonJS(src_exports);
var import_koishi2 = require("koishi");
var import_path = require("path");

// external/webui/plugins/admin/src/command.ts
var import_koishi = require("koishi");
function apply(ctx) {
  function enableAdmin(command) {
    if (!command.config.admin)
      return;
    command[import_koishi.Context.current] = ctx;
    if (command.config.admin.user)
      adminUser(command);
    if (command.config.admin.channel)
      adminChannel(command);
  }
  __name(enableAdmin, "enableAdmin");
  ctx.$commander._commandList.forEach(enableAdmin);
  ctx.on("command-added", enableAdmin);
  ctx.command("user", { authority: 3 });
  ctx.command("channel", { authority: 3 });
  ctx.command("user/authorize <value:natural>", { authority: 4, checkUnknown: true, admin: { user: true, upsert: true } }).alias("auth").userFields(["authority"]).action(async ({ options, session }, authority) => {
    if (!options["user"]) {
      return session.text("admin.user-expected");
    }
    session.user.authority = authority;
  });
  ctx.command("user.locale <lang>", { authority: 1, checkUnknown: true, admin: { user: true } }).userFields(["locales"]).use(adminLocale, "user");
  ctx.command("channel/assign [bot:user]", { authority: 4, checkUnknown: true, admin: { channel: true, upsert: true } }).channelFields(["assignee"]).option("remove", "-r", { descPath: "admin.options.remove" }).action(async ({ session, options }, value) => {
    if (options.remove) {
      session.channel.assignee = "";
    } else if (!value) {
      session.channel.assignee = session.selfId;
    } else {
      const [platform, userId] = parsePlatform(value);
      if (platform !== session.platform) {
        return session.text("admin.invalid-assignee-platform");
      }
      session.channel.assignee = userId;
    }
  });
  ctx.command("channel.locale <lang>", { authority: 3, checkUnknown: true, admin: { channel: true } }).channelFields(["locales"]).use(adminLocale, "channel");
}
__name(apply, "apply");
function parsePlatform(target) {
  const index = target.indexOf(":");
  const platform = target.slice(0, index);
  const id = target.slice(index + 1);
  return [platform, id];
}
__name(parsePlatform, "parsePlatform");
function adminUser(command) {
  let notFound;
  async function setTarget(argv) {
    const { options, session } = argv;
    const { user, app } = session;
    notFound = false;
    if (!options.user)
      return;
    const [platform, userId] = parsePlatform(options.user);
    if (session.userId === userId && session.platform === platform)
      return;
    const fields = session.collect("user", argv);
    const data = await app.database.getUser(platform, userId, [...fields]);
    if (!data) {
      notFound = true;
      const temp = app.model.tables.user.create();
      session.user = (0, import_koishi.observe)(temp, async (diff) => {
        await app.database.createUser(platform, userId, diff);
      }, `user ${options.user}`);
    } else if (user.authority <= data.authority) {
      return session.text("internal.low-authority");
    } else {
      session.user = (0, import_koishi.observe)(data, async (diff) => {
        await app.database.setUser(platform, userId, diff);
      }, `user ${options.user}`);
    }
  }
  __name(setTarget, "setTarget");
  return command.option("user", "-u [user:user]", { authority: 3, descPath: "admin.user-option" }).userFields(["authority"]).action(async (argv, ...args) => {
    const { session, next } = argv;
    const user = session.user;
    const output = await setTarget(argv);
    if (output)
      return output;
    try {
      const diffKeys = Object.keys(session.user.$diff);
      const result = await next();
      if (notFound && !command.config.admin.upsert) {
        return session.text("admin.user-not-found");
      } else if (typeof result === "string") {
        return result;
      } else if (!(0, import_koishi.difference)(Object.keys(session.user.$diff), diffKeys).length) {
        return session.text("admin.user-unchanged");
      } else if (session.user !== user && session.user.authority >= user.authority) {
        return session.text("internal.low-authority");
      }
      await session.user.$update();
      return session.text("admin.user-updated");
    } finally {
      session.user = user;
    }
  }, true);
}
__name(adminUser, "adminUser");
function adminChannel(command) {
  let notFound;
  async function setTarget(argv) {
    const { options, session } = argv;
    const { app } = session;
    notFound = false;
    if (session.isDirect && !options.channel) {
      return session.text("admin.not-in-group");
    }
    const { channel = session.cid } = options;
    if (channel === session.cid && !session.channel["$detached"])
      return;
    const [platform, channelId] = parsePlatform(channel);
    const fields = argv.session.collect("channel", argv);
    const data = await app.database.getChannel(platform, channelId, [...fields]);
    if (!data) {
      notFound = true;
      const temp = app.model.tables.channel.create();
      temp.platform = platform;
      temp.id = channelId;
      session.channel = (0, import_koishi.observe)(temp, async (diff) => {
        await app.database.createChannel(platform, channelId, diff);
      }, `channel ${channel}`);
    } else {
      session.channel = (0, import_koishi.observe)(data, async (diff) => {
        await app.database.setChannel(platform, channelId, diff);
      }, `channel ${channel}`);
    }
  }
  __name(setTarget, "setTarget");
  return command.option("channel", "-c [channel:channel]", { authority: 3, descPath: "admin.channel-option" }).action(async (argv, ...args) => {
    const { session, next } = argv;
    const channel = session.channel;
    const output = await setTarget(argv);
    if (output)
      return output;
    try {
      const diffKeys = Object.keys(session.channel.$diff);
      const result = await next();
      if (notFound && !command.config.admin.upsert) {
        return session.text("admin.channel-not-found");
      } else if (typeof result === "string") {
        return result;
      } else if (!(0, import_koishi.difference)(Object.keys(session.channel.$diff), diffKeys).length) {
        return session.text("admin.channel-unchanged");
      }
      await session.channel.$update();
      return session.text("admin.channel-updated");
    } finally {
      session.channel = channel;
    }
  }, true);
}
__name(adminChannel, "adminChannel");
function adminLocale(cmd, key) {
  return cmd.option("remove", "-r", { descPath: "admin.options.remove" }).action(async ({ session, options }, ...args) => {
    var _a;
    const target = session[key];
    if (options.remove) {
      target.locales = [];
    } else if (args[0]) {
      target.locales = [args[0]];
    } else if ((_a = target.locales) == null ? void 0 : _a.length) {
      return session.text("admin.current-locale", [target.locales.join(", ")]);
    } else {
      return session.text("admin.no-locale");
    }
  });
}
__name(adminLocale, "adminLocale");

// external/webui/plugins/admin/src/locales/zh-CN.yml
var zh_CN_default = { commands: { user: { description: "用户管理" }, channel: { description: "频道管理" }, authorize: { description: "权限管理" }, assign: { description: "受理者账号" }, "user.locale": { description: "语言偏好" }, "channel.locale": { description: "语言偏好" } }, admin: { "user-option": "指定目标用户", "user-not-found": "未找到指定的用户。", "user-unchanged": "用户数据未改动。", "user-updated": "用户数据已修改。", "channel-option": "指定目标频道", "channel-not-found": "未找到指定的频道。", "channel-unchanged": "频道数据未改动。", "channel-updated": "频道数据已修改。", "not-in-group": "当前不在群组上下文中，请使用 -c 参数指定目标频道。", "user-expected": "请指定目标用户。", "channel-expected": "请指定目标频道。", "invalid-assignee-platform": "受理人应与目标频道属于同一平台。", "current-locale": "当前语言偏好为：{0}。", "no-locale": "未设置语言偏好。", options: { remove: "重置设置" } } };

// external/webui/plugins/admin/src/index.ts
var import_meta = {};
var _Admin = class _Admin extends import_koishi2.Service {
  constructor(ctx, config) {
    super(ctx, "admin");
    this.config = config;
    ctx.i18n.define("zh-CN", zh_CN_default);
    ctx.plugin(apply);
    ctx.model.extend("group", {
      id: "unsigned",
      name: "string",
      permissions: "list"
    }, { autoInc: true });
    ctx.model.extend("perm_track", {
      id: "unsigned",
      name: "string",
      permissions: "list"
    }, { autoInc: true });
  }
  groups;
  tracks;
  entry;
  async start() {
    this.groups = await this.ctx.database.get("group", {});
    this.tracks = await this.ctx.database.get("perm_track", {});
    for (const item of this.groups) {
      item.count = await this.ctx.database.select("user", { permissions: { $el: "group:" + item.id } }).execute((row) => import_koishi2.$.count(row.id)) || 0;
      this.setupGroup(item);
    }
    for (const item of this.tracks) {
      this.setupTrack(item);
    }
    this.ctx.inject(["console"], (ctx) => {
      ctx.on("dispose", () => this.entry = void 0);
      this.entry = ctx.console.addEntry(process.env.KOISHI_BASE ? [
        process.env.KOISHI_BASE + "/dist/index.js",
        process.env.KOISHI_BASE + "/dist/style.css"
      ] : process.env.KOISHI_ENV === "browser" ? [
        // @ts-ignore
        import_meta.url.replace(/\/src\/[^/]+$/, "/client/index.ts")
      ] : {
        dev: (0, import_path.resolve)(__dirname, "../client/index.ts"),
        prod: (0, import_path.resolve)(__dirname, "../dist")
      }, () => ({
        group: Object.fromEntries(this.groups.map((group) => [group.id, group])),
        track: Object.fromEntries(this.tracks.map((track) => [track.id, track]))
      }));
      ctx.console.addListener("admin/create-track", (name) => {
        return this.createTrack(name);
      });
      ctx.console.addListener("admin/rename-track", (id, name) => {
        return this.renameTrack(id, name);
      });
      ctx.console.addListener("admin/delete-track", (id) => {
        return this.deleteTrack(id);
      });
      ctx.console.addListener("admin/update-track", (id, permissions) => {
        return this.updateTrack(id, permissions);
      });
      ctx.console.addListener("admin/create-group", (name) => {
        return this.createGroup(name);
      });
      ctx.console.addListener("admin/rename-group", (id, name) => {
        return this.renameGroup(id, name);
      });
      ctx.console.addListener("admin/delete-group", (id) => {
        return this.deleteGroup(id);
      });
      ctx.console.addListener("admin/update-group", (id, permissions) => {
        return this.updateGroup(id, permissions);
      });
      ctx.console.addListener("admin/add-user", (gid, platform, aid) => {
        return this.addUser(gid, platform, aid);
      });
      ctx.console.addListener("admin/remove-user", (gid, platform, aid) => {
        return this.removeUser(gid, platform, aid);
      });
    });
  }
  setupGroup(item) {
    item.dispose = this.ctx.permissions.define("(name)", {
      inherits: ({ name }) => item.permissions.includes(name) && ["group:" + item.id]
    });
  }
  setupTrack(item) {
    item.dispose = this.ctx.permissions.define("(name)", {
      inherits: ({ name }) => {
        const index = item.permissions.indexOf(name);
        if (index > 0)
          return [item.permissions[index - 1]];
      }
    });
  }
  async createTrack(name) {
    var _a;
    const item = await this.ctx.database.create("perm_track", { name });
    this.setupTrack(item);
    this.tracks.push(item);
    (_a = this.entry) == null ? void 0 : _a.refresh();
    return item.id;
  }
  async renameTrack(id, name) {
    var _a;
    const item = this.tracks.find((track) => track.id === id);
    if (!item)
      throw new Error("track not found");
    if (item.name === name)
      return;
    item.name = name;
    await this.ctx.database.set("perm_track", id, { name });
    (_a = this.entry) == null ? void 0 : _a.refresh();
  }
  async deleteTrack(id) {
    var _a;
    const index = this.tracks.findIndex((track) => track.id === id);
    if (index < 0)
      throw new Error("track not found");
    const [item] = this.tracks.splice(index, 1);
    item.dispose();
    (_a = this.entry) == null ? void 0 : _a.refresh();
    await this.ctx.database.remove("perm_track", id);
  }
  async updateTrack(id, permissions) {
    var _a;
    const item = this.tracks.find((group) => group.id === id);
    if (!item)
      throw new Error("track not found");
    item.permissions = permissions;
    await this.ctx.database.set("perm_track", id, { permissions });
    (_a = this.entry) == null ? void 0 : _a.refresh();
  }
  async createGroup(name) {
    var _a;
    const item = await this.ctx.database.create("group", { name });
    item.count = 0;
    this.setupGroup(item);
    this.groups.push(item);
    (_a = this.entry) == null ? void 0 : _a.refresh();
    return item.id;
  }
  async renameGroup(id, name) {
    var _a;
    const item = this.groups.find((group) => group.id === id);
    if (!item)
      throw new Error("group not found");
    if (item.name === name)
      return;
    item.name = name;
    await this.ctx.database.set("group", id, { name });
    (_a = this.entry) == null ? void 0 : _a.refresh();
  }
  async deleteGroup(id) {
    var _a;
    const index = this.groups.findIndex((group) => group.id === id);
    if (index < 0)
      throw new Error("group not found");
    const [item] = this.groups.splice(index, 1);
    item.dispose();
    const users = await this.ctx.database.get("user", { permissions: { $el: "group:" + id } }, ["id", "permissions"]);
    for (const user of users) {
      (0, import_koishi2.remove)(user.permissions, "group:" + id);
    }
    await this.ctx.database.upsert("user", users);
    const updates = this.groups.filter((group) => {
      return (0, import_koishi2.remove)(group.permissions, "group:" + id);
    });
    await this.ctx.database.upsert("group", updates);
    await this.ctx.database.remove("group", id);
    (_a = this.entry) == null ? void 0 : _a.refresh();
  }
  async updateGroup(id, permissions) {
    var _a;
    const item = this.groups.find((group) => group.id === id);
    if (!item)
      throw new Error("group not found");
    item.permissions = permissions;
    await this.ctx.database.set("group", id, { permissions });
    (_a = this.entry) == null ? void 0 : _a.refresh();
  }
  async addUser(id, platform, aid) {
    var _a;
    const item = this.groups.find((group) => group.id === id);
    if (!item)
      throw new Error("group not found");
    const data = await this.ctx.database.getUser(platform, aid, ["id", "permissions"]);
    if (!data)
      throw new Error("user not found");
    if (!data.permissions.includes("group:" + item.id)) {
      data.permissions.push("group:" + item.id);
      item.count++;
      await this.ctx.database.set("user", data.id, { permissions: data.permissions });
      (_a = this.entry) == null ? void 0 : _a.refresh();
    }
  }
  async removeUser(id, platform, aid) {
    var _a;
    const item = this.groups.find((group) => group.id === id);
    if (!item)
      throw new Error("group not found");
    const data = await this.ctx.database.getUser(platform, aid, ["id", "permissions"]);
    if (!data)
      throw new Error("user not found");
    if ((0, import_koishi2.remove)(data.permissions, "group:" + item.id)) {
      item.count--;
      await this.ctx.database.set("user", data.id, { permissions: data.permissions });
      (_a = this.entry) == null ? void 0 : _a.refresh();
    }
  }
};
__name(_Admin, "Admin");
var Admin = _Admin;
((Admin2) => {
  Admin2.inject = ["database"];
  Admin2.Config = import_koishi2.Schema.object({});
})(Admin || (Admin = {}));
var src_default = Admin;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Admin
});
//# sourceMappingURL=index.js.map
