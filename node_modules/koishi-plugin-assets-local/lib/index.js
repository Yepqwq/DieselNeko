"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const koishi_1 = require("koishi");
const fs_1 = require("fs");
const promises_1 = require("fs/promises");
const path_1 = require("path");
const crypto_1 = require("crypto");
const url_1 = require("url");
const file_type_1 = require("file-type");
const assets_1 = __importDefault(require("@koishijs/assets"));
class LocalAssets extends assets_1.default {
    static inject = ['server'];
    _task;
    _stats = {
        assetCount: 0,
        assetSize: 0,
    };
    path;
    root;
    baseUrl;
    noServer = false;
    constructor(ctx, config) {
        super(ctx, config);
        this.root = (0, path_1.resolve)(ctx.baseDir, config.root);
        const selfUrl = config.selfUrl || ctx.server.config.selfUrl;
        if (selfUrl) {
            this.path = (0, koishi_1.sanitize)(config.path || '/files');
            this.baseUrl = (0, koishi_1.trimSlash)(selfUrl) + this.path;
            this.initServer();
        }
        else {
            this.logger.info('missing config "selfUrl", fallback to "file:" scheme');
            this.baseUrl = 'file:';
            this.noServer = true;
        }
    }
    async _start() {
        const legacy = (0, path_1.resolve)(this.ctx.baseDir, 'public');
        await (0, promises_1.mkdir)(this.root, { recursive: true });
        const stats = await (0, promises_1.stat)(legacy).catch(() => null);
        if (stats?.isDirectory()) {
            this.logger.info('migrating to data directory');
            await (0, promises_1.cp)(legacy, this.root);
            await (0, promises_1.rm)(legacy, { recursive: true, force: true });
        }
        const filenames = await (0, promises_1.readdir)(this.root);
        this._stats.assetCount = filenames.length;
        await Promise.all(filenames.map(async (file) => {
            const { size } = await (0, promises_1.stat)((0, path_1.resolve)(this.root, file));
            this._stats.assetSize += size;
        }));
    }
    start() {
        this._task = this._start();
    }
    async initServer() {
        this.ctx.server.get(this.path, async (ctx) => {
            return ctx.body = await this.stats();
        });
        this.ctx.server.get(this.path + '/:name', async (ctx) => {
            const filename = (0, path_1.resolve)(this.root, (0, path_1.basename)(ctx.params.name));
            const stream = await (0, file_type_1.stream)((0, fs_1.createReadStream)(filename));
            ctx.type = stream.fileType?.mime;
            return ctx.body = stream;
        });
        this.ctx.server.post(this.path, async (ctx) => {
            const { salt, sign, url, file } = ctx.query;
            if (Array.isArray(file) || Array.isArray(url)) {
                return ctx.status = 400;
            }
            if (this.config.secret) {
                if (!salt || !sign)
                    return ctx.status = 400;
                const hash = (0, crypto_1.createHmac)('sha1', this.config.secret).update(file + salt).digest('hex');
                if (hash !== sign)
                    return ctx.status = 403;
            }
            return await this.upload(url, file);
        });
    }
    async write(buffer, filename) {
        await (0, promises_1.writeFile)(filename, buffer);
        this._stats.assetCount += 1;
        this._stats.assetSize += buffer.byteLength;
    }
    async upload(url, file) {
        if (url.startsWith(this.baseUrl))
            return url;
        await this._task;
        const { baseUrl, root, noServer } = this;
        const { buffer, filename } = await this.analyze(url, file);
        const savePath = (0, path_1.resolve)(root, filename);
        await this.write(buffer, savePath);
        if (noServer) {
            return (0, url_1.pathToFileURL)(savePath).href;
        }
        else {
            return `${baseUrl}/${filename}`;
        }
    }
    async stats() {
        await this._task;
        return this._stats;
    }
}
(function (LocalAssets) {
    LocalAssets.Config = koishi_1.Schema.intersect([
        koishi_1.Schema.object({
            root: koishi_1.Schema.path({
                filters: ['directory'],
                allowCreate: true,
            }).default('data/assets').description('本地存储资源文件的相对路径。'),
            path: koishi_1.Schema.string().default('/files').description('静态图片暴露在服务器的路径。'),
            selfUrl: koishi_1.Schema.string().role('link').description('Koishi 服务暴露在公网的地址。缺省时将使用全局配置。'),
            secret: koishi_1.Schema.string().description('用于验证上传者的密钥，配合 assets-remote 使用。').role('secret'),
        }),
        assets_1.default.Config,
    ]);
})(LocalAssets || (LocalAssets = {}));
exports.default = LocalAssets;
//# sourceMappingURL=index.js.map