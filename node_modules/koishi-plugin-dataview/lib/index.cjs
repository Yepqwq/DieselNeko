var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => src_default,
  deserialize: () => deserialize,
  serialize: () => serialize
});
module.exports = __toCommonJS(src_exports);
var import_koishi2 = require("koishi");
var import_console = require("@koishijs/console");
var import_path = require("path");

// src/utils.ts
var import_koishi = require("koishi");
function serialize(obj) {
  if (import_koishi.Binary.is(obj))
    return `"b${obj.byteLength}"`;
  if (obj instanceof Date)
    return `"d${obj.toJSON()}"`;
  return JSON.stringify(obj, (_, value) => {
    if (import_koishi.Binary.is(value))
      return `b${value.byteLength}`;
    if (typeof value === "string")
      return "s" + value;
    if (typeof value === "object") {
      if (value instanceof Date)
        return "d" + new Date(value).toJSON();
      if (value === null)
        return null;
      const o = Array.isArray(value) ? [] : {};
      for (const k in value) {
        if (value[k] instanceof Date) {
          o[k] = new Date(value[k]);
          o[k].toJSON = void 0;
        } else {
          o[k] = value[k];
        }
      }
      return o;
    }
    return value;
  });
}
__name(serialize, "serialize");
function deserialize(str) {
  if (str === void 0)
    return void 0;
  return JSON.parse(
    str,
    (_, v) => typeof v === "string" ? v[0] === "s" ? v.slice(1) : v[0] === "b" ? void 0 : new Date(v.slice(1)) : v
  );
}
__name(deserialize, "deserialize");

// src/index.ts
var import_meta = {};
var DatabaseProvider = class extends import_console.DataService {
  static {
    __name(this, "DatabaseProvider");
  }
  static filter = false;
  static inject = ["console", "database"];
  task;
  addListener(name, refresh = false) {
    this.ctx.console.addListener(`database/${name}`, async (...args) => {
      const callargs = args.map(deserialize);
      if (["set", "remove"].includes(name)) {
        const table = (await this.get()).tables[callargs[0]];
        if (table.HookObjectId) {
          callargs[1][table.primary[0]] = new table.HookObjectId(callargs[1][table.primary[0]]);
        }
      }
      const result = await this.ctx.database[name](...callargs);
      if (refresh)
        this.refresh();
      return result === void 0 ? result : serialize(result);
    }, { authority: 4 });
  }
  constructor(ctx) {
    super(ctx, "database", { authority: 4 });
    ctx.console.addEntry(process.env.KOISHI_BASE ? [
      process.env.KOISHI_BASE + "/dist/index.js",
      process.env.KOISHI_BASE + "/dist/style.css"
    ] : process.env.KOISHI_ENV === "browser" ? [
      // @ts-ignore
      import_meta.url.replace(/\/src\/[^/]+$/, "/client/index.ts")
    ] : {
      dev: (0, import_path.resolve)(__dirname, "../client/index.ts"),
      prod: (0, import_path.resolve)(__dirname, "../dist")
    });
    this.addListener("create", true);
    this.addListener("eval", true);
    this.addListener("get");
    this.addListener("remove", true);
    this.addListener("set");
    this.addListener("stats", true);
    this.addListener("upsert", true);
    const refresh = ctx.throttle(() => this.refresh(), 500);
    ctx.on("model", () => refresh());
  }
  async getInfo() {
    const stats = await this.ctx.database.stats();
    const result = { tables: {}, ...stats };
    const tableStats = result.tables;
    result.tables = {};
    await Promise.all(Object.keys(this.ctx.model.tables).map(async (name) => {
      result.tables[name] = {
        ...(0, import_koishi2.clone)((0, import_koishi2.omit)(this.ctx.model.tables[name], ["ctx"])),
        ...tableStats[name]
      };
      result.tables[name].primary = (0, import_koishi2.makeArray)(result.tables[name].primary);
      for (const [key, field] of Object.entries(result.tables[name].fields)) {
        if (field.deprecated)
          delete result.tables[name].fields[key];
      }
      if (result.tables[name].fields[result.tables[name].primary[0]]?.type?.type === "primary" && ["mongo", "MongoDriver"].includes(Object.values(this.ctx.database.drivers)[0].constructor.name)) {
        const record = await this.ctx.database.select(name).limit(1).execute();
        result.tables[name].HookObjectId = record[0]?.[result.tables[name].primary[0]]?.constructor;
      }
    }));
    result.tables = Object.fromEntries(Object.entries(result.tables).sort(([a], [b]) => a.localeCompare(b)));
    return result;
  }
  get(forced = false) {
    if (forced)
      delete this.task;
    return this.task ||= this.getInfo();
  }
};
((DatabaseProvider2) => {
  DatabaseProvider2.Config = import_koishi2.Schema.object({});
})(DatabaseProvider || (DatabaseProvider = {}));
var src_default = DatabaseProvider;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  deserialize,
  serialize
});
