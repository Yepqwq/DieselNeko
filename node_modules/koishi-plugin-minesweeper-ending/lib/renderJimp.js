"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setTheme = setTheme;
exports.renderX = renderX;
const path_1 = require("path");
const minesweeper_1 = __importDefault(require("./minesweeper"));
const fs_1 = __importDefault(require("fs"));
const jimp_1 = __importDefault(require("@initencounter/jimp"));
const koishi_1 = require("koishi");
const imgArr = {};
let FONT;
/**
 * 初始化
 * @param ctx
 * @param config
 */
async function setTheme(ctx, config) {
    const themePath = (0, path_1.resolve)(__dirname, "theme", config.theme);
    const imageTypes = ['closed', 'flag', 'type0', 'type1', 'type2', 'type3', 'type4', 'type5', 'type6', 'type7', 'type8']; // 扫雷的皮肤文件名
    for (var type of imageTypes) {
        imgArr[type] = await ctx.jimp.read((0, path_1.resolve)(themePath, `${type}.png`));
    }
    if (config.colorForSerialNum === "white") {
        FONT = await ctx.jimp.loadFont(ctx.jimp.FONT_SANS_32_WHITE);
    }
    else {
        FONT = await ctx.jimp.loadFont(ctx.jimp.FONT_SANS_32_BLACK);
    }
}
async function main() {
    const ctx = new koishi_1.Context();
    ctx.plugin(jimp_1.default);
    const themePath = (0, path_1.resolve)(__dirname, "theme/", "wom");
    const imageTypes = ['closed', 'flag', 'type0', 'type1', 'type2', 'type3', 'type4', 'type5', 'type6', 'type7', 'type8'];
    for (var type of imageTypes) {
        imgArr[type] = await ctx.jimp.read((0, path_1.resolve)(themePath, `${type}.png`));
    }
    if ("white") {
        FONT = await ctx.jimp.loadFont(ctx.jimp.FONT_SANS_32_WHITE);
    }
    else {
        FONT = await ctx.jimp.loadFont(ctx.jimp.FONT_SANS_32_BLACK);
    }
    const m = new minesweeper_1.default(9, 9, 20);
    m.openCell("6");
    // console.time("mytime")
    const img = await renderX(m, ctx);
    // console.timeEnd("mytime")
    fs_1.default.writeFileSync('test.png', Buffer.from(img));
}
// main()
/**
 * 渲染雷图
 * @param m 雷图对象
 * @returns Arraybuffer
 */
async function renderX(m, ctx) {
    let x = m.width;
    let y = m.height;
    const bigImage = ctx.jimp.newJimp(x * 94, y * 94);
    for (var i = 0; i < m.cells; i++) {
        let [px, py] = [(i % x) * 94, Math.floor(i / x) * 94];
        const ii = m[String(i)];
        if (ii["isOpen"]) {
            bigImage.blit(imgArr[`type${ii["mines"]}`], px, py);
        }
        else if (ii["isFlagged"]) {
            bigImage.blit(imgArr["flag"], px, py);
        }
        else {
            bigImage.blit(imgArr[`closed`], px, py);
            bigImage.print(FONT, px + 30, py + 30, i < 10 ? "0" + i : String(i));
        }
    }
    // await bigImage.writeAsync("test/test.png");
    const res = await bigImage.getBufferAsync(ctx.jimp.MIME_PNG);
    return res;
}
