var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name3 in all)
    __defProp(target, name3, { get: all[name3], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Config: () => Config,
  apply: () => apply2,
  checkTimer: () => checkTimer,
  checkUsage: () => checkUsage,
  getUsage: () => getUsage,
  getUsageName: () => getUsageName,
  inject: () => inject,
  name: () => name2
});
module.exports = __toCommonJS(src_exports);
var import_koishi = require("koishi");

// src/admin.ts
var admin_exports = {};
__export(admin_exports, {
  apply: () => apply,
  name: () => name
});
var name = "usage-admin";
function apply(ctx) {
  ctx.command("usage [key] [value:posint]").userFields(["usage"]).option("set", "-s", { authority: 4 }).option("clear", "-c", { authority: 4 }).action(({ session, options }, name3, count) => {
    const { user } = session;
    if (options.clear) {
      name3 ? delete user.usage[name3] : user.usage = {};
      return session.text(".updated");
    }
    if (options.set) {
      if (!count)
        return session.text("internal.insufficient-arguments");
      user.usage[name3] = count;
      return session.text(".updated");
    }
    if (name3)
      return session.text(".present", [name3, user.usage[name3] || 0]);
    const output = [];
    for (const name4 of Object.keys(user.usage).sort()) {
      if (name4.startsWith("_"))
        continue;
      output.push(`${name4}：${user.usage[name4]}`);
    }
    if (!output.length)
      return session.text(".none");
    output.unshift(session.text(".list"));
    return output.join("\n");
  });
  ctx.command("timer [key] [value:date]").userFields(["timers"]).option("set", "-s", { authority: 4 }).option("clear", "-c", { authority: 4 }).action(({ session, options }, name3, value) => {
    const { user } = session;
    if (options.clear) {
      name3 ? delete user.timers[name3] : user.timers = {};
      return session.text(".updated");
    }
    if (options.set) {
      if (!value)
        return session.text("internal.insufficient-arguments");
      user.timers[name3] = +value;
      return session.text(".updated");
    }
    const now = Date.now();
    if (name3) {
      const delta = user.timers[name3] - now;
      if (delta > 0)
        return session.text(".present", [name3, delta]);
      return session.text(".absent", [name3]);
    }
    const output = [];
    for (const name4 of Object.keys(user.timers).sort()) {
      if (name4.startsWith("_"))
        continue;
      const delta = user.timers[name4] - now;
      if (delta > 0) {
        output.push(session.text(".item", [name4, delta]));
      }
    }
    if (!output.length)
      return session.text(".none");
    output.unshift(session.text(".list"));
    return output.join("\n");
  });
}
__name(apply, "apply");

// src/locales/zh-CN.yml
var zh_CN_default = { internal: { "usage-exhausted": "调用次数已达上限。", "too-frequent": "调用过于频繁，请稍后再试。", "option-not-usage": " (不计入调用)", "command-max-usage": "已调用次数：{0}/{1}。", "command-min-interval": "距离下次调用还需：{0}/{1} 秒。" }, commands: { usage: { description: "调用次数信息", options: { set: "设置调用次数", clear: "清空调用次数" }, messages: { present: "今日 {0} 功能的调用次数为：{1}", list: "今日各功能的调用次数为：", none: "今日没有调用过消耗次数的功能。", updated: "设置成功。" } }, timer: { description: "定时器信息", options: { set: "设置定时器", clear: "清空定时器" }, messages: { present: "定时器 {0} 的生效时间为：剩余 <i18n:time value={1}/>", absent: "定时器 {0} 当前并未生效。", list: "各定时器的生效时间为：", item: "<p>{0}：剩余 <i18n:time value={1}/></p>", none: "当前没有生效的定时器。", updated: "设置成功。" } } } };

// src/index.ts
var name2 = "rate-limit";
var inject = ["database"];
var Config = import_koishi.Schema.object({});
function apply2(ctx) {
  ctx.i18n.define("zh-CN", zh_CN_default);
  ctx.model.extend("user", {
    usage: "json",
    timers: "json"
  });
  ctx.schema.extend("command", import_koishi.Schema.object({
    usageName: import_koishi.Schema.string().description("调用次数的标识符。"),
    maxUsage: import_koishi.Schema.computed(import_koishi.Schema.number(), { userFields: ["authority"] }).default(0).description("每天的调用次数上限。"),
    minInterval: import_koishi.Schema.computed(import_koishi.Schema.number(), { userFields: ["authority"] }).default(0).description("连续调用的最小间隔。")
  }), 800);
  ctx.schema.extend("command-option", import_koishi.Schema.object({
    notUsage: import_koishi.Schema.boolean().default(false).description("不计入调用次数。")
  }), 800);
  ctx.before("command/attach-user", ({ command, options = {} }, fields) => {
    if (!command)
      return;
    const { maxUsage, minInterval, bypassAuthority } = command.config;
    let shouldFetchUsage = !!(maxUsage || minInterval);
    for (const { name: name3, notUsage } of Object.values(command._options)) {
      if (name3 === "help")
        continue;
      if (name3 in options && notUsage)
        shouldFetchUsage = false;
    }
    if (shouldFetchUsage) {
      fields.add("authority");
      if (maxUsage)
        fields.add("usage");
      if (minInterval)
        fields.add("timers");
    }
    if (bypassAuthority)
      fields.add("authority");
  });
  function bypassRateLimit(session, command) {
    if (!session.user)
      return true;
    const bypassAuthority = session.resolve(command.config.bypassAuthority);
    if (session.user.authority >= bypassAuthority)
      return true;
  }
  __name(bypassRateLimit, "bypassRateLimit");
  ctx.before("command/execute", (argv) => {
    const { session, options, command } = argv;
    if (bypassRateLimit(session, command))
      return;
    function sendHint(path, ...param) {
      if (!command.config.showWarning)
        return "";
      return session.text([`.${path}`, `internal.${path}`], param);
    }
    __name(sendHint, "sendHint");
    let isUsage = true;
    for (const { name: name4, notUsage } of Object.values(command._options)) {
      if (name4 in options && notUsage)
        isUsage = false;
    }
    if (!isUsage)
      return;
    const name3 = getUsageName(command);
    const minInterval = session.resolve(command.config.minInterval);
    const maxUsage = session.resolve(command.config.maxUsage);
    if (minInterval > 0 && checkTimer(name3, session.user, minInterval)) {
      return sendHint("too-frequent");
    }
    if (maxUsage > 0 && checkUsage(name3, session.user, maxUsage)) {
      return sendHint("usage-exhausted");
    }
  });
  ctx.on("help/command", (output, command, session) => {
    if (bypassRateLimit(session, command))
      return;
    const user = session.user;
    const name3 = getUsageName(command);
    const maxUsage = session.resolve(command.config.maxUsage) ?? Infinity;
    const minInterval = session.resolve(command.config.minInterval) ?? 0;
    if (maxUsage < Infinity) {
      const count = getUsage(name3, user);
      output.push(session.text("internal.command-max-usage", [Math.min(count, maxUsage), maxUsage]));
    }
    if (minInterval > 0) {
      const due = user.timers[name3];
      const nextUsage = due ? (Math.max(0, due - Date.now()) / 1e3).toFixed() : 0;
      output.push(session.text("internal.command-min-interval", [nextUsage, minInterval / 1e3]));
    }
  });
  ctx.on("help/option", (output, option, command, session) => {
    if (bypassRateLimit(session, command))
      return output;
    const maxUsage = session.resolve(command.config.maxUsage);
    if (option.notUsage && maxUsage !== Infinity) {
      output += session.text("internal.option-not-usage");
    }
    return output;
  });
  ctx.plugin(admin_exports);
}
__name(apply2, "apply");
function getUsageName(command) {
  return command.config.usageName || command.name.replace(/\./g, ":");
}
__name(getUsageName, "getUsageName");
function getUsage(name3, user) {
  const _date = import_koishi.Time.getDateNumber();
  if (user.usage._date !== _date) {
    user.usage = { _date };
  }
  return user.usage[name3] || 0;
}
__name(getUsage, "getUsage");
function checkUsage(name3, user, maxUsage) {
  if (!user.usage)
    return;
  const count = getUsage(name3, user);
  if (count >= maxUsage)
    return true;
  if (maxUsage) {
    user.usage[name3] = count + 1;
  }
}
__name(checkUsage, "checkUsage");
function checkTimer(name3, { timers }, offset) {
  const now = Date.now();
  if (!(now <= timers._date)) {
    for (const key in timers) {
      if (now > timers[key])
        delete timers[key];
    }
    timers._date = now + import_koishi.Time.day;
  }
  if (now <= timers[name3])
    return true;
  if (offset !== void 0) {
    timers[name3] = now + offset;
  }
}
__name(checkTimer, "checkTimer");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Config,
  apply,
  checkTimer,
  checkUsage,
  getUsage,
  getUsageName,
  inject,
  name
});
//# sourceMappingURL=index.js.map
