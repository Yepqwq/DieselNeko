"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const canvas_1 = __importDefault(require("@koishijs/canvas"));
const koishi_1 = require("koishi");
const path_1 = require("path");
const url_1 = require("url");
const kElement = Symbol('element');
class BaseElement {
    page;
    id;
    [kElement] = true;
    constructor(page, id) {
        this.page = page;
        this.id = id;
    }
    get selector() {
        return `document.querySelector("#${this.id}")`;
    }
    async dispose() {
        await this.page.evaluate(`${this.selector}?.remove()`);
        this.id = null;
    }
}
class CanvasElement extends BaseElement {
    width;
    height;
    stmts = [];
    ctx = new Proxy({
        canvas: this,
        direction: 'inherit',
        fillStyle: '#000000',
        filter: 'none',
        font: '10px sans-serif',
        fontKerning: 'auto',
        fontStretch: 'normal',
        fontVariantCaps: 'normal',
        globalAlpha: 1,
        globalCompositeOperation: 'source-over',
        imageSmoothingEnabled: true,
        imageSmoothingQuality: 'low',
        letterSpacing: '0px',
        lineCap: 'butt',
        lineDashOffset: 0,
        lineJoin: 'miter',
        lineWidth: 1,
        miterLimit: 10,
        shadowBlur: 0,
        shadowColor: 'rgba(0, 0, 0, 0)',
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        strokeStyle: '#000000',
        textAlign: 'start',
        textBaseline: 'alphabetic',
        textRendering: 'auto',
        wordSpacing: '0px',
    }, {
        get: (target, prop, receiver) => {
            if (Reflect.has(target, prop) || typeof prop === 'symbol') {
                return Reflect.get(target, prop, receiver);
            }
            return new Proxy(() => { }, {
                apply: (target, thisArg, argArray) => {
                    this.stmts.push(`ctx.${prop}(${argArray.map((value) => {
                        if (value[kElement])
                            return value.selector;
                        return JSON.stringify(value);
                    }).join(', ')});`);
                },
            });
        },
        set: (target, prop, value, receiver) => {
            if (Reflect.has(target, prop)) {
                if (typeof prop !== 'symbol') {
                    this.stmts.push(`ctx.${prop} = ${JSON.stringify(value)};`);
                }
                return Reflect.set(target, prop, value, receiver);
            }
        },
    });
    constructor(page, id, width, height) {
        super(page, id);
        this.width = width;
        this.height = height;
    }
    getContext(type) {
        return this.ctx;
    }
    async toDataURL(type) {
        if (!this.id)
            throw new Error('canvas has been disposed');
        try {
            this.stmts.unshift(`(async (ctx) => {`);
            const expr = this.stmts.join('\n  ') + `\n})(${this.selector}.getContext('2d'))`;
            this.stmts = [];
            await this.page.evaluate(expr);
            return await this.page.evaluate(`${this.selector}.toDataURL(${JSON.stringify(type)})`);
        }
        catch (err) {
            await this.dispose();
            throw err;
        }
    }
    async toBuffer(type) {
        const url = await this.toDataURL(type);
        return Buffer.from(url.slice(url.indexOf(',') + 1), 'base64');
    }
}
class ImageElement extends BaseElement {
    ctx;
    source;
    naturalHeight;
    naturalWidth;
    constructor(ctx, page, id, source) {
        super(page, id);
        this.ctx = ctx;
        this.source = source;
    }
    async initialize() {
        let base64;
        if (this.source instanceof URL) {
            this.source = this.source.href;
        }
        if (typeof this.source === 'string') {
            const file = await this.ctx.http.file(this.source);
            base64 = (0, koishi_1.arrayBufferToBase64)(file.data);
        }
        else if (Buffer.isBuffer(this.source)) {
            base64 = this.source.toString('base64');
        }
        else {
            base64 = (0, koishi_1.arrayBufferToBase64)(this.source);
        }
        const size = await this.page.evaluate(`loadImage(${JSON.stringify(this.id)}, ${JSON.stringify(base64)})`);
        this.naturalWidth = size.width;
        this.naturalHeight = size.height;
    }
}
class default_1 extends canvas_1.default {
    static inject = ['puppeteer', 'http'];
    page;
    counter = 0;
    async start() {
        const page = await this.ctx.puppeteer.page();
        try {
            await page.goto((0, url_1.pathToFileURL)((0, path_1.resolve)(__dirname, '../index.html')).href);
            this.page = page;
        }
        catch (err) {
            await page.close();
            throw err;
        }
    }
    async stop() {
        await this.page?.close();
        this.page = null;
    }
    async createCanvas(width, height) {
        try {
            const name = `canvas_${++this.counter}`;
            await this.page.evaluate([
                `const ${name} = document.createElement('canvas');`,
                `${name}.width = ${width};`,
                `${name}.height = ${height};`,
                `${name}.id = ${JSON.stringify(name)};`,
                `document.body.appendChild(${name});`,
            ].join('\n'));
            return new CanvasElement(this.page, name, width, height);
        }
        catch (err) {
            console.log(err);
            throw err;
        }
    }
    async loadImage(source) {
        const id = `image_${++this.counter}`;
        const image = new ImageElement(this.ctx, this.page, id, source);
        await image.initialize();
        return image;
    }
}
exports.default = default_1;
//# sourceMappingURL=canvas.js.map