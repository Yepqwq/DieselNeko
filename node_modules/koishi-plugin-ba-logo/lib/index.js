"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.apply = exports.Config = exports.using = exports.name = void 0;
const path_1 = __importDefault(require("path"));
const koishi_1 = require("koishi");
exports.name = 'ba-logo';
const logger = new koishi_1.Logger('ba-logo');
exports.using = ['puppeteer'];
exports.Config = koishi_1.Schema.object({
    fontSize: koishi_1.Schema.number().default(84),
    transparent: koishi_1.Schema.boolean().default(false),
    haloX: koishi_1.Schema.number().default(-18),
    haloY: koishi_1.Schema.number().default(0)
});
function normalize(...file) {
    return path_1.default.posix.normalize(path_1.default.resolve(...file));
}
async function validator(texts, session) {
    const results = [];
    for (const text of texts) {
        if (text === null || text === undefined || text === '') {
            results.push({ result: 'invalid', msg: '输入不完整' });
            return results;
        }
        if (text.includes(' ')) {
            results.push({ result: 'text', msg: text });
            continue;
        }
        const t = koishi_1.h.parse(text)[0];
        switch (t.type) {
            case 'at': {
                results.push({ result: 'at', msg: (await session.bot.getGuildMember(session.channelId, t.attrs.id)).user.name });
                break;
            }
            case 'text': {
                results.push({ result: 'text', msg: t.attrs.content });
                break;
            }
            default: {
                results.push({ result: 'invalid', msg: '输入无效' });
                return results;
            }
        }
    }
    return results;
}
function apply(ctx) {
    ctx.i18n.define('zh', require('./locales/zh-CN'));
    ctx.i18n.define('en', require('./locales/en-US'));
    ctx.i18n.define('jp', require('./locales/ja-JP'));
    ctx
        .command('ba <textL:string> <textR:string>')
        .option('fontSize', '-f <font:number>')
        .option('transparent', '-t')
        .option('haloX', '-x <x:number>')
        .option('haloY', '-y <y:number>')
        .action(async ({ session, options }, textL, textR) => {
        const results = await validator([textL, textR], session);
        if (results.some(r => r.result === 'invalid')) {
            return session.text(results.find(r => r.result === 'invalid').msg);
        }
        else {
            const page = await session.app.puppeteer.browser.newPage();
            await page.goto(`file:///${normalize(__dirname, '../public/index.html')}`, { waitUntil: 'networkidle0' });
            await page.evaluate(async (inputs, config) => {
                const ba = new BALogo(config);
                await ba.draw(inputs);
            }, { textL: results[0].msg, textR: results[1].msg }, { options, config: ctx.config });
            const canvas = await page.$('#output');
            const im = await canvas.screenshot({ type: 'png', omitBackground: true });
            await session.send(koishi_1.h.image(im, 'image/png'));
            await page.close();
        }
    });
}
exports.apply = apply;
