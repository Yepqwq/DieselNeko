var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// src/database.ts
import { deduplicate, defineProperty as defineProperty4, filterKeys as filterKeys3, isNullable as isNullable5, makeArray as makeArray2, mapValues as mapValues5, noop, omit, pick, remove } from "cosmokit";
import { Service } from "cordis";

// src/utils.ts
import { Binary as Binary2, isNullable as isNullable4 } from "cosmokit";

// src/eval.ts
import { defineProperty as defineProperty2, isNullable as isNullable3, mapValues as mapValues3 } from "cosmokit";

// src/type.ts
import { Binary, defineProperty, isNullable, mapValues } from "cosmokit";
var Type;
((Type2) => {
  Type2.kType = Symbol.for("minato.type");
  Type2.Boolean = defineProperty({ type: "boolean" }, Type2.kType, true);
  Type2.Number = defineProperty({ type: "double" }, Type2.kType, true);
  Type2.String = defineProperty({ type: "string" }, Type2.kType, true);
  Type2.Object = /* @__PURE__ */ __name((obj) => defineProperty({
    type: "json",
    inner: globalThis.Object.keys(obj ?? {}).length ? mapValues(obj, (value) => isType(value) ? value : fromField(value)) : void 0
  }, Type2.kType, true), "Object");
  Type2.Array = /* @__PURE__ */ __name((type) => defineProperty({
    type: "json",
    inner: type,
    array: true
  }, Type2.kType, true), "Array");
  function fromPrimitive(value) {
    if (isNullable(value))
      return fromField("expr");
    else if (typeof value === "number")
      return Type2.Number;
    else if (typeof value === "string")
      return Type2.String;
    else if (typeof value === "boolean")
      return Type2.Boolean;
    else if (typeof value === "bigint")
      return fromField("bigint");
    else if (value instanceof Date)
      return fromField("timestamp");
    else if (Binary.is(value))
      return fromField("binary");
    else if (globalThis.Array.isArray(value))
      return (0, Type2.Array)(value.length ? fromPrimitive(value[0]) : void 0);
    else if (typeof value === "object")
      return fromField("json");
    throw new TypeError(`invalid primitive: ${value}`);
  }
  Type2.fromPrimitive = fromPrimitive;
  __name(fromPrimitive, "fromPrimitive");
  function fromField(field) {
    if (isType(field))
      return field;
    if (typeof field === "string")
      return defineProperty({ type: field }, Type2.kType, true);
    else if (field.type)
      return field.type;
    else if (field.expr?.[Type2.kType])
      return field.expr[Type2.kType];
    throw new TypeError(`invalid field: ${field}`);
  }
  Type2.fromField = fromField;
  __name(fromField, "fromField");
  function fromTerm(value, initial) {
    if (isEvalExpr(value))
      return value[Type2.kType] ?? initial ?? fromField("expr");
    else
      return fromPrimitive(value);
  }
  Type2.fromTerm = fromTerm;
  __name(fromTerm, "fromTerm");
  function fromTerms(values, initial) {
    return values.map((x) => fromTerm(x)).find((type) => type.type !== "expr") ?? initial ?? fromField("expr");
  }
  Type2.fromTerms = fromTerms;
  __name(fromTerms, "fromTerms");
  function isType(value) {
    return value?.[Type2.kType] === true;
  }
  Type2.isType = isType;
  __name(isType, "isType");
  function isArray(type) {
    return type.type === "json" && type.array;
  }
  Type2.isArray = isArray;
  __name(isArray, "isArray");
  function getInner(type, key) {
    if (!type?.inner)
      return;
    if (isArray(type) && isNullable(key))
      return type.inner;
    if (isNullable(key))
      return;
    if (type.inner[key])
      return type.inner[key];
    if (key.includes("."))
      return key.split(".").reduce((t, k) => getInner(t, k), type);
    return (0, Type2.Object)(globalThis.Object.fromEntries(
      globalThis.Object.entries(type.inner).filter(([k]) => k.startsWith(`${key}.`)).map(([k, v]) => [k.slice(key.length + 1), v])
    ));
  }
  Type2.getInner = getInner;
  __name(getInner, "getInner");
  function transform(value, type, callback) {
    if (!isNullable(value) && type?.inner) {
      if (Type2.isArray(type)) {
        return value.map((x) => callback(x, Type2.getInner(type))).filter((x) => !type.ignoreNull || !isEmpty(x));
      } else {
        if (type.ignoreNull && isEmpty(value))
          return null;
        return mapValues(value, (x, k) => callback(x, Type2.getInner(type, k)));
      }
    }
    return value;
  }
  Type2.transform = transform;
  __name(transform, "transform");
})(Type || (Type = {}));

// src/model.ts
import { clone, filterKeys, isNullable as isNullable2, makeArray, mapValues as mapValues2 } from "cosmokit";
var Primary = Symbol("minato.primary");
var Relation;
((Relation4) => {
  const Marker = Symbol("minato.relation");
  Relation4.Type = ["oneToOne", "oneToMany", "manyToOne", "manyToMany"];
  function buildAssociationTable(...tables) {
    return "_" + tables.sort().join("_");
  }
  Relation4.buildAssociationTable = buildAssociationTable;
  __name(buildAssociationTable, "buildAssociationTable");
  function buildAssociationKey(key, table) {
    return `${table}.${key}`;
  }
  Relation4.buildAssociationKey = buildAssociationKey;
  __name(buildAssociationKey, "buildAssociationKey");
  function buildSharedKey(field, reference) {
    return [field, reference].sort().join("_");
  }
  Relation4.buildSharedKey = buildSharedKey;
  __name(buildSharedKey, "buildSharedKey");
  function parse(def, key, model, relmodel, subprimary) {
    const shared = !def.shared ? {} : typeof def.shared === "string" ? { [def.shared]: def.shared } : Array.isArray(def.shared) ? Object.fromEntries(def.shared.map((x) => [x, x])) : def.shared;
    const fields = def.fields ?? (subprimary || model.name === relmodel.name || def.type === "manyToOne" || def.type === "oneToOne" && !makeArray(relmodel.primary).every((key2) => !relmodel.fields[key2]?.nullable) ? makeArray(relmodel.primary).map((x) => `${key}.${x}`) : model.primary);
    const relation = {
      type: def.type,
      table: def.table ?? relmodel.name,
      fields: makeArray(fields),
      shared,
      references: makeArray(def.references ?? relmodel.primary),
      required: def.type !== "manyToOne" && model.name !== relmodel.name && makeArray(fields).every((key2) => !model.fields[key2]?.nullable || makeArray(model.primary).includes(key2))
    };
    Object.entries(shared).forEach(([k, v]) => {
      relation.fields = relation.fields.filter((x) => x !== k);
      relation.references = relation.references.filter((x) => x !== v);
    });
    const inverse = {
      type: relation.type === "oneToMany" ? "manyToOne" : relation.type === "manyToOne" ? "oneToMany" : relation.type,
      table: model.name,
      fields: relation.references,
      references: relation.fields,
      shared: Object.fromEntries(Object.entries(shared).map(([k, v]) => [v, k])),
      required: relation.type !== "oneToMany" && relation.references.every((key2) => !relmodel.fields[key2]?.nullable || makeArray(relmodel.primary).includes(key2))
    };
    if (inverse.required)
      relation.required = false;
    return [relation, inverse];
  }
  Relation4.parse = parse;
  __name(parse, "parse");
})(Relation || (Relation = {}));
var Field;
((Field2) => {
  Field2.number = ["integer", "unsigned", "float", "double", "decimal"];
  Field2.string = ["char", "string", "text"];
  Field2.boolean = ["boolean"];
  Field2.date = ["timestamp", "date", "time"];
  Field2.object = ["list", "json"];
  const NewType = Symbol("minato.newtype");
  const regexp = /^(\w+)(?:\((.+)\))?$/;
  function parse(source) {
    if (typeof source === "function")
      throw new TypeError("view field is not supported");
    if (typeof source !== "string") {
      return {
        initial: null,
        deftype: source.type,
        ...source,
        type: Type.fromField(source.type)
      };
    }
    const capture = regexp.exec(source);
    if (!capture)
      throw new TypeError("invalid field definition");
    const type = capture[1];
    const args = (capture[2] || "").split(",");
    const field = { deftype: type, type: Type.fromField(type) };
    if (field.initial === void 0)
      field.initial = getInitial(type);
    if (type === "decimal") {
      field.precision = +args[0];
      field.scale = +args[1];
    } else if (args[0]) {
      field.length = +args[0];
    }
    return field;
  }
  Field2.parse = parse;
  __name(parse, "parse");
  function getInitial(type, initial) {
    if (initial === void 0) {
      if (Field2.number.includes(type))
        return 0;
      if (Field2.string.includes(type))
        return "";
      if (type === "list")
        return [];
      if (type === "json")
        return {};
    }
    return initial;
  }
  Field2.getInitial = getInitial;
  __name(getInitial, "getInitial");
  function available(field) {
    return !!field && !field.deprecated && !field.relation && field.deftype !== "expr";
  }
  Field2.available = available;
  __name(available, "available");
})(Field || (Field = {}));
var Model = class {
  constructor(name) {
    this.name = name;
    this.autoInc = false;
    this.primary = "id";
    this.unique = [];
    this.foreign = {};
  }
  static {
    __name(this, "Model");
  }
  fields = {};
  migrations = /* @__PURE__ */ new Map();
  type;
  extend(fields = {}, config = {}) {
    const { primary, autoInc, unique = [], foreign, callback } = config;
    this.primary = primary || this.primary;
    this.autoInc = autoInc || this.autoInc;
    unique.forEach((key) => this.unique.includes(key) || this.unique.push(key));
    Object.assign(this.foreign, foreign);
    if (callback)
      this.migrations.set(callback, Object.keys(fields));
    for (const key in fields) {
      this.fields[key] = Field.parse(fields[key]);
      this.fields[key].deprecated = !!callback;
    }
    if (typeof this.primary === "string" && this.fields[this.primary]?.deftype === "primary") {
      this.autoInc = true;
    }
    this.checkIndex(this.primary);
    this.unique.forEach((index) => this.checkIndex(index));
  }
  checkIndex(index) {
    for (const key of makeArray(index)) {
      if (!this.fields[key]) {
        throw new TypeError(`missing field definition for index key "${key}"`);
      }
    }
  }
  resolveValue(field, value) {
    if (isNullable2(value))
      return value;
    if (typeof field === "string")
      field = this.fields[field];
    if (field)
      field = Type.fromField(field);
    if (field?.type === "time") {
      const date = /* @__PURE__ */ new Date(0);
      date.setHours(value.getHours(), value.getMinutes(), value.getSeconds(), value.getMilliseconds());
      return date;
    } else if (field?.type === "date") {
      const date = new Date(value);
      date.setHours(0, 0, 0, 0);
      return date;
    }
    return value;
  }
  resolveModel(obj, model) {
    if (!model)
      model = this.getType();
    if (isNullable2(obj) || !model.inner)
      return obj;
    if (Type.isArray(model) && Array.isArray(obj)) {
      return obj.map((x) => this.resolveModel(x, Type.getInner(model)));
    }
    const result = {};
    for (const key in obj) {
      const type = Type.getInner(model, key);
      if (!type || isNullable2(obj[key])) {
        result[key] = obj[key];
      } else if (type.type !== "json") {
        result[key] = this.resolveValue(type, obj[key]);
      } else if (type.inner && Type.isArray(type) && Array.isArray(obj[key])) {
        result[key] = obj[key].map((x) => this.resolveModel(x, Type.getInner(type)));
      } else if (type.inner) {
        result[key] = this.resolveModel(obj[key], type);
      } else {
        result[key] = obj[key];
      }
    }
    return result;
  }
  format(source, strict = true, prefix = "", result = {}) {
    const fields = Object.keys(this.fields).filter((key) => !this.fields[key].relation);
    Object.entries(source).map(([key, value]) => {
      key = prefix + key;
      if (value === void 0)
        return;
      if (fields.includes(key)) {
        result[key] = value;
        return;
      }
      const field = fields.find((field2) => key.startsWith(field2 + "."));
      if (field) {
        result[key] = value;
      } else if (isFlat(value)) {
        if (strict && (typeof value !== "object" || Object.keys(value).length)) {
          throw new TypeError(`unknown field "${key}" in model ${this.name}`);
        }
      } else {
        this.format(value, strict, key + ".", result);
      }
    });
    return strict && prefix === "" ? this.resolveModel(result) : result;
  }
  parse(source, strict = true, prefix = "", result = {}) {
    const fields = Object.keys(this.fields).filter((key) => !this.fields[key].relation);
    if (strict && prefix === "") {
      Object.assign(result, unravel(
        Object.fromEntries(fields.filter((key) => key.includes(".")).map((key) => [key.slice(0, key.lastIndexOf(".")), {}]))
      ));
    }
    for (const key in source) {
      let node = result;
      const segments = key.split(".").reverse();
      for (let index = segments.length - 1; index > 0; index--) {
        const segment = segments[index];
        node = node[segment] ??= {};
      }
      if (key in source) {
        const fullKey = prefix + key, value = source[key];
        const field = fields.find((field2) => fullKey === field2 || fullKey.startsWith(field2 + "."));
        if (field) {
          node[segments[0]] = value;
        } else if (isFlat(value)) {
          if (strict) {
            throw new TypeError(`unknown field "${fullKey}" in model ${this.name}`);
          } else {
            node[segments[0]] = value;
          }
        } else {
          this.parse(value, strict, fullKey + ".", node[segments[0]] ??= {});
        }
      }
    }
    return strict && prefix === "" ? this.resolveModel(result) : result;
  }
  create(data) {
    const result = {};
    const keys = makeArray(this.primary);
    for (const key in this.fields) {
      if (!Field.available(this.fields[key]))
        continue;
      const { initial } = this.fields[key];
      if (!keys.includes(key) && !isNullable2(initial)) {
        result[key] = clone(initial);
      }
    }
    return this.parse({ ...result, ...data });
  }
  avaiableFields() {
    return filterKeys(this.fields, (_, field) => Field.available(field));
  }
  getType(key) {
    this.type ??= Type.Object(mapValues2(this.fields, (field) => Type.fromField(field)));
    return key ? Type.getInner(this.type, key) : this.type;
  }
};

// src/eval.ts
function isEvalExpr(value) {
  return value && Object.keys(value).some((key) => key.startsWith("$"));
}
__name(isEvalExpr, "isEvalExpr");
var isUpdateExpr = isEvalExpr;
function isAggrExpr(expr) {
  return expr["$"] || expr["$select"];
}
__name(isAggrExpr, "isAggrExpr");
function hasSubquery(value) {
  if (!isEvalExpr(value))
    return false;
  return Object.entries(value).filter(([k]) => k.startsWith("$")).some(([k, v]) => {
    if (isNullable3(v) || isComparable(v))
      return false;
    if (k === "$exec")
      return true;
    if (isEvalExpr(v))
      return hasSubquery(v);
    if (Array.isArray(v))
      return v.some((x) => hasSubquery(x));
    if (typeof v === "object")
      return Object.values(v).some((x) => hasSubquery(x));
    return false;
  });
}
__name(hasSubquery, "hasSubquery");
var kExpr = Symbol("expr");
var kType = Symbol("type");
var kAggr = Symbol("aggr");
var Eval2 = /* @__PURE__ */ __name((key, value, type) => defineProperty2(defineProperty2({ ["$" + key]: value }, kExpr, true), Type.kType, type), "Eval");
var operators = /* @__PURE__ */ Object.create(null);
operators["$"] = getRecursive;
function unary(key, callback, type) {
  operators[`$${key}`] = callback;
  return (value) => Eval2(key, value, typeof type === "function" ? type(value) : type);
}
__name(unary, "unary");
function multary(key, callback, type) {
  operators[`$${key}`] = callback;
  return (...args) => Eval2(key, args, typeof type === "function" ? type(...args) : type);
}
__name(multary, "multary");
function comparator(key, callback) {
  operators[`$${key}`] = (args, data) => {
    const left = executeEval(data, args[0]);
    const right = executeEval(data, args[1]);
    if (isNullable3(left) || isNullable3(right))
      return true;
    return callback(left.valueOf(), right.valueOf());
  };
  return (...args) => Eval2(key, args, Type.Boolean);
}
__name(comparator, "comparator");
Eval2.switch = (branches, vDefault) => Eval2("switch", { branches, default: vDefault }, Type.fromTerm(branches[0]));
operators.$switch = (args, data) => {
  for (const branch of args.branches) {
    if (executeEval(data, branch.case))
      return executeEval(data, branch.then);
  }
  return executeEval(data, args.default);
};
Eval2.ignoreNull = (expr) => (expr[Type.kType].ignoreNull = true, expr);
Eval2.select = multary("select", (args, table) => args.map((arg) => executeEval(table, arg)), Type.Array());
Eval2.query = (row, query, expr = true) => ({ $expr: expr, ...query });
Eval2.if = multary("if", ([cond, vThen, vElse], data) => executeEval(data, cond) ? executeEval(data, vThen) : executeEval(data, vElse), (cond, vThen, vElse) => Type.fromTerm(vThen));
Eval2.ifNull = multary("ifNull", ([value, fallback], data) => executeEval(data, value) ?? executeEval(data, fallback), (value) => Type.fromTerm(value));
Eval2.add = multary("add", (args, data) => args.reduce((prev, curr) => prev + executeEval(data, curr), 0), Type.Number);
Eval2.mul = Eval2.multiply = multary("multiply", (args, data) => args.reduce((prev, curr) => prev * executeEval(data, curr), 1), Type.Number);
Eval2.sub = Eval2.subtract = multary("subtract", ([left, right], data) => executeEval(data, left) - executeEval(data, right), Type.Number);
Eval2.div = Eval2.divide = multary("divide", ([left, right], data) => executeEval(data, left) / executeEval(data, right), Type.Number);
Eval2.mod = Eval2.modulo = multary("modulo", ([left, right], data) => executeEval(data, left) % executeEval(data, right), Type.Number);
Eval2.abs = unary("abs", (arg, data) => Math.abs(executeEval(data, arg)), Type.Number);
Eval2.floor = unary("floor", (arg, data) => Math.floor(executeEval(data, arg)), Type.Number);
Eval2.ceil = unary("ceil", (arg, data) => Math.ceil(executeEval(data, arg)), Type.Number);
Eval2.round = unary("round", (arg, data) => Math.round(executeEval(data, arg)), Type.Number);
Eval2.exp = unary("exp", (arg, data) => Math.exp(executeEval(data, arg)), Type.Number);
Eval2.log = multary("log", ([left, right], data) => Math.log(executeEval(data, left)) / Math.log(executeEval(data, right ?? Math.E)), Type.Number);
Eval2.pow = Eval2.power = multary("power", ([left, right], data) => Math.pow(executeEval(data, left), executeEval(data, right)), Type.Number);
Eval2.random = () => Eval2("random", {}, Type.Number);
operators.$random = () => Math.random();
Eval2.eq = comparator("eq", (left, right) => left === right);
Eval2.ne = comparator("ne", (left, right) => left !== right);
Eval2.gt = comparator("gt", (left, right) => left > right);
Eval2.ge = Eval2.gte = comparator("gte", (left, right) => left >= right);
Eval2.lt = comparator("lt", (left, right) => left < right);
Eval2.le = Eval2.lte = comparator("lte", (left, right) => left <= right);
Eval2.in = (value, array) => Eval2("in", [Array.isArray(value) ? Eval2.select(...value) : value, array], Type.Boolean);
operators.$in = ([value, array], data) => {
  const val = executeEval(data, value), arr = executeEval(data, array);
  if (typeof val === "object")
    return arr.includes(val) || arr.map(JSON.stringify).includes(JSON.stringify(val));
  return arr.includes(val);
};
Eval2.nin = (value, array) => Eval2("nin", [Array.isArray(value) ? Eval2.select(...value) : value, array], Type.Boolean);
operators.$nin = ([value, array], data) => {
  const val = executeEval(data, value), arr = executeEval(data, array);
  if (typeof val === "object")
    return !arr.includes(val) && !arr.map(JSON.stringify).includes(JSON.stringify(val));
  return !arr.includes(val);
};
Eval2.concat = multary("concat", (args, data) => args.map((arg) => executeEval(data, arg)).join(""), Type.String);
Eval2.regex = multary("regex", ([value, regex, flags], data) => makeRegExp(executeEval(data, regex), flags).test(executeEval(data, value)), Type.Boolean);
Eval2.and = multary("and", (args, data) => {
  const type = Type.fromTerms(args, Type.Boolean);
  if (Field.boolean.includes(type.type))
    return args.every((arg) => executeEval(data, arg));
  else if (Field.number.includes(type.type))
    return args.map((arg) => executeEval(data, arg)).reduce((prev, curr) => prev & curr);
  else if (type.type === "bigint")
    return args.map((arg) => BigInt(executeEval(data, arg) ?? 0)).reduce((prev, curr) => prev & curr);
}, (...args) => Type.fromTerms(args, Type.Boolean));
Eval2.or = multary("or", (args, data) => {
  const type = Type.fromTerms(args, Type.Boolean);
  if (Field.boolean.includes(type.type))
    return args.some((arg) => executeEval(data, arg));
  else if (Field.number.includes(type.type))
    return args.map((arg) => executeEval(data, arg)).reduce((prev, curr) => prev | curr);
  else if (type.type === "bigint")
    return args.map((arg) => BigInt(executeEval(data, arg) ?? 0)).reduce((prev, curr) => prev | curr);
}, (...args) => Type.fromTerms(args, Type.Boolean));
Eval2.not = unary("not", (value, data) => {
  const type = Type.fromTerms([value], Type.Boolean);
  if (Field.boolean.includes(type.type))
    return !executeEval(data, value);
  else if (Field.number.includes(type.type))
    return ~executeEval(data, value);
  else if (type.type === "bigint")
    return ~BigInt(executeEval(data, value) ?? 0);
}, (value) => Type.fromTerms([value], Type.Boolean));
Eval2.xor = multary("xor", (args, data) => {
  const type = Type.fromTerms(args, Type.Boolean);
  if (Field.boolean.includes(type.type))
    return args.map((arg) => executeEval(data, arg)).reduce((prev, curr) => prev !== curr);
  else if (Field.number.includes(type.type))
    return args.map((arg) => executeEval(data, arg)).reduce((prev, curr) => prev ^ curr);
  else if (type.type === "bigint")
    return args.map((arg) => BigInt(executeEval(data, arg) ?? 0)).reduce((prev, curr) => prev ^ curr);
}, (...args) => Type.fromTerms(args, Type.Boolean));
Eval2.literal = multary("literal", ([value, type]) => {
  if (type)
    throw new TypeError("literal cast is not supported");
  else
    return value;
}, (value, type) => type ? Type.fromField(type) : Type.fromTerm(value));
Eval2.number = unary("number", (arg, data) => {
  const value = executeEval(data, arg);
  return value instanceof Date ? Math.floor(value.valueOf() / 1e3) : Number(value);
}, Type.Number);
var unwrapAggr = /* @__PURE__ */ __name((expr, def) => {
  let type = Type.fromTerm(expr);
  type = Type.getInner(type) ?? type;
  return def && type.type === "expr" ? def : type;
}, "unwrapAggr");
Eval2.sum = unary("sum", (expr, table) => Array.isArray(table) ? table.reduce((prev, curr) => prev + executeAggr(expr, curr), 0) : Array.from(executeEval(table, expr)).reduce((prev, curr) => prev + curr, 0), Type.Number);
Eval2.avg = unary("avg", (expr, table) => {
  if (Array.isArray(table))
    return table.reduce((prev, curr) => prev + executeAggr(expr, curr), 0) / table.length;
  else {
    const array = Array.from(executeEval(table, expr));
    return array.reduce((prev, curr) => prev + curr, 0) / array.length;
  }
}, Type.Number);
Eval2.max = unary("max", (expr, table) => Array.isArray(table) ? table.map((data) => executeAggr(expr, data)).reduce((x, y) => x > y ? x : y, -Infinity) : Array.from(executeEval(table, expr)).reduce((x, y) => x > y ? x : y, -Infinity), (expr) => unwrapAggr(expr, Type.Number));
Eval2.min = unary("min", (expr, table) => Array.isArray(table) ? table.map((data) => executeAggr(expr, data)).reduce((x, y) => x < y ? x : y, Infinity) : Array.from(executeEval(table, expr)).reduce((x, y) => x < y ? x : y, Infinity), (expr) => unwrapAggr(expr, Type.Number));
Eval2.count = unary("count", (expr, table) => new Set(table.map((data) => executeAggr(expr, data))).size, Type.Number);
defineProperty2(Eval2, "length", unary("length", (expr, table) => Array.isArray(table) ? table.map((data) => executeAggr(expr, data)).length : Array.from(executeEval(table, expr)).length, Type.Number));
operators.$object = (field, table) => mapValues3(field, (value) => executeAggr(value, table));
Eval2.object = (fields) => {
  if (fields.$model) {
    const modelFields = Object.entries(fields.$model.fields);
    const prefix = fields.$prefix;
    fields = Object.fromEntries(modelFields.filter(([, field]) => Field.available(field)).filter(([path]) => path.startsWith(prefix)).map(([k]) => [k.slice(prefix.length), fields[k.slice(prefix.length)]]));
    return Eval2("object", fields, Type.Object(mapValues3(fields, (value) => Type.fromTerm(value))));
  }
  return Eval2("object", fields, Type.Object(mapValues3(fields, (value) => Type.fromTerm(value))));
};
Eval2.array = unary("array", (expr, table) => Array.isArray(table) ? table.map((data) => executeAggr(expr, data)).filter((x) => !expr[Type.kType]?.ignoreNull || !isEmpty(x)) : Array.from(executeEval(table, expr)).filter((x) => !expr[Type.kType]?.ignoreNull || !isEmpty(x)), (expr) => Type.Array(Type.fromTerm(expr)));
Eval2.exec = unary("exec", (expr, data) => expr.driver.executeSelection(expr, data), (expr) => Type.fromTerm(expr.args[0]));
function getRecursive(args, data) {
  if (typeof args === "string") {
    return getRecursive(["_", args], data);
  }
  const [ref, path] = args;
  let value = data[ref];
  if (!value)
    return value;
  if (path in value)
    return value[path];
  const prefix = Object.keys(value).find((s) => path.startsWith(s + ".")) || path.split(".", 1)[0];
  const rest = path.slice(prefix.length + 1).split(".").filter(Boolean);
  rest.unshift(prefix);
  for (const key of rest) {
    value = value[key];
    if (!value)
      return value;
  }
  return value;
}
__name(getRecursive, "getRecursive");
function executeEvalExpr(expr, data) {
  for (const key in expr) {
    if (key in operators) {
      return operators[key](expr[key], data);
    }
  }
  return expr;
}
__name(executeEvalExpr, "executeEvalExpr");
function executeAggr(expr, data) {
  if (typeof expr === "string") {
    return getRecursive(expr, data);
  }
  return executeEvalExpr(expr, data);
}
__name(executeAggr, "executeAggr");
function executeEval(data, expr) {
  if (isComparable(expr) || isNullable3(expr)) {
    return expr;
  }
  if (Array.isArray(expr)) {
    return expr.map((item) => executeEval(data, item));
  }
  return executeEvalExpr(expr, data);
}
__name(executeEval, "executeEval");
function executeUpdate(data, update, ref) {
  for (const key in update) {
    let root = data;
    const path = key.split(".");
    const last = path.pop();
    for (const key2 of path) {
      root = root[key2] ||= {};
    }
    root[last] = executeEval({ [ref]: data, _: data }, update[key]);
  }
  return data;
}
__name(executeUpdate, "executeUpdate");

// src/utils.ts
function isComparable(value) {
  return typeof value === "string" || typeof value === "number" || typeof value === "boolean" || typeof value === "bigint" || value instanceof Date;
}
__name(isComparable, "isComparable");
function isFlat(value) {
  return !value || typeof value !== "object" || isEvalExpr(value) || Object.keys(value).length === 0 || Array.isArray(value) || value instanceof Date || value instanceof RegExp || Binary2.isSource(value);
}
__name(isFlat, "isFlat");
var letters = "abcdefghijklmnopqrstuvwxyz";
function randomId() {
  return Array(8).fill(0).map(() => letters[Math.floor(Math.random() * letters.length)]).join("");
}
__name(randomId, "randomId");
function makeRegExp(source, flags) {
  return source instanceof RegExp && !flags ? source : new RegExp(source.source ?? source, flags ?? source.flags);
}
__name(makeRegExp, "makeRegExp");
function unravel(source, init) {
  const result = {};
  for (const key in source) {
    let node = result;
    const segments = key.split(".").reverse();
    for (let index = segments.length - 1; index > 0; index--) {
      const segment = segments[index];
      node = node[segment] ??= {};
      if (init)
        node = init(node);
    }
    node[segments[0]] = source[key];
  }
  return result;
}
__name(unravel, "unravel");
function flatten(source, prefix = "", ignore = isFlat) {
  const result = {};
  for (const key in source) {
    const value = source[key];
    if (ignore(value)) {
      result[`${prefix}${key}`] = value;
    } else {
      Object.assign(result, flatten(value, `${prefix}${key}.`, ignore));
    }
  }
  return result;
}
__name(flatten, "flatten");
function getCell(row, path) {
  if (path in row)
    return row[path];
  if (path.includes(".")) {
    const index = path.indexOf(".");
    return getCell(row[path.slice(0, index)] ?? {}, path.slice(index + 1));
  } else {
    return row[path];
  }
}
__name(getCell, "getCell");
function isEmpty(value) {
  if (isNullable4(value))
    return true;
  if (typeof value !== "object")
    return false;
  for (const key in value) {
    if (!isEmpty(value[key]))
      return false;
  }
  return true;
}
__name(isEmpty, "isEmpty");

// src/selection.ts
import { defineProperty as defineProperty3, filterKeys as filterKeys2, mapValues as mapValues4 } from "cosmokit";
var createRow = /* @__PURE__ */ __name((ref, expr = {}, prefix = "", model) => new Proxy(expr, {
  get(target, key) {
    if (key === "$prefix")
      return prefix;
    if (key === "$model")
      return model;
    if (typeof key === "symbol" || key in target || key.startsWith("$"))
      return Reflect.get(target, key);
    let type;
    const field = model?.fields[prefix + key];
    if (Type.getInner(expr?.[Type.kType], key)) {
      type = Type.getInner(expr?.[Type.kType], key);
    } else if (field) {
      type = Type.fromField(field);
    } else if (Object.keys(model?.fields).some((k) => k.startsWith(`${prefix}${key}.`))) {
      type = Type.Object(Object.fromEntries(Object.entries(model?.fields).filter(([k]) => k.startsWith(`${prefix}${key}`)).map(([k, field2]) => [k.slice(prefix.length + key.length + 1), Type.fromField(field2)])));
    } else {
      type = model?.getType(`${prefix}${key}`) ?? Type.fromField("expr");
    }
    const row = createRow(ref, Eval2("", [ref, `${prefix}${key}`], type), `${prefix}${key}.`, model);
    if (!field && Object.keys(model?.fields).some((k) => k.startsWith(`${prefix}${key}.`))) {
      return createRow(ref, Eval2.object(row), `${prefix}${key}.`, model);
    } else {
      return row;
    }
  }
}), "createRow");
var Executable = class {
  static {
    __name(this, "Executable");
  }
  row;
  model;
  driver;
  constructor(driver, payload) {
    Object.assign(this, payload);
    defineProperty3(this, "driver", driver);
    defineProperty3(this, "model", driver.model(this.table));
    defineProperty3(this, "row", createRow(this.ref, {}, "", this.model));
  }
  resolveQuery(query = {}) {
    if (typeof query === "function") {
      const expr = query(this.row);
      return expr["$expr"] ? expr : isEvalExpr(expr) ? { $expr: expr } : expr;
    }
    if (Array.isArray(query) || query instanceof RegExp || ["string", "number", "bigint"].includes(typeof query)) {
      const { primary } = this.model;
      if (Array.isArray(primary)) {
        throw new TypeError("invalid shorthand for composite primary key");
      }
      return { [primary]: query };
    }
    return query;
  }
  resolveField(field) {
    if (typeof field === "string") {
      return this.row[field];
    } else if (typeof field === "function") {
      return field(this.row);
    } else {
      throw new TypeError("invalid field definition");
    }
  }
  resolveFields(fields) {
    if (typeof fields === "string")
      fields = [fields];
    if (Array.isArray(fields)) {
      const modelFields = Object.keys(this.model.fields);
      const entries = fields.flatMap((key) => {
        if (this.model.fields[key])
          return [[key, this.row[key]]];
        else if (modelFields.some((path) => path.startsWith(key + "."))) {
          return modelFields.filter((path) => path.startsWith(key + ".")).map((path) => [path, this.row[path]]);
        }
        return [[key, key.split(".").reduce((row, k) => row[k], this.row)]];
      });
      return Object.fromEntries(entries);
    } else {
      const entries = Object.entries(fields).flatMap(([key, field]) => {
        const expr = this.resolveField(field);
        if (expr["$object"] && !Type.fromTerm(expr).ignoreNull) {
          return Object.entries(expr["$object"]).map(([key2, expr2]) => [`${key}.${key2}`, expr2]);
        }
        return [[key, expr]];
      });
      return Object.fromEntries(entries);
    }
  }
  async execute() {
    await this.driver.database.prepared();
    await this.driver._ensureSession();
    return this.driver[this.type](this, ...this.args);
  }
};
var Selection = class _Selection extends Executable {
  static {
    __name(this, "Selection");
  }
  tables = {};
  constructor(driver, table, query) {
    super(driver, {
      type: "get",
      ref: randomId(),
      table,
      query: null,
      args: [{ sort: [], limit: Infinity, offset: 0, group: void 0, having: Eval2.and(), optional: {} }]
    });
    this.tables[this.ref] = this.model;
    this.query = this.resolveQuery(query);
    if (typeof table !== "string") {
      Object.assign(this.tables, table.tables);
    }
  }
  where(query) {
    this.query.$and ||= [];
    this.query.$and.push(this.resolveQuery(query));
    return this;
  }
  limit(...args) {
    if (args.length > 1)
      this.offset(args.shift());
    this.args[0].limit = args[0];
    return this;
  }
  offset(offset) {
    this.args[0].offset = offset;
    return this;
  }
  orderBy(field, direction = "asc") {
    this.args[0].sort.push([this.resolveField(field), direction]);
    return this;
  }
  groupBy(fields, ...args) {
    this.args[0].fields = this.resolveFields(fields);
    this.args[0].group = Object.keys(this.args[0].fields);
    const extra = typeof args[0] === "function" ? void 0 : args.shift();
    Object.assign(this.args[0].fields, this.resolveFields(extra || {}));
    if (args[0])
      this.having(args[0]);
    return new _Selection(this.driver, this);
  }
  having(query) {
    this.args[0].having["$and"].push(this.resolveField(query));
    return this;
  }
  project(fields) {
    this.args[0].fields = this.resolveFields(fields);
    return new _Selection(this.driver, this);
  }
  join(name, selection, callback = () => Eval2.and(), optional = false) {
    const fields = Object.fromEntries(Object.entries(this.model.fields).filter(([key, field]) => Field.available(field) && !key.startsWith(name + ".")).map(([key]) => [key, (row) => getCell(row[this.ref], key)]));
    const joinFields = Object.fromEntries(Object.entries(selection.model.fields).filter(([key, field]) => Field.available(field) || Field.available(this.model.fields[`${name}.${key}`])).map(([key]) => [
      key,
      (row) => Field.available(this.model.fields[`${name}.${key}`]) ? getCell(row[this.ref], `${name}.${key}`) : getCell(row[name], key)
    ]));
    if (optional) {
      return this.driver.database.join({ [this.ref]: this, [name]: selection }, (t) => callback(t[this.ref], t[name]), { [this.ref]: false, [name]: true }).project({ ...fields, [name]: (row) => Eval2.ignoreNull(Eval2.object(mapValues4(joinFields, (x) => x(row)))) });
    } else {
      return this.driver.database.join({ [this.ref]: this, [name]: selection }, (t) => callback(t[this.ref], t[name])).project({ ...fields, [name]: (row) => Eval2.ignoreNull(Eval2.object(mapValues4(joinFields, (x) => x(row)))) });
    }
  }
  _action(type, ...args) {
    return new Executable(this.driver, { ...this, type, args });
  }
  evaluate(callback) {
    const selection = new _Selection(this.driver, this);
    if (!callback)
      callback = /* @__PURE__ */ __name((row) => Eval2.array(Eval2.object(row)), "callback");
    const expr = Array.isArray(callback) ? Eval2.select(...callback.map((x) => this.resolveField(x))) : this.resolveField(callback);
    if (isAggrExpr(expr))
      defineProperty3(expr, Type.kType, Type.Array(Type.fromTerm(expr)));
    return Eval2.exec(selection._action("eval", expr));
  }
  async execute(cursor) {
    if (typeof cursor === "function") {
      const selection = new _Selection(this.driver, this);
      return selection._action("eval", this.resolveField(cursor)).execute();
    }
    if (Array.isArray(cursor)) {
      cursor = { fields: cursor };
    } else if (!cursor) {
      cursor = {};
    }
    if (cursor.fields)
      this.project(cursor.fields);
    if (cursor.limit !== void 0)
      this.limit(cursor.limit);
    if (cursor.offset !== void 0)
      this.offset(cursor.offset);
    if (cursor.sort) {
      for (const field in cursor.sort) {
        this.orderBy(field, cursor.sort[field]);
      }
    }
    const rows = await super.execute();
    if (!cursor.fields)
      return rows;
    return rows.map((row) => {
      return filterKeys2(row, (key) => {
        return cursor.fields.some((k) => k === key || k.startsWith(`${key}.`));
      });
    });
  }
};
function executeSort(data, modifier, name) {
  const { limit, offset, sort } = modifier;
  data.sort((a, b) => {
    for (const [field, direction] of sort) {
      const sign = direction === "asc" ? 1 : -1;
      const x = executeEval({ [name]: a, _: a }, field);
      const y = executeEval({ [name]: b, _: b }, field);
      if (x < y)
        return -sign;
      if (x > y)
        return sign;
    }
    return 0;
  });
  return data.slice(offset, offset + limit);
}
__name(executeSort, "executeSort");

// src/database.ts
function mergeQuery(base, query) {
  if (typeof query === "function") {
    return (row) => {
      const q = query(row);
      return { $expr: true, ...base, ...q.$expr ? q : { $expr: q } };
    };
  } else {
    return (_) => ({ $expr: true, ...base, ...query });
  }
}
__name(mergeQuery, "mergeQuery");
var Database = class _Database extends Service {
  static {
    __name(this, "Database");
  }
  static [Service.provide] = "model";
  static [Service.immediate] = true;
  static transact = Symbol("minato.transact");
  static migrate = Symbol("minato.migrate");
  tables = /* @__PURE__ */ Object.create(null);
  drivers = [];
  types = /* @__PURE__ */ Object.create(null);
  _driver;
  stashed = /* @__PURE__ */ new Set();
  prepareTasks = /* @__PURE__ */ Object.create(null);
  migrateTasks = /* @__PURE__ */ Object.create(null);
  async connect(driver, ...args) {
    this.ctx.plugin(driver, args[0]);
    await this.ctx.start();
  }
  refresh() {
    for (const name in this.tables) {
      this.prepareTasks[name] = this.prepare(name);
    }
  }
  async prepared() {
    if (this[_Database.migrate])
      return;
    await Promise.all(Object.values(this.prepareTasks));
  }
  getDriver(table) {
    if (table instanceof Selection)
      return table.driver;
    const model = this.tables[table];
    if (!model)
      throw new Error(`cannot resolve table "${table}"`);
    return model.ctx?.get("database")?._driver;
  }
  async prepare(name) {
    this.stashed.add(name);
    await this.prepareTasks[name];
    await Promise.resolve();
    if (!this.stashed.delete(name))
      return;
    const driver = this.getDriver(name);
    if (!driver)
      return;
    const { fields } = driver.model(name);
    Object.values(fields).forEach((field) => field?.transformers?.forEach((x) => driver.define(x)));
    await driver.prepare(name);
  }
  extend(name, fields, config = {}) {
    let model = this.tables[name];
    if (!model) {
      model = this.tables[name] = new Model(name);
    }
    Object.entries(fields).forEach(([key, field]) => {
      const transformer = [];
      this.parseField(field, transformer, void 0, (value) => field = fields[key] = value);
      if (typeof field === "object")
        field.transformers = transformer;
    });
    model.extend(fields, config);
    if (makeArray2(model.primary).every((key) => key in fields)) {
      defineProperty4(model, "ctx", this.ctx);
    }
    Object.entries(fields).forEach(([key, def]) => {
      if (!Relation.Type.includes(def.type))
        return;
      const subprimary = !def.fields && makeArray2(model.primary).includes(key);
      const [relation, inverse] = Relation.parse(def, key, model, this.tables[def.table ?? key], subprimary);
      if (!this.tables[relation.table])
        throw new Error(`relation table ${relation.table} does not exist`);
      (model.fields[key] = Field.parse("expr")).relation = relation;
      if (def.target) {
        (this.tables[relation.table].fields[def.target] ??= Field.parse("expr")).relation = inverse;
      }
      if (relation.type === "oneToOne" || relation.type === "manyToOne") {
        relation.fields.forEach((x, i) => {
          model.fields[x] ??= { ...this.tables[relation.table].fields[relation.references[i]] };
          if (!relation.required) {
            model.fields[x].nullable = true;
            model.fields[x].initial = null;
          }
        });
      } else if (relation.type === "manyToMany") {
        const assocTable = Relation.buildAssociationTable(relation.table, name);
        if (this.tables[assocTable])
          return;
        const shared = Object.entries(relation.shared).map(([x, y]) => [Relation.buildSharedKey(x, y), model.fields[x].deftype]);
        const fields2 = relation.fields.map((x) => [Relation.buildAssociationKey(x, name), model.fields[x].deftype]);
        const references = relation.references.map((x, i) => [Relation.buildAssociationKey(x, relation.table), fields2[i][1]]);
        this.extend(assocTable, {
          ...Object.fromEntries([...shared, ...fields2, ...references]),
          [name]: {
            type: "manyToOne",
            table: name,
            fields: [...shared, ...fields2].map((x) => x[0]),
            references: [...Object.keys(relation.shared), ...relation.fields]
          },
          [relation.table]: {
            type: "manyToOne",
            table: relation.table,
            fields: [...shared, ...references].map((x) => x[0]),
            references: [...Object.values(relation.shared), ...relation.references]
          }
        }, {
          primary: [...shared, ...fields2, ...references].map((x) => x[0])
        });
      }
    });
    if (Array.isArray(model.primary) && model.primary.every((key) => model.fields[key]?.relation)) {
      model.primary = deduplicate(model.primary.map((key) => model.fields[key].relation.fields).flat());
    }
    this.prepareTasks[name] = this.prepare(name);
    this.ctx.emit("model", name);
  }
  _parseField(field, transformers = [], setInitial, setField) {
    if (field === "object") {
      setInitial?.({});
      setField?.({ type: "json", initial: {} });
      return Type.Object();
    } else if (field === "array") {
      setInitial?.([]);
      setField?.({ type: "json", initial: [] });
      return Type.Array();
    } else if (typeof field === "string" && this.types[field]) {
      transformers.push({
        types: [field],
        load: this.types[field].load,
        dump: this.types[field].dump
      }, ...this.types[field].transformers ?? []);
      setInitial?.(this.types[field].initial);
      setField?.({ ...this.types[field], type: field });
      return Type.fromField(field);
    } else if (typeof field === "string") {
      setInitial?.(Field.getInitial(field.split("(")[0]));
      setField?.(field);
      return Type.fromField(field.split("(")[0]);
    } else if (typeof field === "object" && field.type === "object") {
      const inner = field.inner ? unravel(field.inner, (value) => (value.type = "object", value.inner ??= {})) : /* @__PURE__ */ Object.create(null);
      const initial = /* @__PURE__ */ Object.create(null);
      const res = Type.Object(mapValues5(inner, (x, k) => this.parseField(x, transformers, (value) => initial[k] = value)));
      setInitial?.(Field.getInitial("json", initial));
      setField?.({ initial: Field.getInitial("json", initial), ...field, deftype: "json", type: res });
      return res;
    } else if (typeof field === "object" && field.type === "array") {
      const res = field.inner ? Type.Array(this.parseField(field.inner, transformers)) : Type.Array();
      setInitial?.([]);
      setField?.({ initial: [], ...field, deftype: "json", type: res });
      return res;
    } else if (typeof field === "object" && this.types[field.type]) {
      transformers.push({
        types: [field.type],
        load: this.types[field.type].load,
        dump: this.types[field.type].dump
      }, ...this.types[field.type].transformers ?? []);
      setInitial?.(field.initial === void 0 ? this.types[field.type].initial : field.initial);
      setField?.({ initial: this.types[field.type].initial, ...field });
      return Type.fromField(field.type);
    } else {
      setInitial?.(Field.getInitial(field.type, field.initial));
      setField?.(field);
      return Type.fromField(field.type);
    }
  }
  parseField(field, transformers = [], setInitial, setField) {
    let midfield;
    let type = this._parseField(field, transformers, setInitial, (value) => (midfield = value, setField?.(value)));
    if (typeof field === "object" && field.load && field.dump) {
      if (type.inner)
        type = Type.fromField(this.define({ ...omit(midfield, ["load", "dump"]), type }));
      const name = this.define({ ...field, deftype: midfield.deftype, type: type.type });
      transformers.push({
        types: [name],
        load: field.load,
        dump: field.dump
      });
      setInitial?.(field.initial);
      setField?.({ ...field, deftype: midfield.deftype ?? this.types[type.type]?.deftype ?? type.type, initial: midfield.initial, type: name });
      return Type.fromField(name);
    }
    if (typeof midfield === "object")
      setField?.({ ...midfield, deftype: midfield.deftype ?? this.types[type.type]?.deftype ?? type?.type });
    return type;
  }
  define(name, field) {
    if (typeof name === "object") {
      field = name;
      name = void 0;
    }
    if (name && this.types[name])
      throw new Error(`type "${name}" already defined`);
    if (!name)
      while (this.types[name = "_define_" + randomId()])
        ;
    const transformers = [];
    const type = this._parseField(field, transformers, void 0, (value) => field = value);
    field.transformers = transformers;
    this.ctx.effect(() => {
      this.types[name] = { ...field };
      this.types[name].deftype ??= this.types[field.type]?.deftype ?? type.type;
      return () => delete this.types[name];
    });
    return name;
  }
  migrate(name, fields, callback) {
    this.extend(name, fields, { callback });
  }
  select(table, query, include) {
    let sel = new Selection(this.getDriver(table), table, query);
    if (typeof table !== "string")
      return sel;
    const whereOnly = include === null;
    const rawquery = typeof query === "function" ? query : () => query;
    const modelFields = this.tables[table].fields;
    if (include)
      include = filterKeys3(include, (key) => !!modelFields[key]?.relation);
    for (const key in { ...sel.query, ...sel.query.$not }) {
      if (modelFields[key]?.relation) {
        if (sel.query[key] === null && !modelFields[key].relation.required) {
          sel.query[key] = Object.fromEntries(modelFields[key].relation.references.map((k) => [k, null]));
        }
        if (sel.query[key] && typeof sel.query[key] !== "function" && typeof sel.query[key] === "object" && Object.keys(sel.query[key]).every((x) => modelFields[key].relation.fields.includes(`${key}.${x}`))) {
          Object.entries(sel.query[key]).forEach(([k, v]) => sel.query[`${key}.${k}`] = v);
          delete sel.query[key];
        }
        if (sel.query.$not?.[key] === null && !modelFields[key].relation.required) {
          sel.query.$not[key] = Object.fromEntries(modelFields[key].relation.references.map((k) => [k, null]));
        }
        if (sel.query.$not?.[key] && typeof sel.query.$not[key] !== "function" && typeof sel.query.$not[key] === "object" && Object.keys(sel.query.$not[key]).every((x) => modelFields[key].relation.fields.includes(`${key}.${x}`))) {
          Object.entries(sel.query.$not[key]).forEach(([k, v]) => sel.query.$not[`${key}.${k}`] = v);
          delete sel.query.$not[key];
        }
        if (!include || !Object.getOwnPropertyNames(include).includes(key)) {
          (include ??= {})[key] = true;
        }
      }
    }
    sel.query = omit(sel.query, Object.keys(include ?? {}));
    if (Object.keys(sel.query.$not ?? {}).length) {
      sel.query.$not = omit(sel.query.$not, Object.keys(include ?? {}));
      if (Object.keys(sel.query.$not).length === 0)
        Reflect.deleteProperty(sel.query, "$not");
    }
    if (include && typeof include === "object") {
      if (typeof table !== "string")
        throw new Error("cannot include relations on derived selection");
      const extraFields = [];
      const applyQuery = /* @__PURE__ */ __name((sel2, key) => {
        const query2 = rawquery(sel2.row);
        const relquery = query2[key] !== void 0 ? query2[key] : query2.$not?.[key] !== void 0 ? { $not: query2.$not?.[key] } : void 0;
        return relquery === void 0 ? sel2 : sel2.where(this.transformRelationQuery(table, sel2.row, key, relquery));
      }, "applyQuery");
      for (const key in include) {
        if (!include[key] || !modelFields[key]?.relation)
          continue;
        const relation = modelFields[key].relation;
        if (relation.type === "oneToOne" || relation.type === "manyToOne") {
          sel = whereOnly ? sel : sel.join(key, this.select(relation.table, {}, include[key]), (self, other) => Eval2.and(
            ...relation.fields.map((k, i) => Eval2.eq(self[k], other[relation.references[i]]))
          ), true);
          sel = applyQuery(sel, key);
        } else if (relation.type === "oneToMany") {
          sel = whereOnly ? sel : sel.join(key, this.select(relation.table, {}, include[key]), (self, other) => Eval2.and(
            ...relation.fields.map((k, i) => Eval2.eq(self[k], other[relation.references[i]]))
          ), true);
          sel = applyQuery(sel, key);
          sel = whereOnly ? sel : sel.groupBy([
            ...Object.entries(modelFields).filter(([k, field]) => !extraFields.some((x) => k.startsWith(`${x}.`)) && Field.available(field)).map(([k]) => k),
            ...extraFields
          ], {
            [key]: (row) => Eval2.ignoreNull(Eval2.array(row[key]))
          });
        } else if (relation.type === "manyToMany") {
          const assocTable = Relation.buildAssociationTable(relation.table, table);
          const references = relation.fields.map((x) => Relation.buildAssociationKey(x, table));
          const shared = Object.entries(relation.shared).map(([x, y]) => [Relation.buildSharedKey(x, y), {
            field: x,
            reference: y
          }]);
          sel = whereOnly ? sel : sel.join(key, this.select(assocTable, {}, { [relation.table]: include[key] }), (self, other) => Eval2.and(
            ...shared.map(([k, v]) => Eval2.eq(self[v.field], other[k])),
            ...relation.fields.map((k, i) => Eval2.eq(self[k], other[references[i]]))
          ), true);
          sel = applyQuery(sel, key);
          sel = whereOnly ? sel : sel.groupBy([
            ...Object.entries(modelFields).filter(([k, field]) => !extraFields.some((x) => k.startsWith(`${x}.`)) && Field.available(field)).map(([k]) => k),
            ...extraFields
          ], {
            [key]: (row) => Eval2.ignoreNull(Eval2.array(row[key][relation.table]))
          });
        }
        extraFields.push(key);
      }
    }
    return sel;
  }
  join(tables, query = (...args) => Eval2.and(), optional) {
    const oldTables = tables;
    if (Array.isArray(oldTables)) {
      tables = Object.fromEntries(oldTables.map((name) => [name, this.select(name)]));
    }
    let sels = mapValues5(tables, (t) => {
      return typeof t === "string" ? this.select(t) : t;
    });
    if (Object.keys(sels).length === 0)
      throw new Error("no tables to join");
    const drivers = new Set(Object.values(sels).map((sel2) => sel2.driver[_Database.transact] ?? sel2.driver));
    if (drivers.size !== 1)
      throw new Error("cannot join tables from different drivers");
    if (Object.keys(sels).length === 2 && (optional?.[0] || optional?.[Object.keys(sels)[0]])) {
      if (optional[1] || optional[Object.keys(sels)[1]])
        throw new Error("full join is not supported");
      sels = Object.fromEntries(Object.entries(sels).reverse());
    }
    const sel = new Selection([...drivers][0], sels);
    if (Array.isArray(oldTables)) {
      sel.args[0].having = Eval2.and(query(...oldTables.map((name) => sel.row[name])));
      sel.args[0].optional = Object.fromEntries(oldTables.map((name, index) => [name, optional?.[index]]));
    } else {
      sel.args[0].having = Eval2.and(query(sel.row));
      sel.args[0].optional = optional;
    }
    return this.select(sel);
  }
  async get(table, query, cursor) {
    let fields = Array.isArray(cursor) ? cursor : cursor?.fields;
    fields = fields ? Object.fromEntries(fields.map((x) => [x, true])) : cursor?.include;
    return this.select(table, query, fields).execute(cursor);
  }
  async eval(table, expr, query) {
    return this.select(table, query).execute(typeof expr === "function" ? expr : () => expr);
  }
  async set(table, query, update) {
    const rawupdate = typeof update === "function" ? update : () => update;
    let sel = this.select(table, query, null);
    if (typeof update === "function")
      update = update(sel.row);
    const primary = makeArray2(sel.model.primary);
    if (primary.some((key) => key in update)) {
      throw new TypeError(`cannot modify primary key`);
    }
    const relations = Object.entries(sel.model.fields).filter(([key, field]) => key in update && field.relation).map(([key, field]) => [key, field.relation]);
    if (relations.length) {
      return await this.ensureTransaction(async (database) => {
        const rows = await database.get(table, query);
        sel = database.select(table, query, null);
        let baseUpdate = omit(rawupdate(sel.row), relations.map(([key]) => key));
        baseUpdate = sel.model.format(baseUpdate);
        for (const [key] of relations) {
          await Promise.all(rows.map((row) => database.processRelationUpdate(table, row, key, rawupdate(row)[key])));
        }
        return Object.keys(baseUpdate).length === 0 ? {} : await sel._action("set", baseUpdate).execute();
      });
    }
    update = sel.model.format(update);
    if (Object.keys(update).length === 0)
      return {};
    return sel._action("set", update).execute();
  }
  async remove(table, query) {
    const sel = this.select(table, query, null);
    return sel._action("remove").execute();
  }
  async create(table, data) {
    const sel = this.select(table);
    if (!this.hasRelation(table, data)) {
      const { primary, autoInc } = sel.model;
      if (!autoInc) {
        const keys = makeArray2(primary);
        if (keys.some((key) => getCell(data, key) === void 0)) {
          throw new Error("missing primary key");
        }
      }
      return sel._action("create", sel.model.create(data)).execute();
    } else {
      return this.ensureTransaction((database) => database.createOrUpdate(table, data, false));
    }
  }
  async upsert(table, upsert, keys) {
    const sel = this.select(table);
    if (typeof upsert === "function")
      upsert = upsert(sel.row);
    upsert = upsert.map((item) => sel.model.format(item));
    keys = makeArray2(keys || sel.model.primary);
    return sel._action("upsert", upsert, keys).execute();
  }
  makeProxy(marker, getDriver) {
    const drivers = /* @__PURE__ */ new Map();
    const database = new Proxy(this, {
      get: (target, p, receiver) => {
        if (p === marker)
          return true;
        if (p !== "getDriver")
          return Reflect.get(target, p, receiver);
        return (name) => {
          const original = this.getDriver(name);
          let driver = drivers.get(original);
          if (!driver) {
            driver = getDriver?.(original, database) ?? new Proxy(original, {
              get: (target2, p2, receiver2) => {
                if (p2 === "database")
                  return database;
                return Reflect.get(target2, p2, receiver2);
              }
            });
            drivers.set(original, driver);
          }
          return driver;
        };
      }
    });
    return database;
  }
  withTransaction(callback) {
    return this.transact(callback);
  }
  async transact(callback) {
    if (this[_Database.transact])
      throw new Error("nested transactions are not supported");
    const finalTasks = [];
    const database = this.makeProxy(_Database.transact, (driver) => {
      let initialized = false, session;
      let _resolve;
      const sessionTask = new Promise((resolve) => _resolve = resolve);
      driver = new Proxy(driver, {
        get: (target, p, receiver) => {
          if (p === _Database.transact)
            return target;
          if (p === "database")
            return database;
          if (p === "session")
            return session;
          if (p === "_ensureSession")
            return () => sessionTask;
          return Reflect.get(target, p, receiver);
        }
      });
      finalTasks.push(driver.withTransaction((_session) => {
        if (initialized)
          initialTask = initialTaskFactory();
        initialized = true;
        _resolve(session = _session);
        return initialTask;
      }));
      return driver;
    });
    const initialTaskFactory = /* @__PURE__ */ __name(() => Promise.resolve().then(() => callback(database)), "initialTaskFactory");
    let initialTask = initialTaskFactory();
    return initialTask.catch(noop).finally(() => Promise.all(finalTasks));
  }
  async stopAll() {
    await Promise.all(this.drivers.splice(0, Infinity).map((driver) => driver.stop()));
  }
  async drop(table) {
    if (this[_Database.transact])
      throw new Error("cannot drop table in transaction");
    await this.getDriver(table).drop(table);
  }
  async dropAll() {
    if (this[_Database.transact])
      throw new Error("cannot drop table in transaction");
    await Promise.all(Object.values(this.drivers).map((driver) => driver.dropAll()));
  }
  async stats() {
    await this.prepared();
    const stats = { size: 0, tables: {} };
    await Promise.all(Object.values(this.drivers).map(async (driver) => {
      const { size = 0, tables } = await driver.stats();
      stats.size += size;
      Object.assign(stats.tables, tables);
    }));
    return stats;
  }
  ensureTransaction(callback) {
    if (this[_Database.transact]) {
      return callback(this);
    } else {
      return this.transact(callback);
    }
  }
  transformRelationQuery(table, row, key, query) {
    const relation = this.tables[table].fields[key].relation;
    const results = [];
    if (relation.type === "oneToOne" || relation.type === "manyToOne") {
      if (query === null) {
        results.push(Eval2.nin(
          relation.fields.map((x) => row[x]),
          this.select(relation.table).evaluate(relation.references)
        ));
      } else {
        results.push(Eval2.in(
          relation.fields.map((x) => row[x]),
          this.select(relation.table, query).evaluate(relation.references)
        ));
      }
    } else if (relation.type === "oneToMany") {
      if (query.$some) {
        results.push(Eval2.in(
          relation.fields.map((x) => row[x]),
          this.select(relation.table, query.$some).evaluate(relation.references)
        ));
      }
      if (query.$none) {
        results.push(Eval2.nin(
          relation.fields.map((x) => row[x]),
          this.select(relation.table, query.$none).evaluate(relation.references)
        ));
      }
      if (query.$every) {
        results.push(Eval2.nin(
          relation.fields.map((x) => row[x]),
          this.select(relation.table, Eval2.not(query.$every)).evaluate(relation.references)
        ));
      }
    } else if (relation.type === "manyToMany") {
      const assocTable = Relation.buildAssociationTable(table, relation.table);
      const fields = relation.fields.map((x) => Relation.buildAssociationKey(x, table));
      const references = relation.references.map((x) => Relation.buildAssociationKey(x, relation.table));
      if (query.$some) {
        const innerTable = this.select(relation.table, query.$some).evaluate(relation.references);
        const relTable = this.select(assocTable, (r) => Eval2.in(references.map((x) => r[x]), innerTable)).evaluate(fields);
        results.push(Eval2.in(relation.fields.map((x) => row[x]), relTable));
      }
      if (query.$none) {
        const innerTable = this.select(relation.table, query.$none).evaluate(relation.references);
        const relTable = this.select(assocTable, (r) => Eval2.in(references.map((x) => r[x]), innerTable)).evaluate(fields);
        results.push(Eval2.nin(relation.fields.map((x) => row[x]), relTable));
      }
      if (query.$every) {
        const innerTable = this.select(relation.table, Eval2.not(query.$every)).evaluate(relation.references);
        const relTable = this.select(assocTable, (r) => Eval2.in(references.map((x) => r[x]), innerTable)).evaluate(fields);
        results.push(Eval2.nin(relation.fields.map((x) => row[x]), relTable));
      }
    }
    return { $expr: Eval2.and(...results) };
  }
  async createOrUpdate(table, data, upsert = true) {
    const sel = this.select(table);
    data = { ...data };
    const tasks = [""];
    for (const key in data) {
      if (data[key] !== void 0 && this.tables[table].fields[key]?.relation) {
        const relation = this.tables[table].fields[key].relation;
        if (relation.type === "oneToOne" && relation.required)
          tasks.push(key);
        else if (relation.type === "oneToOne")
          tasks.unshift(key);
        else if (relation.type === "oneToMany")
          tasks.push(key);
        else if (relation.type === "manyToOne")
          tasks.unshift(key);
        else if (relation.type === "manyToMany")
          tasks.push(key);
      }
    }
    for (const key of [...tasks]) {
      if (!key) {
        const { primary, autoInc } = sel.model;
        const keys = makeArray2(primary);
        if (keys.some((key2) => isNullable5(getCell(data, key2)))) {
          if (!autoInc) {
            throw new Error("missing primary key");
          } else {
            delete data[primary];
            upsert = false;
          }
        }
        if (upsert) {
          await sel._action("upsert", [sel.model.format(omit(data, tasks))], keys).execute();
        } else {
          Object.assign(data, await sel._action("create", sel.model.create(omit(data, tasks))).execute());
        }
        continue;
      }
      const value = data[key];
      const relation = this.tables[table].fields[key].relation;
      if (relation.type === "oneToOne") {
        if (value.$literal) {
          data[key] = value.$literal;
          remove(tasks, key);
        } else if (value.$create || !isUpdateExpr(value)) {
          const result = await this.createOrUpdate(relation.table, {
            ...Object.fromEntries(relation.references.map((k, i) => [k, getCell(data, relation.fields[i])])),
            ...value.$create ?? value
          });
          if (!relation.required) {
            relation.references.forEach((k, i) => data[relation.fields[i]] = getCell(result, k));
          }
        } else if (value.$upsert) {
          await this.upsert(relation.table, [{
            ...Object.fromEntries(relation.references.map((k, i) => [k, getCell(data, relation.fields[i])])),
            ...value.$upsert
          }]);
          if (!relation.required) {
            relation.references.forEach((k, i) => data[relation.fields[i]] = getCell(value.$upsert, k));
          }
        } else if (value.$connect) {
          if (relation.required) {
            await this.set(
              relation.table,
              value.$connect,
              Object.fromEntries(relation.references.map((k, i) => [k, getCell(data, relation.fields[i])]))
            );
          } else {
            const result = relation.references.every((k) => value.$connect[k] !== void 0) ? [value.$connect] : await this.get(relation.table, value.$connect);
            if (result.length !== 1)
              throw new Error("related row not found or not unique");
            relation.references.forEach((k, i) => data[relation.fields[i]] = getCell(result[0], k));
          }
        }
      } else if (relation.type === "manyToOne") {
        if (value.$literal) {
          data[key] = value.$literal;
          remove(tasks, key);
        } else if (value.$create || !isUpdateExpr(value)) {
          const result = await this.createOrUpdate(relation.table, value.$create ?? value);
          relation.references.forEach((k, i) => data[relation.fields[i]] = getCell(result, k));
        } else if (value.$upsert) {
          await this.upsert(relation.table, [value.$upsert]);
          relation.references.forEach((k, i) => data[relation.fields[i]] = getCell(value.$upsert, k));
        } else if (value.$connect) {
          const result = relation.references.every((k) => value.$connect[k] !== void 0) ? [value.$connect] : await this.get(relation.table, value.$connect);
          if (result.length !== 1)
            throw new Error("related row not found or not unique");
          relation.references.forEach((k, i) => data[relation.fields[i]] = getCell(result[0], k));
        }
      } else if (relation.type === "oneToMany") {
        if (value.$create || Array.isArray(value)) {
          for (const item of makeArray2(value.$create ?? value)) {
            await this.createOrUpdate(relation.table, {
              ...Object.fromEntries(relation.references.map((k, i) => [k, getCell(data, relation.fields[i])])),
              ...item
            });
          }
        }
        if (value.$upsert) {
          await this.upsert(relation.table, makeArray2(value.$upsert).map((r) => ({
            ...Object.fromEntries(relation.references.map((k, i) => [k, getCell(data, relation.fields[i])])),
            ...r
          })));
        }
        if (value.$connect) {
          await this.set(
            relation.table,
            value.$connect,
            Object.fromEntries(relation.references.map((k, i) => [k, getCell(data, relation.fields[i])]))
          );
        }
      } else if (relation.type === "manyToMany") {
        const assocTable = Relation.buildAssociationTable(relation.table, table);
        const fields = relation.fields.map((x) => Relation.buildAssociationKey(x, table));
        const references = relation.references.map((x) => Relation.buildAssociationKey(x, relation.table));
        const shared = Object.entries(relation.shared).map(([x, y]) => [Relation.buildSharedKey(x, y), {
          field: x,
          reference: y
        }]);
        const result = [];
        if (value.$create || Array.isArray(value)) {
          for (const item of makeArray2(value.$create ?? value)) {
            result.push(await this.createOrUpdate(relation.table, {
              ...Object.fromEntries(shared.map(([, v]) => [v.reference, getCell(item, v.reference) ?? getCell(data, v.field)])),
              ...item
            }));
          }
        }
        if (value.$upsert) {
          const upsert2 = makeArray2(value.$upsert).map((r) => ({
            ...Object.fromEntries(shared.map(([, v]) => [v.reference, getCell(r, v.reference) ?? getCell(data, v.field)])),
            ...r
          }));
          await this.upsert(relation.table, upsert2);
          result.push(...upsert2);
        }
        if (value.$connect) {
          for (const item of makeArray2(value.$connect)) {
            if (references.every((k) => item[k] !== void 0))
              result.push(item);
            else
              result.push(...await this.get(relation.table, item));
          }
        }
        await this.upsert(assocTable, result.map((r) => ({
          ...Object.fromEntries(shared.map(([k, v]) => [k, getCell(r, v.reference) ?? getCell(data, v.field)])),
          ...Object.fromEntries(fields.map((k, i) => [k, getCell(data, relation.fields[i])])),
          ...Object.fromEntries(references.map((k, i) => [k, getCell(r, relation.references[i])]))
        })));
      }
    }
    return data;
  }
  async processRelationUpdate(table, row, key, value) {
    const model = this.tables[table], update = /* @__PURE__ */ Object.create(null);
    const relation = this.tables[table].fields[key].relation;
    if (relation.type === "oneToOne") {
      if (value === null) {
        value = relation.required ? { $remove: {} } : { $disconnect: {} };
      }
      if (typeof value === "object" && !isUpdateExpr(value)) {
        value = { $create: value };
      }
      if (value.$remove) {
        await this.remove(relation.table, Object.fromEntries(relation.references.map((k, i) => [k, getCell(row, relation.fields[i])])));
      }
      if (value.$disconnect) {
        if (relation.required) {
          await this.set(
            relation.table,
            mergeQuery(Object.fromEntries(relation.references.map((k, i) => [k, getCell(row, relation.fields[i])])), value.$disconnect),
            Object.fromEntries(relation.references.map((k, i) => [k, null]))
          );
        } else {
          Object.assign(update, Object.fromEntries(relation.fields.map((k, i) => [k, null])));
        }
      }
      if (value.$set || typeof value === "function") {
        await this.set(
          relation.table,
          Object.fromEntries(relation.references.map((k, i) => [k, getCell(row, relation.fields[i])])),
          value.$set ?? value
        );
      }
      if (value.$create) {
        const result = await this.createOrUpdate(relation.table, {
          ...Object.fromEntries(relation.references.map((k, i) => [k, getCell(row, relation.fields[i])])),
          ...value.$create
        });
        if (!relation.required) {
          Object.assign(update, Object.fromEntries(relation.fields.map((k, i) => [k, getCell(result, relation.references[i])])));
        }
      }
      if (value.$upsert) {
        await this.upsert(relation.table, makeArray2(value.$upsert).map((r) => ({
          ...Object.fromEntries(relation.references.map((k, i) => [k, getCell(row, relation.fields[i])])),
          ...r
        })));
        if (!relation.required) {
          Object.assign(update, Object.fromEntries(relation.fields.map((k, i) => [k, getCell(value.$upsert, relation.references[i])])));
        }
      }
      if (value.$connect) {
        if (relation.required) {
          await this.set(
            relation.table,
            value.$connect,
            Object.fromEntries(relation.references.map((k, i) => [k, getCell(row, relation.fields[i])]))
          );
        } else {
          const result = await this.get(relation.table, value.$connect);
          if (result.length !== 1)
            throw new Error("related row not found or not unique");
          Object.assign(update, Object.fromEntries(relation.fields.map((k, i) => [k, getCell(result[0], relation.references[i])])));
        }
      }
    } else if (relation.type === "manyToOne") {
      if (value === null) {
        value = { $disconnect: {} };
      }
      if (typeof value === "object" && !isUpdateExpr(value)) {
        value = { $create: value };
      }
      if (value.$remove) {
        await this.remove(relation.table, Object.fromEntries(relation.references.map((k, i) => [k, getCell(row, relation.fields[i])])));
      }
      if (value.$disconnect) {
        Object.assign(update, Object.fromEntries(relation.fields.map((k, i) => [k, null])));
      }
      if (value.$set || typeof value === "function") {
        await this.set(
          relation.table,
          Object.fromEntries(relation.references.map((k, i) => [k, getCell(row, relation.fields[i])])),
          value.$set ?? value
        );
      }
      if (value.$create) {
        const result = await this.createOrUpdate(relation.table, {
          ...Object.fromEntries(relation.references.map((k, i) => [k, getCell(row, relation.fields[i])])),
          ...value.$create
        });
        Object.assign(update, Object.fromEntries(relation.fields.map((k, i) => [k, getCell(result, relation.references[i])])));
      }
      if (value.$upsert) {
        await this.upsert(relation.table, makeArray2(value.$upsert).map((r) => ({
          ...Object.fromEntries(relation.references.map((k, i) => [k, getCell(row, relation.fields[i])])),
          ...r
        })));
        Object.assign(update, Object.fromEntries(relation.fields.map((k, i) => [k, getCell(value.$upsert, relation.references[i])])));
      }
      if (value.$connect) {
        const result = await this.get(relation.table, value.$connect);
        if (result.length !== 1)
          throw new Error("related row not found or not unique");
        Object.assign(update, Object.fromEntries(relation.fields.map((k, i) => [k, getCell(result[0], relation.references[i])])));
      }
    } else if (relation.type === "oneToMany") {
      if (Array.isArray(value)) {
        const $create = [], $upsert = [];
        value.forEach((item) => this.hasRelation(relation.table, item) ? $create.push(item) : $upsert.push(item));
        value = { $remove: {}, $create, $upsert };
      }
      if (value.$remove) {
        await this.remove(relation.table, mergeQuery(Object.fromEntries(relation.references.map((k, i) => [k, row[relation.fields[i]]])), value.$remove));
      }
      if (value.$disconnect) {
        await this.set(
          relation.table,
          mergeQuery(Object.fromEntries(relation.references.map((k, i) => [k, getCell(row, relation.fields[i])])), value.$disconnect),
          Object.fromEntries(relation.references.map((k, i) => [k, null]))
        );
      }
      if (value.$set || typeof value === "function") {
        for (const setexpr of makeArray2(value.$set ?? value)) {
          const [query, update2] = setexpr.update ? [setexpr.where, setexpr.update] : [{}, setexpr];
          await this.set(
            relation.table,
            mergeQuery(Object.fromEntries(relation.references.map((k, i) => [k, row[relation.fields[i]]])), query),
            update2
          );
        }
      }
      if (value.$create) {
        for (const item of makeArray2(value.$create)) {
          await this.createOrUpdate(relation.table, {
            ...Object.fromEntries(relation.references.map((k, i) => [k, getCell(row, relation.fields[i])])),
            ...item
          });
        }
      }
      if (value.$upsert) {
        await this.upsert(relation.table, makeArray2(value.$upsert).map((r) => ({
          ...Object.fromEntries(relation.references.map((k, i) => [k, getCell(row, relation.fields[i])])),
          ...r
        })));
      }
      if (value.$connect) {
        await this.set(
          relation.table,
          value.$connect,
          Object.fromEntries(relation.references.map((k, i) => [k, row[relation.fields[i]]]))
        );
      }
    } else if (relation.type === "manyToMany") {
      const assocTable = Relation.buildAssociationTable(table, relation.table);
      const fields = relation.fields.map((x) => Relation.buildAssociationKey(x, table));
      const references = relation.references.map((x) => Relation.buildAssociationKey(x, relation.table));
      const shared = Object.entries(relation.shared).map(([x, y]) => [Relation.buildSharedKey(x, y), {
        field: x,
        reference: y
      }]);
      if (Array.isArray(value)) {
        const $create = [], $upsert = [];
        value.forEach((item) => this.hasRelation(relation.table, item) ? $create.push(item) : $upsert.push(item));
        value = { $disconnect: {}, $create, $upsert };
      }
      if (value.$remove) {
        const rows = await this.select(assocTable, {
          ...Object.fromEntries(shared.map(([k, v]) => [k, getCell(row, v.field)])),
          ...Object.fromEntries(fields.map((k, i) => [k, getCell(row, relation.fields[i])])),
          [relation.table]: value.$remove
        }, null).execute();
        await this.remove(assocTable, (r) => Eval2.in(
          [...shared.map(([k, v]) => r[k]), ...fields.map((x) => r[x]), ...references.map((x) => r[x])],
          rows.map((r2) => [...shared.map(([k, v]) => getCell(r2, k)), ...fields.map((x) => getCell(r2, x)), ...references.map((x) => getCell(r2, x))])
        ));
        await this.remove(relation.table, (r) => Eval2.in(
          [...shared.map(([k, v]) => r[v.reference]), ...relation.references.map((x) => r[x])],
          rows.map((r2) => [...shared.map(([k, v]) => getCell(r2, k)), ...references.map((x) => getCell(r2, x))])
        ));
      }
      if (value.$disconnect) {
        const rows = await this.select(assocTable, {
          ...Object.fromEntries(shared.map(([k, v]) => [k, getCell(row, v.field)])),
          ...Object.fromEntries(fields.map((k, i) => [k, getCell(row, relation.fields[i])])),
          [relation.table]: value.$disconnect
        }, null).execute();
        await this.remove(assocTable, (r) => Eval2.in(
          [...shared.map(([k, v]) => r[k]), ...fields.map((x) => r[x]), ...references.map((x) => r[x])],
          rows.map((r2) => [...shared.map(([k, v]) => getCell(r2, k)), ...fields.map((x) => getCell(r2, x)), ...references.map((x) => getCell(r2, x))])
        ));
      }
      if (value.$set) {
        for (const setexpr of makeArray2(value.$set)) {
          const [query, update2] = setexpr.update ? [setexpr.where, setexpr.update] : [{}, setexpr];
          const rows = await this.select(assocTable, (r) => ({
            ...Object.fromEntries(shared.map(([k, v]) => [k, getCell(row, v.field)])),
            ...Object.fromEntries(fields.map((k, i) => [k, getCell(row, relation.fields[i])])),
            [relation.table]: query
          }), null).execute();
          await this.set(
            relation.table,
            (r) => Eval2.in(
              [...shared.map(([k, v]) => r[v.reference]), ...relation.references.map((x) => r[x])],
              rows.map((r2) => [...shared.map(([k, v]) => getCell(r2, k)), ...references.map((x) => getCell(r2, x))])
            ),
            update2
          );
        }
      }
      if (value.$create) {
        const result = [];
        for (const item of makeArray2(value.$create)) {
          result.push(await this.createOrUpdate(relation.table, {
            ...Object.fromEntries(relation.references.map((k, i) => [k, getCell(row, relation.fields[i])])),
            ...item
          }));
        }
        await this.upsert(assocTable, result.map((r) => ({
          ...Object.fromEntries(shared.map(([k, v]) => [k, getCell(row, v.field)])),
          ...Object.fromEntries(fields.map((k, i) => [k, row[relation.fields[i]]])),
          ...Object.fromEntries(references.map((k, i) => [k, r[relation.references[i]]]))
        })));
      }
      if (value.$upsert) {
        await this.upsert(relation.table, makeArray2(value.$upsert).map((r) => ({
          ...Object.fromEntries(relation.references.map((k, i) => [k, getCell(row, relation.fields[i])])),
          ...r
        })));
        await this.upsert(assocTable, makeArray2(value.$upsert).map((r) => ({
          ...Object.fromEntries(shared.map(([k, v]) => [k, getCell(row, v.field)])),
          ...Object.fromEntries(fields.map((k, i) => [k, row[relation.fields[i]]])),
          ...Object.fromEntries(references.map((k, i) => [k, r[relation.references[i]]]))
        })));
      }
      if (value.$connect) {
        const rows = await this.get(
          relation.table,
          mergeQuery(Object.fromEntries(shared.map(([k, v]) => [v.reference, getCell(row, v.field)])), value.$connect)
        );
        await this.upsert(assocTable, rows.map((r) => ({
          ...Object.fromEntries(shared.map(([k, v]) => [k, getCell(row, v.field)])),
          ...Object.fromEntries(fields.map((k, i) => [k, row[relation.fields[i]]])),
          ...Object.fromEntries(references.map((k, i) => [k, r[relation.references[i]]]))
        })));
      }
    }
    if (Object.keys(update).length) {
      await this.set(table, pick(model.format(row), makeArray2(model.primary)), update);
    }
  }
  hasRelation(table, data) {
    for (const key in data) {
      if (data[key] !== void 0 && this.tables[table].fields[key]?.relation)
        return true;
    }
    return false;
  }
};

// src/driver.ts
import { defineProperty as defineProperty5, mapValues as mapValues6, remove as remove2 } from "cosmokit";
import { Context as Context2, Service as Service2 } from "cordis";
var Driver = class {
  constructor(ctx, config) {
    this.ctx = ctx;
    this.config = config;
    this.database = ctx.model;
    this.logger = ctx.logger(this.constructor.name);
    ctx.on("ready", async () => {
      await Promise.resolve();
      await this.start();
      ctx.model.drivers.push(this);
      ctx.model.refresh();
      const database = Object.create(ctx.model);
      defineProperty5(database, "ctx", ctx);
      database._driver = this;
      database[Service2.tracker] = {
        associate: "database",
        property: "ctx"
      };
      ctx.set("database", Context2.associate(database, "database"));
    });
    ctx.on("dispose", async () => {
      remove2(ctx.model.drivers, this);
      await this.stop();
    });
  }
  static {
    __name(this, "Driver");
  }
  static inject = ["model"];
  database;
  logger;
  types = /* @__PURE__ */ Object.create(null);
  model(table) {
    if (typeof table === "string") {
      const model2 = this.database.tables[table];
      if (model2)
        return model2;
      throw new TypeError(`unknown table name "${table}"`);
    }
    if (table instanceof Selection) {
      if (!table.args[0].fields && (typeof table.table === "string" || table.table instanceof Selection)) {
        return table.model;
      }
      const model2 = new Model("temp");
      if (table.args[0].fields) {
        model2.fields = mapValues6(table.args[0].fields, (expr) => ({
          type: Type.fromTerm(expr)
        }));
      } else {
        model2.fields = mapValues6(table.model.fields, (field) => ({
          type: Type.fromField(field)
        }));
      }
      return model2;
    }
    const model = new Model("temp");
    for (const key in table) {
      const submodel = this.model(table[key]);
      for (const field in submodel.fields) {
        if (!Field.available(submodel.fields[field]))
          continue;
        model.fields[`${key}.${field}`] = {
          expr: Eval2("", [table[key].ref, field], Type.fromField(submodel.fields[field])),
          type: Type.fromField(submodel.fields[field])
        };
      }
    }
    return model;
  }
  async migrate(name, hooks) {
    const database = this.database.makeProxy(Database.migrate);
    const model = this.model(name);
    await (database.migrateTasks[name] = Promise.resolve(database.migrateTasks[name]).then(() => {
      return Promise.all([...model.migrations].map(async ([migrate, keys]) => {
        try {
          if (!hooks.before(keys))
            return;
          await migrate(database);
          hooks.after(keys);
        } catch (reason) {
          hooks.error(reason);
        }
      }));
    }).then(hooks.finalize).catch(hooks.error));
  }
  define(converter) {
    converter.types.forEach((type) => this.types[type] = converter);
  }
  async _ensureSession() {
  }
};

// src/error.ts
var RuntimeError = class _RuntimeError extends Error {
  constructor(code, message) {
    super(message || code.replace("-", " "));
    this.code = code;
  }
  static {
    __name(this, "RuntimeError");
  }
  name = "RuntimeError";
  static check(error, code) {
    if (!(error instanceof _RuntimeError))
      return false;
    return !code || error.message === code;
  }
};

// src/query.ts
import { isNullable as isNullable6 } from "cosmokit";
var queryOperators = {
  // logical
  $or: (query, data) => query.reduce((prev, query2) => prev || executeFieldQuery(query2, data), false),
  $and: (query, data) => query.reduce((prev, query2) => prev && executeFieldQuery(query2, data), true),
  $not: (query, data) => !executeFieldQuery(query, data),
  // existence
  $exists: (query, data) => query !== isNullable6(data),
  // comparison
  $eq: (query, data) => data.valueOf() === query.valueOf(),
  $ne: (query, data) => data.valueOf() !== query.valueOf(),
  $gt: (query, data) => data.valueOf() > query.valueOf(),
  $gte: (query, data) => data.valueOf() >= query.valueOf(),
  $lt: (query, data) => data.valueOf() < query.valueOf(),
  $lte: (query, data) => data.valueOf() <= query.valueOf(),
  // membership
  $in: (query, data) => query.includes(data),
  $nin: (query, data) => !query.includes(data),
  // regexp
  $regex: (query, data) => makeRegExp(query).test(data),
  $regexFor: (query, data) => typeof query === "string" ? makeRegExp(data).test(query) : makeRegExp(data, query.flags).test(query.input),
  // bitwise
  $bitsAllSet: (query, data) => (query & data) === query,
  $bitsAllClear: (query, data) => (query & data) === 0,
  $bitsAnySet: (query, data) => (query & data) !== 0,
  $bitsAnyClear: (query, data) => (query & data) !== query,
  // list
  $el: (query, data) => data.some((item) => executeFieldQuery(query, item)),
  $size: (query, data) => data.length === query
};
function executeFieldQuery(query, data) {
  if (Array.isArray(query)) {
    return query.includes(data);
  } else if (query instanceof RegExp) {
    return query.test(data);
  } else if (isComparable(query)) {
    return data.valueOf() === query.valueOf();
  } else if (isNullable6(query)) {
    return isNullable6(data);
  }
  for (const key in query) {
    if (key in queryOperators) {
      if (!queryOperators[key](query[key], data))
        return false;
    }
  }
  return true;
}
__name(executeFieldQuery, "executeFieldQuery");
function executeQuery(data, query, ref, env = {}) {
  const entries = Object.entries(query);
  return entries.every(([key, value]) => {
    if (key === "$and") {
      return value.reduce((prev, query2) => prev && executeQuery(data, query2, ref, env), true);
    } else if (key === "$or") {
      return value.reduce((prev, query2) => prev || executeQuery(data, query2, ref, env), false);
    } else if (key === "$not") {
      return !executeQuery(data, value, ref, env);
    } else if (key === "$expr") {
      return executeEval({ ...env, [ref]: data, _: data }, value);
    }
    try {
      const flattenQuery = isFlat(query[key]) ? { [key]: query[key] } : flatten(query[key], `${key}.`);
      return Object.entries(flattenQuery).every(([key2, value2]) => executeFieldQuery(value2, getCell(data, key2)));
    } catch {
      return false;
    }
  });
}
__name(executeQuery, "executeQuery");

// src/index.ts
import { Logger as Logger2, Schema, Schema as Schema2 } from "cordis";
var Types = Symbol("minato.types");
var Tables = Symbol("minato.tables");
var src_default = Database;
export {
  Eval2 as $,
  Database,
  Driver,
  Eval2 as Eval,
  Field,
  Logger2 as Logger,
  Model,
  Relation,
  RuntimeError,
  Schema,
  Selection,
  Tables,
  Type,
  Types,
  src_default as default,
  executeEval,
  executeQuery,
  executeSort,
  executeUpdate,
  flatten,
  getCell,
  hasSubquery,
  isAggrExpr,
  isComparable,
  isEmpty,
  isEvalExpr,
  isFlat,
  isUpdateExpr,
  makeRegExp,
  randomId,
  unravel,
  Schema2 as z
};
//# sourceMappingURL=index.mjs.map
