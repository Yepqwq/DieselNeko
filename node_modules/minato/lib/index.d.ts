import { Extract, Dict, Awaitable, MaybeArray, Intersect } from 'cosmokit';
import { Context, Logger, Service, Spread } from 'cordis';
export type Query<T = any> = Query.Expr<Flatten<T>> | Query.Shorthand<Indexable> | Selection.Callback<T, boolean>;
export namespace Query {
    export interface FieldExpr<T = any> {
        $or?: Field<T>[];
        $and?: Field<T>[];
        $not?: Field<T>;
        $exists?: boolean;
        $in?: Extract<T, Indexable, T[]>;
        $nin?: Extract<T, Indexable, T[]>;
        $eq?: Extract<T, Comparable>;
        $ne?: Extract<T, Comparable>;
        $gt?: Extract<T, Comparable>;
        $gte?: Extract<T, Comparable>;
        $lt?: Extract<T, Comparable>;
        $lte?: Extract<T, Comparable>;
        $el?: T extends (infer U)[] ? Field<U> : never;
        $size?: Extract<T, any[], number>;
        $regex?: Extract<T, string, string | RegExpLike>;
        $regexFor?: Extract<T, string, string | {
            input: string;
            flags?: string;
        }>;
        $bitsAllClear?: Extract<T, number>;
        $bitsAllSet?: Extract<T, number>;
        $bitsAnyClear?: Extract<T, number>;
        $bitsAnySet?: Extract<T, number>;
        $some?: T extends (infer U)[] ? Query<U> : never;
        $none?: T extends (infer U)[] ? Query<U> : never;
        $every?: T extends (infer U)[] ? Query<U> : never;
    }
    export interface LogicalExpr<T = any> {
        $or?: Expr<T>[];
        $and?: Expr<T>[];
        $not?: Expr<T>;
        /** @deprecated use query callback instead */
        $expr?: Eval.Term<boolean>;
    }
    export type Shorthand<T = any> = Extract<T, Comparable> | Extract<T, Indexable, T[]> | Extract<T, string, RegExp>;
    export type Field<T = any> = FieldExpr<T> | Shorthand<T>;
    type NonNullExpr<T> = T extends Values<AtomicTypes> | any[] ? Field<T> : T extends object ? Expr<Flatten<T>> | Selection.Callback<T, boolean> : Field<T>;
    export type Expr<T = any> = LogicalExpr<T> & {
        [K in keyof T]?: (undefined extends T[K] ? null : never) | NonNullExpr<Exclude<T[K], undefined>>;
    };
}
export function executeQuery(data: any, query: Query.Expr, ref: string, env?: any): boolean;
export namespace Eval {
    interface Static {
        exec<S, T>(value: Executable<S, T>): Expr<T>;
    }
}
export type Direction = 'asc' | 'desc';
export interface Modifier {
    limit: number;
    offset: number;
    sort: [Eval.Expr, Direction][];
    group?: string[];
    having: Eval.Expr<boolean>;
    fields?: Dict<Eval.Expr>;
    optional: Dict<boolean>;
}
declare namespace Executable {
    type Action = 'get' | 'set' | 'remove' | 'create' | 'upsert' | 'eval';
    interface Payload {
        type: Action;
        table: string | Selection | Dict<Selection.Immutable>;
        ref: string;
        query: Query.Expr;
        args: any[];
    }
}
declare interface Executable extends Executable.Payload {
}
declare class Executable<S = any, T = any> {
    readonly row: Row<S>;
    readonly model: Model;
    readonly driver: Driver;
    constructor(driver: Driver, payload: Executable.Payload);
    protected resolveQuery(query?: Query<S>): Query.Expr<S>;
    protected resolveField(field: FieldLike<S>): Eval.Expr;
    protected resolveFields(fields: string | string[] | Dict<FieldLike<S>>): any;
    execute(): Promise<T>;
}
type FieldLike<S = any> = FlatKeys<S> | Selection.Callback<S>;
type FieldType<S, T extends FieldLike<S>> = T extends FlatKeys<S> ? Flatten<S>[T] : T extends Selection.Callback<S> ? Eval<ReturnType<T>> : never;
type FieldMap<S, M extends Dict<FieldLike<S>>> = {
    [K in keyof M]: FieldType<S, M[K]>;
};
export namespace Selection {
    type Callback<S = any, T = any, A extends boolean = boolean> = (row: Row<S>) => Eval.Expr<T, A>;
    interface Immutable extends Executable, Executable.Payload {
        tables: Dict<Model>;
    }
    interface Mutable extends Executable, Executable.Payload {
        tables: Dict<Model>;
        table: string;
    }
}
export interface Selection extends Executable.Payload {
    args: [Modifier];
}
export class Selection<S = any> extends Executable<S, S[]> {
    tables: Dict<Model>;
    constructor(driver: Driver<any>, table: string | Selection | Dict<Selection.Immutable>, query?: Query);
    where(query: Query<S>): this;
    limit(limit: number): this;
    limit(offset: number, limit: number): this;
    offset(offset: number): this;
    orderBy(field: FieldLike<S>, direction?: Direction): this;
    groupBy<K extends FlatKeys<S>>(fields: K | readonly K[], query?: Selection.Callback<S, boolean>): Selection<FlatPick<S, K>>;
    groupBy<K extends FlatKeys<S>, U extends Dict<FieldLike<S>>>(fields: K | K[], extra?: U, query?: Selection.Callback<S, boolean>): Selection<FlatPick<S, K> & FieldMap<S, U>>;
    groupBy<K extends Dict<FieldLike<S>>>(fields: K, query?: Selection.Callback<S, boolean>): Selection<FieldMap<S, K>>;
    groupBy<K extends Dict<FieldLike<S>>, U extends Dict<FieldLike<S>>>(fields: K, extra?: U, query?: Selection.Callback<S, boolean>): Selection<FieldMap<S, K & U>>;
    having(query: Selection.Callback<S, boolean>): this;
    project<K extends FlatKeys<S>>(fields: K | readonly K[]): Selection<FlatPick<S, K>>;
    project<U extends Dict<FieldLike<S>>>(fields: U): Selection<FieldMap<S, U>>;
    join<K extends string, U>(name: K, selection: Selection<U>, callback?: (self: Row<S>, other: Row<U>) => Eval.Expr<boolean>, optional?: boolean): Selection<S & {
        [P in K]: U;
    }>;
    _action(type: Executable.Action, ...args: any[]): Executable<any, any>;
    evaluate<T>(callback: Selection.Callback<S, T, true>): Eval.Expr<T, true>;
    evaluate<K extends Keys<S>>(field: K): Eval.Expr<S[K][], false>;
    evaluate<K extends Keys<S>>(field: K[]): Eval.Expr<any[][], false>;
    evaluate(): Eval.Expr<S[], boolean>;
    execute(): Promise<S[]>;
    execute<K extends FlatKeys<S> = any>(cursor?: Driver.Cursor<K>): Promise<FlatPick<S, K>[]>;
    execute<T>(callback: Selection.Callback<S, T, true>): Promise<T>;
}
export function executeSort(data: any[], modifier: Modifier, name: string): any[];
export namespace Driver {
    interface Stats {
        size: number;
        tables: Dict<TableStats>;
    }
    interface TableStats {
        count: number;
        size: number;
    }
    type Cursor<K extends string = string, S = any, T extends Keys<S> = any> = K[] | CursorOptions<K, S, T>;
    interface CursorOptions<K extends string = string, S = any, T extends Keys<S> = any> {
        limit?: number;
        offset?: number;
        fields?: K[];
        sort?: Partial<Dict<Direction, FlatKeys<S[T]>>>;
        include?: Relation.Include<S[T], Values<S>>;
    }
    interface WriteResult {
        inserted?: number;
        matched?: number;
        modified?: number;
        removed?: number;
    }
    interface Transformer<S = any, T = any> {
        types: Field.Type<S>[];
        dump: (value: S | null) => T | null | void;
        load: (value: T | null) => S | null | void;
    }
}
export namespace Driver {
    type Constructor<T> = new (ctx: Context, config: T) => Driver<T>;
}
export abstract class Driver<T = any, C extends Context = Context> {
    ctx: C;
    config: T;
    static inject: string[];
    abstract start(): Promise<void>;
    abstract stop(): Promise<void>;
    abstract drop(table: string): Promise<void>;
    abstract dropAll(): Promise<void>;
    abstract stats(): Promise<Partial<Driver.Stats>>;
    abstract prepare(name: string): Promise<void>;
    abstract get(sel: Selection.Immutable, modifier: Modifier): Promise<any>;
    abstract eval(sel: Selection.Immutable, expr: Eval.Expr): Promise<any>;
    abstract set(sel: Selection.Mutable, data: Update): Promise<Driver.WriteResult>;
    abstract remove(sel: Selection.Mutable): Promise<Driver.WriteResult>;
    abstract create(sel: Selection.Mutable, data: any): Promise<any>;
    abstract upsert(sel: Selection.Mutable, data: any[], keys: string[]): Promise<Driver.WriteResult>;
    abstract withTransaction(callback: (session?: any) => Promise<void>): Promise<void>;
    database: Database<any, any, C>;
    logger: Logger;
    types: Dict<Driver.Transformer>;
    constructor(ctx: C, config: T);
    model<S = any>(table: string | Selection.Immutable | Dict<string | Selection.Immutable>): Model<S>;
    protected migrate(name: string, hooks: MigrationHooks): Promise<void>;
    define<S, T>(converter: Driver.Transformer<S, T>): void;
    _ensureSession(): Promise<void>;
}
export interface MigrationHooks {
    before: (keys: string[]) => boolean;
    after: (keys: string[]) => void;
    finalize: () => Awaitable<void>;
    error: (reason: any) => void;
}
declare const Primary: unique symbol;
export type Primary = (string | number) & {
    [Primary]: true;
};
export namespace Relation {
    const Marker: unique symbol;
    export type Marker = {
        [Marker]: true;
    };
    export const Type: readonly ["oneToOne", "oneToMany", "manyToOne", "manyToMany"];
    export type Type = typeof Type[number];
    export interface Config<S extends any = any, T extends Keys<S> = Keys<S>, K extends string = string> {
        type: Type;
        table: T;
        references: Keys<S[T]>[];
        fields: K[];
        shared: Record<K, Keys<S[T]>>;
        required: boolean;
    }
    export interface Definition<K extends string = string> {
        type: 'oneToOne' | 'manyToOne' | 'manyToMany';
        table?: string;
        target?: string;
        references?: MaybeArray<string>;
        fields?: MaybeArray<K>;
        shared?: MaybeArray<K> | Partial<Record<K, string>>;
    }
    export type Include<T, S> = boolean | {
        [P in keyof T]?: T[P] extends MaybeArray<infer U> | undefined ? U extends S ? Include<U, S> : never : never;
    };
    export type SetExpr<S extends object = any> = ((row: Row<S>) => Update<S>) | {
        where: Query.Expr<Flatten<S>> | Selection.Callback<S, boolean>;
        update: Row.Computed<S, Update<S>>;
    };
    export interface Modifier<T extends object = any, S extends any = any> {
        $create?: MaybeArray<Create<T, S>>;
        $upsert?: MaybeArray<DeepPartial<T>>;
        $set?: MaybeArray<SetExpr<T>>;
        $remove?: Query.Expr<Flatten<T>> | Selection.Callback<T, boolean>;
        $connect?: Query.Expr<Flatten<T>> | Selection.Callback<T, boolean>;
        $disconnect?: Query.Expr<Flatten<T>> | Selection.Callback<T, boolean>;
    }
    export function buildAssociationTable(...tables: [string, string]): string;
    export function buildAssociationKey(key: string, table: string): string;
    export function buildSharedKey(field: string, reference: string): string;
    export function parse(def: Definition, key: string, model: Model, relmodel: Model, subprimary?: boolean): [Config, Config];
}
export interface Field<T = any> {
    type: Type<T>;
    deftype?: Field.Type<T>;
    length?: number;
    nullable?: boolean;
    initial?: T;
    precision?: number;
    scale?: number;
    expr?: Eval.Expr;
    legacy?: string[];
    deprecated?: boolean;
    relation?: Relation.Config;
    transformers?: Driver.Transformer[];
}
export namespace Field {
    export const number: Type[];
    export const string: Type[];
    export const boolean: Type[];
    export const date: Type[];
    export const object: Type[];
    export type Type<T = any> = T extends Primary ? 'primary' : T extends number ? 'integer' | 'unsigned' | 'float' | 'double' | 'decimal' : T extends string ? 'char' | 'string' | 'text' : T extends boolean ? 'boolean' : T extends Date ? 'timestamp' | 'date' | 'time' : T extends ArrayBuffer ? 'binary' : T extends bigint ? 'bigint' : T extends unknown[] ? 'list' | 'json' | 'oneToMany' | 'manyToMany' : T extends object ? 'json' | 'oneToOne' | 'manyToOne' : 'expr';
    type Shorthand<S extends string> = S | `${S}(${any})`;
    export type Object<T = any, N = any> = {
        type: 'object';
        inner?: Extension<T, N>;
    } & Omit<Field<T>, 'type'>;
    export type Array<T = any, N = any> = {
        type: 'array';
        inner?: Literal<T, N> | Definition<T, N> | Transform<T, any, N>;
    } & Omit<Field<T[]>, 'type'>;
    export type Transform<S = any, T = S, N = any> = {
        type: Type<T> | Keys<N, T> | NewType<T> | 'object' | 'array';
        dump: (value: S | null) => T | null | void;
        load: (value: T | null) => S | null | void;
        initial?: S;
    } & Omit<Definition<T, N>, 'type' | 'initial'>;
    export type Definition<T, N> = (Omit<Field<T>, 'type'> & {
        type: Type<T> | Keys<N, T> | NewType<T>;
    }) | (T extends object ? Object<T, N> : never) | (T extends (infer I)[] ? Array<I, N> : never);
    export type Literal<T, N> = Shorthand<Type<T>> | Keys<N, T> | NewType<T> | (T extends object ? 'object' : never) | (T extends unknown[] ? 'array' : never);
    export type Parsable<T = any> = {
        type: Type<T> | Field<T>['type'];
    } & Omit<Field<T>, 'type'>;
    type MapField<O = any, N = any> = {
        [K in keyof O]?: Literal<O[K], N> | Definition<O[K], N> | Transform<O[K], any, N> | (O[K] extends object | undefined ? Relation.Definition<FlatKeys<O>> : never);
    };
    export type Extension<O = any, N = any> = MapField<Flatten<O>, N>;
    const NewType: unique symbol;
    export type NewType<T> = string & {
        [NewType]: T;
    };
    export type Config<O = any> = {
        [K in keyof O]?: Field<O[K]>;
    };
    export function parse(source: string | Parsable): Field;
    export function getInitial(type: Field.Type, initial?: any): any;
    export function available(field?: Field): boolean;
}
export namespace Model {
    type Migration<D = any> = (database: D) => Promise<void>;
    interface Config<K extends string = string> {
        callback?: Migration;
        autoInc: boolean;
        primary: MaybeArray<K>;
        unique: MaybeArray<K>[];
        foreign: {
            [P in K]?: [string, string];
        };
    }
}
export interface Model extends Model.Config {
}
export class Model<S = any> {
    name: string;
    ctx?: Context;
    fields: Field.Config<S>;
    migrations: Map<Model.Migration<any>, string[]>;
    private type;
    constructor(name: string);
    extend(fields: Field.Extension<S>, config?: Partial<Model.Config>): void;
    private checkIndex;
    resolveValue(field: string | Field | Type, value: any): any;
    resolveModel(obj: any, model?: Type): any;
    format(source: object, strict?: boolean, prefix?: string, result?: S): any;
    parse(source: object, strict?: boolean, prefix?: string, result?: S): any;
    create(data?: {}): any;
    avaiableFields(): import("cosmokit").Dict<Field<S[K]> | undefined, string>;
    getType(): Type<S>;
    getType(key: string): Type | undefined;
}
export interface Type<T = any, N = any> {
    [Type.kType]?: true;
    type: Field.Type<T>;
    inner?: T extends (infer I)[] ? Type<I, N> : Field.Type<T> extends 'json' ? {
        [key in keyof T]: Type<T[key], N>;
    } : never;
    array?: boolean;
    ignoreNull?: boolean;
}
export namespace Type {
    export const kType: unique symbol;
    export const Boolean: Type<boolean>;
    export const Number: Type<number>;
    export const String: Type<string>;
    type Extract<T> = T extends Type<infer I> ? I : T extends Field<infer I> ? I : T extends Field.Type<infer I> ? I : T extends Eval.Term<infer I> ? I : never;
    export type Object<T = any> = Type<T>;
    export const Object: <T extends unknown>(obj?: T) => Object<{ [K in keyof T]: Extract<T>; }>;
    export type Array<T = any> = Type<T[]>;
    export const Array: <T>(type?: Type<T>) => Type.Array<T>;
    export function fromPrimitive<T>(value: T): Type<T>;
    export function fromField<T, N>(field: any): Type<T, N>;
    export function fromTerm<T>(value: Eval.Term<T>, initial?: Type): Type<T>;
    export function fromTerms(values: Eval.Term<any>[], initial?: Type): Type;
    export function isType(value: any): value is Type;
    export function isArray(type: Type): boolean | undefined;
    export function getInner(type?: Type, key?: string): Type | undefined;
    export function transform(value: any, type: Type, callback: (value: any, type?: Type) => any): any;
}
export function isEvalExpr(value: any): value is Eval.Expr;
export const isUpdateExpr: (value: any) => boolean;
export function isAggrExpr(expr: Eval.Expr): boolean;
export function hasSubquery(value: any): boolean;
type UnevalObject<S> = {
    [K in keyof S]?: (undefined extends S[K] ? null : never) | Uneval<Exclude<S[K], undefined>, boolean>;
};
export type Uneval<U, A extends boolean> = U extends Values<AtomicTypes> ? Eval.Term<U, A> : U extends (infer T extends object)[] ? Relation.Modifier<T> | Eval.Array<T, A> : U extends object ? Eval.Expr<U, A> | UnevalObject<Flatten<U>> | Relation.Modifier<U> : any;
export type Eval<U> = U extends Values<AtomicTypes> ? U : U extends Eval.Expr<infer T> ? T : never;
declare const kExpr: unique symbol;
declare const kType: unique symbol;
declare const kAggr: unique symbol;
export namespace Eval {
    interface Expr<T = any, A extends boolean = boolean> {
        [kExpr]: true;
        [kType]?: T;
        [kAggr]?: A;
        [Type.kType]?: Type<T>;
    }
    type Any<A extends boolean = boolean> = Comparable | Expr<any, A>;
    type Term<T, A extends boolean = boolean> = T | Expr<T, A>;
    type Array<T, A extends boolean = boolean> = Term<T, A>[] | Expr<T[], A>;
    type Unary<S, R> = <T extends S, A extends boolean>(x: Term<T, A>) => Expr<R, A>;
    type Binary<S, R> = <T extends S, A extends boolean>(x: Term<T, A>, y: Term<T, A>) => Expr<R, A>;
    type Multi<S, R> = <T extends S, A extends boolean>(...args: Term<T, A>[]) => Expr<R, A>;
    interface Aggr<S> {
        <T extends S>(value: Term<T, false>): Expr<T, true>;
        <T extends S, A extends boolean>(value: Array<T, A>): Expr<T, A>;
    }
    interface Branch<T, A extends boolean> {
        case: Term<boolean, A>;
        then: Term<T, A>;
    }
    interface Static {
        <A extends boolean>(key: string, value: any, type: Type): Eval.Expr<any, A>;
        ignoreNull<T, A extends boolean>(value: Eval.Expr<T, A>): Eval.Expr<T, A>;
        select(...args: Any[]): Expr<any[], false>;
        query<T extends object>(row: Row<T>, query: Query.Expr<T>, expr?: Term<boolean>): Expr<boolean, false>;
        if<T extends Comparable, A extends boolean>(cond: Any<A>, vThen: Term<T, A>, vElse: Term<T, A>): Expr<T, A>;
        ifNull<T extends Comparable, A extends boolean>(...args: Term<T, A>[]): Expr<T, A>;
        switch<T, A extends boolean>(branches: Branch<T, A>[], vDefault: Term<T, A>): Expr<T, A>;
        add: Multi<number, number>;
        mul: Multi<number, number>;
        multiply: Multi<number, number>;
        sub: Binary<number, number>;
        subtract: Binary<number, number>;
        div: Binary<number, number>;
        divide: Binary<number, number>;
        mod: Binary<number, number>;
        modulo: Binary<number, number>;
        abs: Unary<number, number>;
        floor: Unary<number, number>;
        ceil: Unary<number, number>;
        round: Unary<number, number>;
        exp: Unary<number, number>;
        log<A extends boolean>(x: Term<number, A>, base?: Term<number, A>): Expr<number, A>;
        pow: Binary<number, number>;
        power: Binary<number, number>;
        random(): Expr<number, false>;
        eq: Multi<Comparable, boolean>;
        ne: Binary<Comparable, boolean>;
        gt: Binary<Comparable, boolean>;
        ge: Binary<Comparable, boolean>;
        gte: Binary<Comparable, boolean>;
        lt: Binary<Comparable, boolean>;
        le: Binary<Comparable, boolean>;
        lte: Binary<Comparable, boolean>;
        in<T extends Comparable, A extends boolean>(x: Term<T, A>, array: Array<T, A>): Expr<boolean, A>;
        in<T extends Comparable, A extends boolean>(x: Term<T, A>[], array: Array<T[], A>): Expr<boolean, A>;
        nin<T extends Comparable, A extends boolean>(x: Term<T, A>, array: Array<T, A>): Expr<boolean, A>;
        nin<T extends Comparable, A extends boolean>(x: Term<T, A>[], array: Array<T[], A>): Expr<boolean, A>;
        concat: Multi<string, string>;
        regex<A extends boolean>(x: Term<string, A>, y: RegExp): Expr<boolean, A>;
        regex<A extends boolean>(x: Term<string, A>, y: Term<string, A>, flags?: string): Expr<boolean, A>;
        and: Multi<boolean, boolean> & Multi<number, number> & Multi<bigint, bigint>;
        or: Multi<boolean, boolean> & Multi<number, number> & Multi<bigint, bigint>;
        not: Unary<boolean, boolean> & Unary<number, number> & Unary<bigint, bigint>;
        xor: Multi<boolean, boolean> & Multi<number, number> & Multi<bigint, bigint>;
        literal<T>(value: T, type?: Type<T> | Field.Type<T> | Field.NewType<T> | string): Expr<T, false>;
        number: Unary<any, number>;
        sum: Aggr<number>;
        avg: Aggr<number>;
        max: Aggr<Comparable>;
        min: Aggr<Comparable>;
        count(value: Any<false>): Expr<number, true>;
        length(value: Any<false>): Expr<number, true>;
        length<A extends boolean>(value: any[] | Expr<any[], A>): Expr<number, A>;
        object<T extends any>(row: Row.Cell<T>): Expr<T, false>;
        object<T extends any>(row: Row<T>): Expr<T, false>;
        array<T>(value: Expr<T, false>): Expr<T[], true>;
    }
}
export const Eval: Eval.Static;
export { Eval as $ };
export type Update<T = any> = UnevalObject<Flatten<T>>;
export function executeEval(data: any, expr: any): any;
export function executeUpdate(data: any, update: any, ref: string): any;
export type Values<S> = S[keyof S];
export type Keys<O, T = any> = Values<{
    [P in keyof O]: O[P] extends T | undefined ? P : never;
}> & string;
export type FlatKeys<O, T = any> = Keys<Flatten<O>, T>;
export type FlatPick<O, K extends FlatKeys<O>> = {
    [P in string & keyof O as K extends P | `${P}.${any}` ? P : never]: P extends K ? O[P] : FlatPick<O[P], Extract<K extends `${any}.${infer R}` ? R : never, FlatKeys<O[P]>>>;
};
export type DeepPartial<T> = T extends Values<AtomicTypes> ? T : T extends (infer U)[] ? DeepPartial<U>[] : T extends object ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : T;
export interface AtomicTypes {
    Number: number;
    String: string;
    Boolean: boolean;
    BigInt: bigint;
    Symbol: symbol;
    Date: Date;
    RegExp: RegExp;
    Function: Function;
    ArrayBuffer: ArrayBuffer;
    SharedArrayBuffer: SharedArrayBuffer;
}
export type Indexable = string | number | bigint;
export type Comparable = string | number | boolean | bigint | Date;
type FlatWrap<S, A extends 0[], P extends string> = {
    [K in P]: S;
} | (S extends Values<AtomicTypes> ? never : S extends any[] ? never : string extends keyof S ? never : A extends [0, ...infer R extends 0[]] ? FlatMap<S, R, `${P}.`> : never);
type FlatMap<S, T extends 0[], P extends string = ''> = Values<{
    [K in keyof S & string as `${P}${K}`]: FlatWrap<S[K], T, `${P}${K}`>;
}>;
type Sequence<N extends number, A extends 0[] = []> = A['length'] extends N ? A : Sequence<N, [0, ...A]>;
export type Flatten<S, D extends number = 5> = Intersect<FlatMap<S, Sequence<D>>>;
export type Row<S> = {
    [K in keyof S]-?: Row.Cell<NonNullable<S[K]>>;
};
export namespace Row {
    type Cell<T> = Eval.Expr<T, false> & (T extends Comparable ? {} : Row<T>);
    type Computed<S, T> = T | ((row: Row<S>) => T);
}
export function isComparable(value: any): value is Comparable;
export function isFlat(value: any): value is Values<AtomicTypes>;
export function randomId(): string;
export interface RegExpLike {
    source: string;
    flags?: string;
}
export function makeRegExp(source: string | RegExpLike, flags?: string): RegExp;
export function unravel(source: object, init?: (value: any) => any): {};
export function flatten(source: object, prefix?: string, ignore?: (value: any) => boolean): {};
export function getCell(row: any, path: any): any;
export function isEmpty(value: any): boolean;
type TableLike<S> = Keys<S> | Selection;
type TableType<S, T extends TableLike<S>> = T extends Keys<S> ? S[T] : T extends Selection<infer U> ? U : never;
export namespace Join1 {
    export type Input<S> = readonly Keys<S>[];
    export type Output<S, U extends Input<S>> = {
        [P in U[number]]: TableType<S, P>;
    };
    type Parameters<S, U extends Input<S>> = U extends readonly [infer K extends Keys<S>, ...infer R] ? [Row<S[K]>, ...Parameters<S, Extract<R, Input<S>>>] : [];
    export type Predicate<S, U extends Input<S>> = (...args: Parameters<S, U>) => Eval.Expr<boolean>;
}
export namespace Join2 {
    export type Input<S> = Dict<TableLike<S>>;
    export type Output<S, U extends Input<S>> = {
        [K in keyof U]: TableType<S, U[K]>;
    };
    type Parameters<S, U extends Input<S>> = {
        [K in keyof U]: Row<TableType<S, U[K]>>;
    };
    export type Predicate<S, U extends Input<S>> = (args: Parameters<S, U>) => Eval.Expr<boolean>;
}
type CreateMap<T, S> = {
    [K in keyof T]?: Create<T[K], S>;
};
export type Create<T, S> = T extends Values<AtomicTypes> ? T : T extends (infer I extends Values<S>)[] ? CreateMap<I, S>[] | {
    $literal?: DeepPartial<I>;
    $create?: MaybeArray<CreateMap<I, S>>;
    $upsert?: MaybeArray<CreateMap<I, S>>;
    $connect?: Query.Expr<Flatten<I>>;
} : T extends Values<S> ? CreateMap<T, S> | {
    $literal?: DeepPartial<T>;
    $create?: CreateMap<T, S>;
    $upsert?: CreateMap<T, S>;
    $connect?: Query.Expr<Flatten<T>>;
} : T extends (infer U)[] ? DeepPartial<U>[] : T extends object ? CreateMap<T, S> : T;
export class Database<S = {}, N = {}, C extends Context = Context> extends Service<undefined, C> {
    static [Service.provide]: string;
    static [Service.immediate]: boolean;
    static readonly transact: unique symbol;
    static readonly migrate: unique symbol;
    tables: Dict<Model>;
    drivers: Driver<any, C>[];
    types: Dict<Field.Transform>;
    private _driver;
    private stashed;
    private prepareTasks;
    migrateTasks: Dict<Promise<void>>;
    connect<T = undefined>(driver: Driver.Constructor<T>, ...args: Spread<T>): Promise<void>;
    refresh(): void;
    prepared(): Promise<void>;
    private getDriver;
    private prepare;
    extend<K extends Keys<S>>(name: K, fields: Field.Extension<S[K], N>, config?: Partial<Model.Config<FlatKeys<S[K]>>>): void;
    private _parseField;
    private parseField;
    define<K extends Exclude<Keys<N>, Field.Type | 'object' | 'array'>>(name: K, field: Field.Definition<N[K], N> | Field.Transform<N[K], any, N>): K;
    define<T>(field: Field.Definition<T, N> | Field.Transform<T, any, N>): Field.NewType<T>;
    migrate<K extends Keys<S>>(name: K, fields: Field.Extension<S[K], N>, callback: Model.Migration<this>): void;
    select<T>(table: Selection<T>, query?: Query<T>): Selection<T>;
    select<K extends Keys<S>>(table: K, query?: Query<S[K]>, include?: Relation.Include<S[K], Values<S>> | null): Selection<S[K]>;
    join<const X extends Join1.Input<S>>(tables: X, callback?: Join1.Predicate<S, X>, optional?: boolean[]): Selection<Join1.Output<S, X>>;
    join<X extends Join2.Input<S>>(tables: X, callback?: Join2.Predicate<S, X>, optional?: Dict<boolean, Keys<X>>): Selection<Join2.Output<S, X>>;
    get<K extends Keys<S>>(table: K, query: Query<S[K]>): Promise<S[K][]>;
    get<K extends Keys<S>, P extends FlatKeys<S[K]> = any>(table: K, query: Query<S[K]>, cursor?: Driver.Cursor<P, S, K>): Promise<FlatPick<S[K], P>[]>;
    eval<K extends Keys<S>, T>(table: K, expr: Selection.Callback<S[K], T, true>, query?: Query<S[K]>): Promise<T>;
    set<K extends Keys<S>>(table: K, query: Query<S[K]>, update: Row.Computed<S[K], Update<S[K]>>): Promise<Driver.WriteResult>;
    remove<K extends Keys<S>>(table: K, query: Query<S[K]>): Promise<Driver.WriteResult>;
    create<K extends Keys<S>>(table: K, data: Create<S[K], S>): Promise<S[K]>;
    upsert<K extends Keys<S>>(table: K, upsert: Row.Computed<S[K], Update<S[K]>[]>, keys?: MaybeArray<FlatKeys<S[K], Indexable>>): Promise<Driver.WriteResult>;
    makeProxy(marker: any, getDriver?: (driver: Driver<any, C>, database: this) => Driver<any, C>): this;
    withTransaction(callback: (database: this) => Promise<void>): Promise<any>;
    transact<T>(callback: (database: this) => Promise<T>): Promise<any>;
    stopAll(): Promise<void>;
    drop<K extends Keys<S>>(table: K): Promise<void>;
    dropAll(): Promise<void>;
    stats(): Promise<Driver.Stats>;
    private ensureTransaction;
    private transformRelationQuery;
    private createOrUpdate;
    private processRelationUpdate;
    private hasRelation;
}
export namespace RuntimeError {
    type Code = 'duplicate-entry' | 'unsupported-expression';
}
export class RuntimeError<T extends RuntimeError.Code> extends Error {
    code: T;
    name: string;
    constructor(code: T, message?: string);
    static check<T extends RuntimeError.Code>(error: any, code?: RuntimeError.Code): error is RuntimeError<T>;
}
declare module 'cordis' {
    interface Events {
        'model'(name: string): void;
    }
    interface Context {
        [Types]: Types;
        [Tables]: Tables;
        [Context.Minato]: Context.Minato<this>;
        [Context.Database]: Context.Database<this>;
        model: Database<this[typeof Tables], this[typeof Types], this> & this[typeof Context.Minato];
        database: Database<this[typeof Tables], this[typeof Types], this> & this[typeof Context.Database];
    }
    namespace Context {
        const Minato: unique symbol;
        const Database: unique symbol;
        interface Minato<C extends Context = Context> {
        }
        interface Database<C extends Context = Context> {
        }
    }
}
export { Logger, Schema, Schema as z } from 'cordis';
export const Types: unique symbol;
export interface Types {
}
export const Tables: unique symbol;
export interface Tables {
}
export default Database;
