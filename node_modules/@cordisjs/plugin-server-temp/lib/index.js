"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cordis_1 = require("cordis");
const promises_1 = require("node:fs/promises");
const node_fs_1 = require("node:fs");
const cosmokit_1 = require("cosmokit");
const url_1 = require("url");
const stream_1 = require("stream");
class TempServer extends cordis_1.Service {
    ctx;
    config;
    static [cordis_1.Service.provide] = 'server.temp';
    static inject = ['server', 'http'];
    path;
    selfUrl;
    baseDir;
    entries = Object.create(null);
    constructor(ctx, config) {
        super(ctx, 'server.temp');
        this.ctx = ctx;
        this.config = config;
        const logger = ctx.logger('temp');
        this.path = (0, cosmokit_1.sanitize)(config.path);
        this.selfUrl = config.selfUrl || ctx.server.config.selfUrl;
        if (!this.selfUrl) {
            logger.warn('missing selfUrl configuration');
        }
        ctx.server.get(this.path + '/:name', async (koa) => {
            logger.debug(koa.params.name);
            const entry = this.entries[koa.params.name];
            if (!entry)
                return koa.status = 404;
            koa.body = (0, node_fs_1.createReadStream)(entry.path);
        });
    }
    async start() {
        this.baseDir = this.ctx.baseDir + '/temp/' + Math.random().toString(36).slice(2) + '/';
        await (0, promises_1.mkdir)(this.baseDir, { recursive: true });
    }
    async stop() {
        await (0, promises_1.rm)(this.baseDir, { recursive: true });
    }
    async create(data) {
        const name = Math.random().toString(36).slice(2);
        const url = this.selfUrl + this.path + '/' + name;
        let path;
        if (typeof data === 'string') {
            if (new URL(data).protocol === 'file:') {
                path = (0, url_1.fileURLToPath)(data);
            }
            else {
                const stream = await this.ctx.http.get(data, { responseType: 'stream' });
                path = this.baseDir + name;
                await (0, promises_1.writeFile)(path, stream_1.Readable.fromWeb(stream));
            }
        }
        else {
            path = this.baseDir + name;
            await (0, promises_1.writeFile)(path, data instanceof ReadableStream ? stream_1.Readable.fromWeb(data) : data);
        }
        return this[cordis_1.Context.origin].effect(() => {
            const timer = setTimeout(() => dispose(), this.config.maxAge);
            const dispose = async () => {
                clearTimeout(timer);
                delete this.entries[name];
                if (path.startsWith(this.baseDir))
                    await (0, promises_1.rm)(path);
            };
            return this.entries[name] = { path, url, dispose };
        });
    }
}
(function (TempServer) {
    TempServer.Config = cordis_1.Schema.object({
        path: cordis_1.Schema.string().default('/temp'),
        selfUrl: cordis_1.Schema.string().role('link').description('此服务暴露在公网的地址。缺省时将使用全局配置。'),
        maxAge: cordis_1.Schema.number().default(cosmokit_1.Time.minute * 5).description('临时文件的默认最大存活时间。'),
    });
})(TempServer || (TempServer = {}));
exports.default = TempServer;
//# sourceMappingURL=index.js.map