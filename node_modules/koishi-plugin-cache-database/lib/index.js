"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const koishi_1 = require("koishi");
const cache_1 = __importDefault(require("@koishijs/cache"));
class DatabaseCache extends cache_1.default {
    constructor(ctx, config) {
        super(ctx);
        this.config = config;
        ctx.model.extend('cache', {
            table: 'string(63)',
            key: 'string(63)',
            value: 'text',
            expire: 'timestamp',
        }, {
            primary: ['table', 'key'],
        });
        ctx.setInterval(async () => {
            await ctx.database.remove('cache', { expire: { $lt: new Date() } });
        }, config.refreshInterval);
    }
    encode(data) {
        return JSON.stringify(data);
    }
    decode(record) {
        return JSON.parse(record);
    }
    async clear(table) {
        await this.ctx.database.remove('cache', { table });
    }
    async get(table, key) {
        const [entry] = await this.ctx.database.get('cache', { table, key }, ['expire', 'value']);
        if (!entry)
            return;
        if (entry.expire && +entry.expire < Date.now())
            return;
        return this.decode(entry.value);
    }
    async set(table, key, value, maxAge) {
        const expire = maxAge ? new Date(Date.now() + maxAge) : null;
        await this.ctx.database.upsert('cache', [{
                table,
                key,
                value: this.encode(value),
                expire,
            }]);
    }
    async delete(table, key) {
        await this.ctx.database.remove('cache', { table, key });
    }
    async *keys(table) {
        const entries = await this.ctx.database.get('cache', { table }, ['expire', 'key']);
        yield* entries
            .filter(entry => !entry.expire || +entry.expire > Date.now())
            .map(entry => entry.key);
    }
    async *values(table) {
        const entries = await this.ctx.database.get('cache', { table }, ['expire', 'value']);
        yield* entries
            .filter(entry => !entry.expire || +entry.expire > Date.now())
            .map(entry => this.decode(entry.value));
    }
    async *entries(table) {
        const entries = await this.ctx.database.get('cache', { table }, ['expire', 'key', 'value']);
        yield* entries
            .filter(entry => !entry.expire || +entry.expire > Date.now())
            .map(entry => [entry.key, this.decode(entry.value)]);
    }
}
DatabaseCache.using = ['database'];
(function (DatabaseCache) {
    DatabaseCache.Config = koishi_1.Schema.object({
        refreshInterval: koishi_1.Schema.number().default(koishi_1.Time.minute * 10).role('time').description('缓存刷新间隔。'),
    });
})(DatabaseCache || (DatabaseCache = {}));
exports.default = DatabaseCache;
