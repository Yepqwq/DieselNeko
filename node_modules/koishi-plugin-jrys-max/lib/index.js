var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Config: () => Config2,
  apply: () => apply,
  inject: () => inject,
  jrysmaxs: () => jrysmaxs,
  name: () => name
});
module.exports = __toCommonJS(src_exports);
var import_koishi2 = require("koishi");
var import_url = require("url");
var import_path2 = require("path");

// src/signin.ts
var import_koishi = require("koishi");
var import_koishi_plugin_axlmly_role_playing_game = require("koishi-plugin-axlmly-role-playing-game");

// src/jrysmax.ts
var fs = __toESM(require("fs"));
var import_path = __toESM(require("path"));
function fnv1aHash(str) {
  let hash = 2166136261;
  for (let i = 0; i < str.length; i++) {
    hash ^= str.charCodeAt(i);
    hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
  }
  return hash >>> 0;
}
__name(fnv1aHash, "fnv1aHash");
var jrysmax = class {
  static {
    __name(this, "jrysmax");
  }
  constructor() {
  }
  async getJrys(uid) {
    const etime = (/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0).toString();
    let userId;
    if (typeof uid === "number" || !isNaN(Number(uid))) {
      userId = Number(uid);
    } else {
      if (uid) {
        const hashInput = uid + etime;
        userId = fnv1aHash(hashInput) % 1000000001;
      } else {
        const defaultInput = "Default Jrys" + etime;
        userId = fnv1aHash(defaultInput) % 1000000001;
      }
    }
    const todaySeed = userId * parseInt(etime) % 1000000001;
    const randomFactor = Math.sin(todaySeed) * 1e4;
    const todayJrys = Math.floor((randomFactor - Math.floor(randomFactor)) * 512);
    return todayJrys;
  }
  seededRandom(seed) {
    const x = Math.sin(seed) * 1e4;
    return x - Math.floor(x);
  }
  // 抽取四个宜不宜
  async getRandomObjects(jsonObject, uid) {
    if (!Array.isArray(jsonObject) || jsonObject.length < 4) {
      throw new Error("输入必须是一个包含至少四个对象的数组");
    }
    const seed = await this.getJrys(uid);
    const randomIndexes = /* @__PURE__ */ new Set();
    let counter = 0;
    while (randomIndexes.size < 4) {
      const randomIndex = Math.floor(this.seededRandom(seed + counter) * jsonObject.length);
      randomIndexes.add(randomIndex);
      counter++;
    }
    return Array.from(randomIndexes).map((index) => jsonObject[index]);
  }
  // 递归获取文件夹内所有文件的文件名
  async readFilenames(dirPath) {
    let filenames = [];
    const files = fs.readdirSync(dirPath);
    files.forEach((filename) => {
      const fullPath = import_path.default.join(dirPath, filename);
      if (fs.statSync(fullPath).isDirectory()) {
        filenames = filenames.concat(this.readFilenames(fullPath));
      } else {
        filenames.push(filename);
      }
    });
    return filenames;
  }
};

// src/signin.ts
var timeGreetings = [
  { range: [0, 5], message: "晚安" },
  { range: [5, 11], message: "上午好" },
  { range: [11, 14], message: "中午好" },
  { range: [14, 18], message: "下午好" },
  { range: [18, 20], message: "傍晚好" },
  { range: [20, 24], message: "晚上好" }
];
var levelInfos = [
  { level: 1, level_line: 1e4 },
  { level: 2, level_line: 15e3 },
  { level: 3, level_line: 32e3 },
  { level: 4, level_line: 76e3 },
  { level: 5, level_line: 328e3 },
  { level: 6, level_line: 676e3 },
  { level: 7, level_line: 1372e3 },
  { level: 8, level_line: 2944e3 },
  { level: 9, level_line: 6088e3 },
  { level: 10, level_line: 12376e3 },
  { level: 11, level_line: 26752e3 },
  { level: 12, level_line: 55504e3 },
  { level: 13, level_line: 113008e3 },
  { level: 14, level_line: 246016e3 },
  { level: 15, level_line: 512032e3 },
  { level: 16, level_line: 1044064e3 },
  { level: 17, level_line: 2108128e3 },
  { level: 18, level_line: 4416256e3 },
  { level: 19, level_line: 9032512e3 },
  { level: 20, level_line: 18265024e3 }
];
var logger = new import_koishi.Logger("[JrysMax]>> ");
var Signin = class {
  static {
    __name(this, "Signin");
  }
  ctx;
  cfg;
  constructor(context, config) {
    this.ctx = context;
    this.cfg = config;
    this.ctx.database.extend("jrys_max", {
      id: "string",
      name: "string",
      time: "string",
      point: "unsigned",
      count: "unsigned",
      current_point: "unsigned",
      coins: "unsigned",
      exp: "unsigned"
    });
  }
  //                  0:已签到, 1:签到成功, 2:未签到, 3:抽奖
  // { "status": 1, "getpoint": signpoint, "signTime": signTime, "allpoint": signpoint, "count": 1 };
  // 参数：session， 返回：json
  async callSignin(session, ctx) {
    let name2;
    if (this.ctx.database && this.cfg.callme)
      name2 = session.username;
    if (!name2 && this.cfg.callme)
      name2 = session.author.name;
    else
      name2 = session.username;
    name2 = name2.length > 12 ? name2.substring(0, 12) : name2;
    const jrys = new jrysmax();
    const jrysData = await jrys.getJrys(session.userId);
    let signTime = import_koishi.Time.template("yyyy-MM-dd hh:mm:ss", /* @__PURE__ */ new Date());
    let all_point = (await this.ctx.database.get("jrys_max", { id: String(session.userId) }))[0]?.point;
    let time = (await this.ctx.database.get("jrys_max", { id: String(session.userId) }))[0]?.time;
    let count = (await this.ctx.database.get("jrys_max", { id: String(session.userId) }))[0]?.count;
    let dbname = (await this.ctx.database.get("jrys_max", { id: String(session.userId) }))[0]?.name;
    let signpoint = import_koishi.Random.int(this.cfg.signpointmin, this.cfg.signpointmax);
    let nowPoint = (await this.ctx.database.get("jrys_max", { id: String(session.userId) }))[0]?.current_point;
    let coins;
    const config = new import_koishi_plugin_axlmly_role_playing_game.Config();
    if (!dbname)
      await this.ctx.database.upsert("jrys_max", [{ id: String(session.userId), name: name2 }]);
    if (!all_point && !time) {
      await this.ctx.database.upsert("jrys_max", [{
        id: String(session.userId),
        name: name2,
        time: signTime,
        point: Number(signpoint),
        count: 1,
        current_point: Number(signpoint)
      }]);
      if (ctx.axlmlyrpg) {
        await ctx.axlmlyrpg.getdata(session, config, ctx);
        await ctx.axlmlyrpg.updataconis(ctx, session, config, jrysData);
      }
      console.log(coins);
      logger.info(`${name2}(${session.userId}) 第一次签到成功，写入数据库！`);
      return {
        "cmd": "get",
        "status": 1,
        "getpoint": signpoint,
        "signTime": signTime,
        "allpoint": signpoint,
        "count": 1
      };
    }
    if (Number(time.slice(8, 10)) - Number(signTime.slice(8, 10))) {
      await this.ctx.database.upsert("jrys_max", [{
        id: String(session.userId),
        name: name2,
        time: signTime,
        point: Number(all_point + signpoint),
        count: count + 1,
        current_point: Number(signpoint)
      }]);
      if (ctx.axlmlyrpg) {
        await ctx.axlmlyrpg.getdata(session, config, ctx);
        await ctx.axlmlyrpg.updataconis(ctx, session, config, jrysData);
      }
      return {
        // "cmd": "get",
        "status": 1,
        // 签到成功
        "getpoint": signpoint,
        // 本次签到获得的积分
        "signTime": signTime,
        // 当前签到时间
        "allpoint": all_point + signpoint,
        // 总积分
        "count": count + 1
        // 签到次数
      };
    }
    return {
      // "cmd": "get",
      "status": 0,
      // 签到失败
      "getpoint": nowPoint,
      // 本次签到获得的积分
      "signTime": signTime,
      // 当前签到时间
      "allpoint": all_point,
      // 总积分
      "count": count
      // 签到次数
    };
  }
  levelJudge(all_point) {
    for (const levelInfo of levelInfos) {
      if (all_point <= levelInfo.level_line) {
        return levelInfo;
      }
    }
    return levelInfos[levelInfos.length - 1];
  }
  getGreeting(hour) {
    const greeting = timeGreetings.find(
      (timeGreeting) => hour >= timeGreeting.range[0] && hour < timeGreeting.range[1]
    );
    return greeting ? greeting.message : "你好";
  }
  getLevelLine(all_point, levelInfos2) {
    for (const levelInfo of levelInfos2) {
      if (all_point <= levelInfo.level_line) {
        return levelInfo.level_line;
      }
    }
    return levelInfos2[levelInfos2.length - 1].level_line;
  }
};

// src/event.ts
var eventJson = [
  {
    "name": "看直播",
    "good": "喜欢的V开歌回啦",
    "bad": "喜欢的V咕了一整天"
  },
  {
    "name": "打轴",
    "good": "一次性过",
    "bad": "谁说话这么难懂"
  },
  {
    "name": "剪辑",
    "good": "灵感爆发",
    "bad": "一团乱麻"
  },
  {
    "name": "校对",
    "good": "变成无情的审轴机器",
    "bad": "被闪轴闪瞎眼"
  },
  {
    "name": "浏览Pixiv",
    "good": "发现符合xp的涩图",
    "bad": "找不到想要的涩图"
  },
  {
    "name": "打SC",
    "good": "享受石油佬的乐趣",
    "bad": "吃土中"
  },
  {
    "name": "吃人",
    "good": "你面前这位有成为神龙的潜质",
    "bad": "这人会用Aegisub吗？"
  },
  {
    "name": "背单词",
    "good": "这次六级肯定过",
    "bad": "背完50个忘了45个"
  },
  {
    "name": "翘课",
    "good": "老师不会点名",
    "bad": "老师准会抽到你来回答问题"
  },
  {
    "name": "做作业",
    "good": "做的每个都对",
    "bad": "做一个做错一个"
  },
  {
    "name": "锻炼一下身体",
    "good": "身体健康, 更加性福",
    "bad": "能量没消耗多少, 吃得却更多"
  },
  {
    "name": "浏览成人网站",
    "good": "重拾对生活的信心",
    "bad": "你会心神不宁"
  },
  {
    "name": "修复BUG",
    "good": "你今天对BUG的嗅觉大大提高",
    "bad": "新产生的BUG将比修复的更多"
  },
  {
    "name": "上AB站",
    "good": "还需要理由吗?",
    "bad": "满屏兄贵亮瞎你的眼"
  },
  {
    "name": "打LOL",
    "good": "你将有如神助",
    "bad": "你会被虐的很惨"
  },
  {
    "name": "打DOTA",
    "good": "天梯5000分不是梦",
    "bad": "你会遇到猪一样的队友"
  },
  {
    "name": "打DOTA2",
    "good": "Godlike",
    "bad": "不怕神一样的对手，就怕猪一样的队友"
  },
  {
    "name": "穿女装",
    "good": "你会得到很多炙热的目光",
    "bad": "被父母看到"
  },
  {
    "name": "组模型",
    "good": "今天的喷漆会很完美",
    "bad": "精神不集中板件被剪断了"
  },
  {
    "name": "熬夜",
    "good": "夜间的效率更高",
    "bad": "明天有很重要的事"
  },
  {
    "name": "抚摸猫咪",
    "good": "才不是特意蹭你的呢",
    "bad": "死开! 愚蠢的人类"
  },
  {
    "name": "烹饪",
    "good": "黑暗料理界就由我来打败",
    "bad": "难道这就是……仰望星空派?"
  },
  {
    "name": "告白",
    "good": "其实我也喜欢你好久了",
    "bad": "对不起, 你是一个好人"
  },
  {
    "name": "追新番",
    "good": "完结之前我绝不会死",
    "bad": "会被剧透"
  },
  {
    "name": "日麻",
    "good": "立直一发自摸！",
    "bad": "碰喵吃喵杠喵荣喵！"
  },
  {
    "name": "音游",
    "good": "FCACFRPR不过如此",
    "bad": "又双叒叕LOST了..."
  },
  {
    "name": "向大佬请教",
    "good": "太棒了，学到许多",
    "bad": "太棒了，什么都没学到"
  },
  {
    "name": "早起",
    "good": "迎接第一缕阳光",
    "bad": "才4点，再睡一会"
  },
  {
    "name": "早睡",
    "good": "第二天精神饱满",
    "bad": "失眠数羊画圈圈"
  },
  {
    "name": "入正版游戏",
    "good": "买了痛三天，不买悔三年",
    "bad": "emmmm，汇率还是……"
  },
  {
    "name": "补旧作",
    "good": "意外地对胃口",
    "bad": "会踩雷"
  },
  {
    "name": "晾晒老婆（抱枕套）",
    "good": "天気も晴れココロも晴れ",
    "bad": "引发路人围观"
  },
  {
    "name": "不按攻略打",
    "good": "居然是HAPPY END",
    "bad": "碰到BAD END"
  },
  {
    "name": "观赏CG包",
    "good": "社保。",
    "bad": "还不去如看游戏剧情"
  },
  {
    "name": "研究黄油创作理论",
    "good": "增进鉴赏水平",
    "bad": "闲适玩家不需要这些"
  },
  {
    "name": "暴露性癖",
    "good": "会引来很多趣味相同的变态",
    "bad": "四斋蒸鹅心"
  },
  {
    "name": "施法",
    "good": "传统手艺精进了",
    "bad": "房间门关好了吗"
  },
  {
    "name": "刷新作动态",
    "good": "喜欢的画师发了新图",
    "bad": "发现游戏跳票"
  },
  {
    "name": "回味玩过的作品",
    "good": "重温感动",
    "bad": "还是先看看新作"
  },
  {
    "name": "出门走走",
    "good": "宅久了要发霉",
    "bad": "太陽が眩しすぎる"
  },
  {
    "name": "思考人生",
    "good": "自己的幸福呢？",
    "bad": "喵喵……喵？"
  },
  {
    "name": "撸猫",
    "good": "啊……好爽",
    "bad": "家里没有猫的洗洗睡吧"
  },
  {
    "name": "抽卡",
    "good": "单抽出货",
    "bad": "到井前一发出货"
  },
  {
    "name": "拼乐高",
    "good": "顺利完工",
    "bad": "发现少了一块零件"
  },
  {
    "name": "跳槽",
    "good": "新工作待遇大幅提升",
    "bad": "待遇还不如之前的"
  },
  {
    "name": "和女神聊天",
    "good": "今天天气不错",
    "bad": "我去洗澡了，呵呵"
  },
  {
    "name": "写开源库",
    "good": "今天北斗七星汇聚，裤子造的又快又好",
    "bad": "写好会发现github上已经有了更好的"
  },
  {
    "name": "给测试妹子埋个bug",
    "good": "下辈子的幸福就靠这个bug了",
    "bad": "妹子会认为你活和代码一样差"
  },
  {
    "name": "写单元测试",
    "good": "写单元测试将减少出错",
    "bad": "写单元测试会降低你的开发效率"
  },
  {
    "name": "洗澡",
    "good": "你几天没洗澡了？",
    "bad": "会把设计方面的灵感洗掉"
  },
  {
    "name": "白天上线",
    "good": "今天白天上线是安全的",
    "bad": "可能导致灾难性后果"
  },
  {
    "name": "重构",
    "good": "代码质量得到提高",
    "bad": "你很有可能会陷入泥潭"
  },
  {
    "name": "招人",
    "good": "你面前这位有成为牛人的潜质",
    "bad": "这人会写程序吗？"
  },
  {
    "name": "面试",
    "good": "面试官今天心情很好",
    "bad": "面试官不爽，会拿你出气"
  },
  {
    "name": "申请加薪",
    "good": "老板今天心情很好",
    "bad": "公司正在考虑裁员"
  },
  {
    "name": "提交代码",
    "good": "遇到冲突的几率是最低的",
    "bad": "会遇到的一大堆冲突"
  },
  {
    "name": "代码复审",
    "good": "发现重要问题的几率大大增加",
    "bad": "你什么问题都发现不了，白白浪费时间"
  },
  {
    "name": "晚上上线",
    "good": "晚上是程序员精神最好的时候",
    "bad": "你白天已经筋疲力尽了"
  },
  {
    "name": "乘电梯",
    "good": "正好赶上打卡截止时间",
    "bad": "电梯超载"
  },
  {
    "name": "复读",
    "good": "有时候，人云亦云也是一种生存方式",
    "bad": "你的对手是鸽子"
  },
  {
    "name": "肝爆",
    "good": "努力使人进步，肝爆让人快乐",
    "bad": "醒醒，限时活动没了"
  },
  {
    "name": "氪金",
    "good": "早买早享受，晚买哭着求",
    "bad": "第二天就 50% off"
  },
  {
    "name": "卖弱",
    "good": "楚楚动人更容易打动群友",
    "bad": "Boy♂next♂door"
  },
  {
    "name": "唱脑力",
    "good": "唱一次提神醒脑，唱两次精神百倍",
    "bad": "会与复读机一起对群聊造成毁灭性打击"
  },
  {
    "name": "看手元",
    "good": "从手元中获得一点音游经验",
    "bad": "会被大佬闪瞎"
  },
  {
    "name": "录手元",
    "good": "音游届的未来新星UP主就是你",
    "bad": "打完歌才发现忘记开录像"
  },
  {
    "name": "挑战魔王曲",
    "good": "一上来就是一个新纪录",
    "bad": "有这点时间还不如干点别的"
  },
  {
    "name": "咕咕咕",
    "good": "一时咕一时爽",
    "bad": "会被抓起来，被群友强迫穿上女装"
  },
  {
    "name": "与群友水聊",
    "good": "扶我起来我还能打字",
    "bad": "一不小心就被大佬闪瞎"
  },
  {
    "name": "迫害大佬",
    "good": "迫害是大佬进步的阶梯",
    "bad": "亲爱的，你号没了"
  },
  {
    "name": "算命",
    "good": "算啥都准",
    "bad": "诸事不宜"
  },
  {
    "name": "成为魔法少女",
    "good": "勇敢的烧酒啊快去拯救世界吧！",
    "bad": "会掉头"
  },
  {
    "name": "沟通克苏鲁",
    "good": "奇怪的知识增加了",
    "bad": "&▓▓▓◆▓▓▓￥#▓@■.◆"
  },
  {
    "name": "看新番",
    "good": "你看的这部新番有成为本季度霸权的可能",
    "bad": "这周更新的是总集篇"
  },
  {
    "name": "看旧番",
    "good": "在宅的道路上又前进了一步",
    "bad": "被剧情喂屎"
  },
  {
    "name": "看里番",
    "good": "传统手艺精进了",
    "bad": "房间门关好了吗？"
  },
  {
    "name": "看漫画",
    "good": "正在追的作品十话连发",
    "bad": "刷到正在追的作品的腰斩停更通知"
  },
  {
    "name": "看轻小说",
    "good": "插画很好舔，孩子很满意",
    "bad": "买插画送的厕纸有啥好看的"
  },
  {
    "name": "看本子",
    "good": "被精准戳中性癖",
    "bad": "更新的全是你不喜欢的类型"
  },
  {
    "name": "前往女仆咖啡厅",
    "good": "感受身心上的治愈",
    "bad": "虚假的女仆只会让你内心更加空虚"
  },
  {
    "name": "女装Cosplay",
    "good": "好评如潮",
    "bad": "照片传到班级群还被认出来"
  },
  {
    "name": "修仙",
    "good": "能突破到下一个境界",
    "bad": "会在进阶中遭受心魔侵蚀"
  },
  {
    "name": "渡劫",
    "good": "万事俱备，只待飞升",
    "bad": "没能扛过去，寿元终"
  },
  {
    "name": "在妹子面前吹牛",
    "good": "改善你矮穷挫的形象",
    "bad": "会被识破"
  },
  {
    "name": "发超过10条的状态",
    "good": "显得你很高产",
    "bad": "会被人直接拉黑"
  },
  {
    "name": "在B站上传视频",
    "good": "播放量爆炸",
    "bad": "没人看"
  },
  {
    "name": "搬运视频",
    "good": "会被硬币砸得很爽",
    "bad": "不会有人看的"
  },
  {
    "name": "上微博",
    "good": "今天的瓜不能错过",
    "bad": "被智障发言糊一脸"
  },
  {
    "name": "作死",
    "good": "节目效果一流",
    "bad": "吾之旧友弔似汝，如今坟头草丈五"
  },
  {
    "name": "看老黄历",
    "good": "反正你已经看了",
    "bad": "反正你已经看了"
  },
  {
    "name": "学习一门新技能",
    "good": "有会成为大神的资质",
    "bad": "可能会误入歧途"
  },
  {
    "name": "睡懒觉",
    "good": "避免内存不足",
    "bad": "早上很早醒来睡不着了"
  },
  {
    "name": "睡懒觉",
    "good": "你今天会更有精神",
    "bad": "会错过重要的事情"
  },
  {
    "name": "上课玩手机",
    "good": "会发现好玩的事情",
    "bad": "会被老师教训"
  },
  {
    "name": "抄作业",
    "good": "没有作业抄的学生生活是罪恶的！",
    "bad": "老师会认真批改，你懂的……"
  },
  {
    "name": "学习",
    "good": "你已经几天(月、年)没学习了？",
    "bad": "会睡着"
  },
  {
    "name": "出门带伞",
    "good": "今天下雨你信不信",
    "bad": "好运气都被遮住了"
  },
  {
    "name": "走夜路",
    "good": "偶尔也要一个人静一静",
    "bad": "有坏人"
  },
  {
    "name": "补番",
    "good": "你会后悔没早点看这部番",
    "bad": "你会后悔看了这部番"
  },
  {
    "name": "玩Minecraft",
    "good": "建筑灵感爆发",
    "bad": "启动器都会崩溃"
  },
  {
    "name": "上Steam",
    "good": "愿望单里全是90%off",
    "bad": "钱包被G胖洗劫一空"
  },
  {
    "name": "修图",
    "good": "原片直出毫无压力",
    "bad": "Photoshop未响应"
  },
  {
    "name": "赶稿",
    "good": "完美守住deadline",
    "bad": "终究还是超期了"
  },
  {
    "name": "摸鱼",
    "good": "摸鱼一时爽，一直摸鱼一直爽",
    "bad": "被老板当场抓获"
  },
  {
    "name": "入手新游戏",
    "good": "你会玩的很开心",
    "bad": "这游戏明天就99%off"
  },
  {
    "name": "出门",
    "good": "今天会是个好天气",
    "bad": "中途突降暴雨"
  }
];

// src/index.ts
var import_fs = __toESM(require("fs"));
var import_path3 = __toESM(require("path"));
var name = "jrys-max";
var Config2 = import_koishi2.Schema.object({
  imgurl: import_koishi2.Schema.string().role("link").description("随机横图api").required(),
  signpointmin: import_koishi2.Schema.number().default(1).description("签到积分随机最小值"),
  signpointmax: import_koishi2.Schema.number().default(100).description("签到积分随机最大值")
});
var jrysmaxs = class extends import_koishi2.Service {
  static {
    __name(this, "jrysmaxs");
  }
  constructor(ctx) {
    super(ctx, "jrysmaxs", true);
  }
};
var inject = {
  "required": ["database", "puppeteer"],
  "optional": ["axlmlyrpg"]
};
var logger2 = new import_koishi2.Logger("[jrys-max]>> ");
async function getFolderImg(folder) {
  let imgfilename = await readFilenames(folder);
  const filteredArr = imgfilename.filter((filename) => {
    return /\.(png|jpg|jpeg|ico|svg)$/i.test(filename);
  });
  return filteredArr;
}
__name(getFolderImg, "getFolderImg");
async function readFilenames(dirPath) {
  let filenames = [];
  const files = import_fs.default.readdirSync(dirPath);
  files.forEach((filename) => {
    const fullPath = import_path3.default.join(dirPath, filename);
    if (import_fs.default.statSync(fullPath).isDirectory()) {
      filenames = filenames.concat(readFilenames(fullPath));
    } else {
      filenames.push(filename);
    }
  });
  return filenames;
}
__name(readFilenames, "readFilenames");
async function fetchHitokoto(ctx) {
  try {
    const response = await fetch("https://v1.hitokoto.cn/?c=a&c&b&k");
    const { hitokoto: hitokotoText, from: fromText, from_who: fromWhoText } = await response.json();
    let hitokoto;
    if (fromWhoText !== null) {
      hitokoto = `${hitokotoText}<br>  ——${fromWhoText} <br>⟪${fromText}⟫`;
    } else {
      hitokoto = `${hitokotoText}<br>  ——⟪${fromText}⟫`;
    }
    return hitokoto;
  } catch (error) {
    console.error("获取 hitokoto 时出错:", error);
    return "无法获取 hitokoto";
  }
}
__name(fetchHitokoto, "fetchHitokoto");
function apply(ctx, config) {
  ctx.plugin(jrysmaxs);
  ctx.inject(["jrysmaxs"], (ctx2) => {
  });
  const signin = new Signin(ctx, config);
  const jrys = new jrysmax();
  const date = /* @__PURE__ */ new Date();
  ctx.command("jrysmax", "今日运势").userFields(["name"]).action(async ({ session, options }) => {
    const month = (date.getMonth() + 1).toString().padStart(2, "0");
    const day = date.getDate().toString().padStart(2, "0");
    const formattedDate = `${month}/${day}`;
    const jrysData = await jrys.getJrys(session.userId);
    const [gooddo1, gooddo2, baddo1, baddo2] = await jrys.getRandomObjects(eventJson, session.userId ? session.userId : 2333);
    let jryslucky = jrysData;
    let fortune_star = "";
    let fortune_text = "";
    if (jryslucky < 10) {
      fortune_star = "☆".repeat(12);
      fortune_text = "走平坦的路但会摔倒的程度";
    } else if (jryslucky < 42) {
      fortune_star = "★".repeat(1) + "☆".repeat(11);
      fortune_text = "吃泡面偶尔没有调味包的程度";
    } else if (jryslucky < 86) {
      fortune_star = "★".repeat(2) + "☆".repeat(10);
      fortune_text = "上厕所偶尔会忘记带纸的程度";
    } else if (jryslucky < 132) {
      fortune_star = "★".repeat(3) + "☆".repeat(9);
      fortune_text = "上学/上班路上会堵车的程度";
    } else if (jryslucky < 178) {
      fortune_star = "★".repeat(4) + "☆".repeat(8);
      fortune_text = "点外卖很晚才会送到的程度";
    } else if (jryslucky < 224) {
      fortune_star = "★".repeat(5) + "☆".repeat(7);
      fortune_text = "点外卖会多给予赠品的程度";
    } else if (jryslucky < 270) {
      fortune_star = "★".repeat(6) + "☆".repeat(6);
      fortune_text = "出门能捡到几枚硬币的程度";
    } else if (jryslucky < 316) {
      fortune_star = "★".repeat(7) + "☆".repeat(5);
      fortune_text = "踩到香蕉皮不会滑倒的程度";
    } else if (jryslucky < 362) {
      fortune_star = "★".repeat(8) + "☆".repeat(4);
      fortune_text = "玩滑梯能流畅滑到底的程度";
    } else if (jryslucky < 408) {
      fortune_star = "★".repeat(9) + "☆".repeat(3);
      fortune_text = "晚上走森林不会迷路的程度";
    } else if (jryslucky < 454) {
      fortune_star = "★".repeat(10) + "☆".repeat(2);
      fortune_text = "打游戏能够轻松过关的程度";
    } else if (jryslucky < 500) {
      fortune_star = "★".repeat(11) + "☆".repeat(1);
      fortune_text = "在自习室能找到想要的位置的程度";
    } else {
      fortune_star = "★".repeat(12);
      fortune_text = "天选之人";
    }
    let name2;
    if (ctx.database) {
      name2 = session.username;
    }
    if (!name2) {
      name2 = session.author.name;
    }
    name2 = name2.length > 12 ? name2.substring(0, 12) : name2;
    let bgUrl;
    let etime = (/* @__PURE__ */ new Date()).getTime() % 25565;
    if (config.imgurl.match(/http(s)?:\/\/(.*)/gi)) {
      bgUrl = config.imgurl.match(/^http(s)?:\/\/(.*)#e#$/gi) ? config.imgurl.replace("#e#", etime.toString()) : config.imgurl;
    } else {
      bgUrl = (0, import_url.pathToFileURL)((0, import_path2.resolve)(__dirname, config.imgurl + import_koishi2.Random.pick(await getFolderImg(config.imgurl)))).href;
    }
    const getSigninJson = await signin.callSignin(session, ctx);
    let lvline = signin.levelJudge(Number(getSigninJson.allpoint)).level_line;
    const hitokoto = await fetchHitokoto(ctx);
    let level = signin.levelJudge(Number(getSigninJson.allpoint)).level;
    let LevelLines = signin.getLevelLine(Number(getSigninJson.allpoint), levelInfos);
    let levelname;
    let color;
    if (level === 1) {
      levelname = "群聊冒险者";
      color = "#838383";
    } else if (level === 2) {
      levelname = "群聊冒险家";
      color = "#838383";
    } else if (level === 3) {
      levelname = "开拓地冒险者";
      color = "#838383";
    } else if (level === 4) {
      levelname = "开拓地冒险家";
      color = "#000000";
    } else if (level === 5) {
      levelname = "火星开拓者";
      color = "#000000";
    } else if (level === 6) {
      levelname = "火星科技";
      color = "#42bc05";
    } else if (level === 7) {
      levelname = "言灵密语";
      color = "#42bc05";
    } else if (level === 8) {
      levelname = "低声呢喃";
      color = "#42bc05";
    } else if (level === 9) {
      levelname = "荒野的漫步者";
      color = "#2003da";
    } else if (level === 10) {
      levelname = "言灵探索者";
      color = "#2003da";
    } else if (level === 11) {
      levelname = "水系魔法师";
      color = "#2003da";
    } else if (level === 12) {
      levelname = "水系魔导士";
      color = "#03a4da";
    } else if (level === 13) {
      levelname = "绝望的呐喊";
      color = "#03a4da";
    } else if (level === 14) {
      levelname = "疯狂嘶吼";
      color = "#9d03da";
    } else if (level === 15) {
      levelname = "被缚的倒吊者";
      color = "#9d03da";
    } else if (level === 16) {
      levelname = "崩毁世界之人";
      color = "#9d03da";
    } else if (level === 17) {
      levelname = "命运眷顾者";
      color = "#f10171";
    } else if (level === 18) {
      levelname = "背弃之绝望";
      color = "#f10171";
    } else if (level === 19) {
      levelname = "誓约的守护者";
      color = "#c9b86d";
    } else if (level === 20) {
      levelname = "天选之人";
      color = "#ffd000";
    }
    const textfont = import_path3.default.join(__dirname, "/font/pixel.ttf").replace(/\\/g, "/");
    const allpoint = getSigninJson.allpoint;
    const allpoint_LevelLines = `${allpoint}/${LevelLines}`.toString();
    const gooddo = `${gooddo1.name}——${gooddo1.good}<br>${gooddo2.name}——${gooddo2.good}`;
    const baddo = `${baddo1.name}——${baddo1.bad}<br>${baddo2.name}——${baddo2.bad}`;
    let coins = (await ctx.database.get("jrys_max", { id: String(session.userId) }))[0]?.coins;
    let exp = (await ctx.database.get("jrys_max", { id: String(session.userId) }))[0]?.exp;
    let page;
    try {
      let templateHTML;
      if (ctx.axlmlyrpg) {
        templateHTML = import_fs.default.readFileSync(import_path3.default.resolve(__dirname, "./index/template2.txt"), "utf-8");
      } else {
        templateHTML = import_fs.default.readFileSync(import_path3.default.resolve(__dirname, "./index/template.txt"), "utf-8");
      }
      let template = templateHTML.replace("##textfont##", textfont).replace("##todayExp##", getSigninJson.getpoint.toString()).replace("##totalExp##", getSigninJson.allpoint.toString()).replace("##jryslucky##", jryslucky).replace("##level##", levelname).replace("##color##", color).replace("##pointlevel##", allpoint_LevelLines).replace("##bgUrl##", bgUrl).replace("##coins##", coins).replace("##exp##", exp).replace("##avatarUrl##", session.platform == "qq" ? `http://q.qlogo.cn/qqapp/${session.bot.config.id}/${session.event.user?.id}/640` : session.author.avatar).replace("##signinText##", getSigninJson.status ? "签到成功！" : "今天已经签到过了哦~").replace("##date##", formattedDate).replace("##hello##", signin.getGreeting(date.getHours())).replace("##user##", name2).replace("##persent##", (Number(getSigninJson.allpoint) / lvline * 100).toFixed(3).toString()).replace("##signTxt##", hitokoto).replace("##fortunate##", fortune_text).replace("##luckystar##", fortune_star).replace("##gooddo##", gooddo).replace("##baddo##", baddo);
      await import_fs.default.writeFileSync(import_path3.default.resolve(__dirname, "./index/index.html"), template);
      page = await ctx.puppeteer.page();
      await page.setViewport({ width: 600, height: 1080 * 2 });
      await page.goto(`file:///${(0, import_path2.resolve)(__dirname, "./index/index.html")}`);
      await page.waitForSelector("#body");
      const element = await page.$("#body");
      let msg;
      if (element) {
        const imgBuf = await element.screenshot({
          encoding: "binary"
        });
        msg = import_koishi2.h.image(imgBuf, "image/png");
      } else {
        msg = "Failed to capture screenshot.";
      }
      await page.close();
      return import_koishi2.h.quote(session.event.message.id) + msg;
    } catch (err) {
      logger2.error(`[jrysmax Error]:\r
` + err);
      return "哪里出的问题！md跟你爆了";
    }
  });
}
__name(apply, "apply");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Config,
  apply,
  inject,
  jrysmaxs,
  name
});
