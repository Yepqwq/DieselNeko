"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.apply = exports.Config = exports.using = exports.name = void 0;
const jsx_runtime_1 = require("@satorijs/element/jsx-runtime");
const koishi_1 = require("koishi");
exports.name = "wife";
exports.using = ["cache"];
exports.Config = koishi_1.Schema.intersect([
    koishi_1.Schema.object({
        tableCleanupTime: koishi_1.Schema.number()
            .min(0)
            .max(23)
            .step(1)
            .default(0)
            .description("数据在何时失效（也就是到几点算作第二天）。以24小时制计。"),
    }).description("存储设置"),
    koishi_1.Schema.object({
        allowDaffodil: koishi_1.Schema.boolean()
            .default(false)
            .description("允许随机到自己。"),
        allowNtr: koishi_1.Schema.boolean()
            .default(false)
            .description("允许随机到其他人的老婆。"),
        allowBots: koishi_1.Schema.boolean()
            .default(false)
            .description("允许随机到平台标注为机器人的账号（除了自身）。"),
        allowSelf: koishi_1.Schema.boolean()
            .default(false)
            .description("允许随机到Bot自身账号。"),
    }).description("随机过滤设置"),
]);
/**
 * Build the message to return with given member and his/her wife.
 * @param userId Member's ID who triggers the command
 * @param wife The member's wife
 * @returns Message to return
 */
function buildMessage(userId, wife) {
    return ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)("at", { id: userId }), (0, jsx_runtime_1.jsx)("br", {}), (0, jsx_runtime_1.jsx)("i18n", { path: "commands.wife.messages.todaysWifeIs" }), (0, jsx_runtime_1.jsx)("br", {}), (0, jsx_runtime_1.jsx)("image", { url: wife.user.avatar }), (0, jsx_runtime_1.jsx)("br", {}), wife.name ? wife.name : wife.user.name, " (", wife.user.id, ")"] }));
}
/**
 * Get all member of a guild.
 *
 * The API of bot returns paged data. Use this function
 * to get a full set of data.
 * @param bot Bot object of the session
 * @param guildId Id of the target guild
 * @returns All members of the target guild
 */
async function getAllGuildMember(bot, guildId) {
    let members = [];
    // Get the first page
    let membersPage = await bot.getGuildMemberList(guildId);
    members = members.concat(membersPage.data);
    // If there are more pages, get them
    while (membersPage.next) {
        membersPage = await bot.getGuildMemberList(guildId, membersPage.next);
        members = members.concat(membersPage.data);
    }
    return members;
}
/**
 * Calculate `maxAge` for a cache entry.
 * @param cleanupTime Preset cleanup time
 * @returns Proper age of the cache entry
 */
function getAge(cleanupTime) {
    const currentTime = Date.now();
    const tomorrow = new Date(currentTime + 24 * 60 * 60 * 1000);
    tomorrow.setHours(cleanupTime, 0, 0, 0);
    const tomorrowTime = tomorrow.getTime();
    return tomorrowTime - currentTime;
}
function apply(ctx, config) {
    // Register i18n
    ctx.i18n.define("zh-CN", require("./locales/zh-CN"));
    // Register the command
    ctx.command("wife").action(async ({ session }) => {
        // We use `session.gid` to identify guilds, and session.userId to
        // identify members. The result is designed to be different in
        // different guilds, so there's no need to bind a user between
        // different platforms.
        // Check if the command is triggered in guilds.
        if (!session.guildId)
            return ((0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children: (0, jsx_runtime_1.jsx)("i18n", { path: "commands.wife.messages.pleaseUseInGuilds" }) }));
        // Query the database for result generated earlier.
        const existedWife = await ctx.cache.get(`wife_of_the_day_${session.gid}`, session.userId);
        // If there is pre-generated result, return it.
        if (existedWife) {
            const wife = await session.bot.getGuildMember(session.guildId, existedWife);
            return buildMessage(session.userId, wife);
        }
        // There is no generated result. We should generate a new one.
        // Query members that already be someone's wife.
        const wifeAsyncIterator = ctx.cache.values(`wife_of_the_day_${session.gid}`);
        const wifes = [];
        for await (const wife of wifeAsyncIterator)
            wifes.push(wife);
        // Get members that are available to be one's wife.
        const members = (await getAllGuildMember(session.bot, session.guildId)).filter((value) => (config.allowNtr || !wifes.includes(value.user.id)) &&
            (value.user.id === session.bot.selfId || // If the member is self, let the next expression handle it
                config.allowBots ||
                !value.user.isBot) &&
            (config.allowSelf || value.user.id !== session.bot.selfId) &&
            (config.allowDaffodil || value.user.id !== session.userId));
        // Check the array to prevent errors.
        if (members.length === 0)
            return ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)("at", { id: session.userId }), (0, jsx_runtime_1.jsx)("i18n", { path: "commands.wife.messages.youHaveNoWife" })] }));
        // Pick a member to be one's wife.
        const wife = members[Math.floor(Math.random() * members.length)];
        // Store the wife to database for later query.
        await ctx.cache.set(`wife_of_the_day_${session.gid}`, session.userId, wife.user.id, getAge(config.tableCleanupTime));
        // Build and return the message
        return buildMessage(session.userId, wife);
    });
}
exports.apply = apply;
