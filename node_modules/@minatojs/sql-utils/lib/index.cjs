"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Builder: () => Builder,
  escapeId: () => escapeId,
  isBracketed: () => isBracketed,
  isSqlJson: () => isSqlJson
});
module.exports = __toCommonJS(src_exports);
var import_cosmokit = require("cosmokit");
var import_minato = require("minato");
function escapeId(value) {
  return "`" + value + "`";
}
__name(escapeId, "escapeId");
function isBracketed(value) {
  return value.startsWith("(") && value.endsWith(")");
}
__name(isBracketed, "isBracketed");
function isSqlJson(type) {
  return type ? type.type === "json" || !!type.inner : false;
}
__name(isSqlJson, "isSqlJson");
var Builder = class {
  constructor(driver, tables) {
    this.driver = driver;
    this.state.tables = tables;
    this.queryOperators = {
      // logical
      $or: (key, value) => this.logicalOr(value.map((value2) => this.parseFieldQuery(key, value2))),
      $and: (key, value) => this.logicalAnd(value.map((value2) => this.parseFieldQuery(key, value2))),
      $not: (key, value) => this.logicalNot(this.parseFieldQuery(key, value)),
      // existence
      $exists: (key, value) => this.createNullQuery(key, value),
      // comparison
      $eq: this.createEqualQuery,
      $ne: this.comparator("!="),
      $gt: this.comparator(">"),
      $gte: this.comparator(">="),
      $lt: this.comparator("<"),
      $lte: this.comparator("<="),
      // membership
      $in: (key, value) => this.createMemberQuery(key, value, ""),
      $nin: (key, value) => this.createMemberQuery(key, value, " NOT"),
      // regexp
      $regex: (key, value) => this.createRegExpQuery(key, value),
      $regexFor: (key, value) => typeof value === "string" ? `${this.escape(value)} collate utf8mb4_bin regexp ${key}` : `${this.escape(value.input)} ${value.flags?.includes("i") ? "regexp" : "collate utf8mb4_bin regexp"} ${key}`,
      // bitwise
      $bitsAllSet: (key, value) => `${key} & ${this.escape(value)} = ${this.escape(value)}`,
      $bitsAllClear: (key, value) => `${key} & ${this.escape(value)} = 0`,
      $bitsAnySet: (key, value) => `${key} & ${this.escape(value)} != 0`,
      $bitsAnyClear: (key, value) => `${key} & ${this.escape(value)} != ${this.escape(value)}`,
      // list
      $el: (key, value) => {
        if (Array.isArray(value)) {
          return this.logicalOr(value.map((value2) => this.createElementQuery(key, value2)));
        } else if (typeof value !== "number" && typeof value !== "string") {
          throw new TypeError("query expr under $el is not supported");
        } else {
          return this.createElementQuery(key, value);
        }
      },
      $size: (key, value) => {
        if (this.isJsonQuery(key)) {
          return `${this.jsonLength(key)} = ${this.escape(value)}`;
        } else {
          if (!value)
            return this.logicalNot(key);
          return `${key} AND LENGTH(${key}) - LENGTH(REPLACE(${key}, ${this.escape(",")}, ${this.escape("")})) = ${this.escape(value)} - 1`;
        }
      }
    };
    this.evalOperators = {
      // universal
      $: (key) => this.getRecursive(key),
      $select: (args) => `${args.map((arg) => this.parseEval(arg, false)).join(", ")}`,
      $if: (args) => `if(${args.map((arg) => this.parseEval(arg)).join(", ")})`,
      $ifNull: (args) => `ifnull(${args.map((arg) => this.parseEval(arg)).join(", ")})`,
      // number
      $add: (args) => `(${args.map((arg) => this.parseEval(arg)).join(" + ")})`,
      $multiply: (args) => `(${args.map((arg) => this.parseEval(arg)).join(" * ")})`,
      $subtract: this.binary("-"),
      $divide: this.binary("/"),
      $modulo: this.binary("%"),
      // mathemetic
      $abs: (arg) => `abs(${this.parseEval(arg)})`,
      $floor: (arg) => `floor(${this.parseEval(arg)})`,
      $ceil: (arg) => `ceil(${this.parseEval(arg)})`,
      $round: (arg) => `round(${this.parseEval(arg)})`,
      $exp: (arg) => `exp(${this.parseEval(arg)})`,
      $log: (args) => `log(${args.filter((x) => !(0, import_cosmokit.isNullable)(x)).map((arg) => this.parseEval(arg)).reverse().join(", ")})`,
      $power: (args) => `power(${args.map((arg) => this.parseEval(arg)).join(", ")})`,
      $random: () => `rand()`,
      // string
      $concat: (args) => `concat(${args.map((arg) => this.parseEval(arg)).join(", ")})`,
      $regex: ([key, value, flags]) => `(${this.parseEval(key)} ${flags?.includes("i") || value instanceof RegExp && value.flags.includes("i") ? "regexp" : "collate utf8mb4_bin regexp"} ${this.parseEval(value)})`,
      // logical / bitwise
      $or: (args) => {
        const type = import_minato.Type.fromTerm(this.state.expr, import_minato.Type.Boolean);
        if (import_minato.Field.boolean.includes(type.type))
          return this.logicalOr(args.map((arg) => this.parseEval(arg)));
        else
          return `(${args.map((arg) => this.parseEval(arg)).join(" | ")})`;
      },
      $and: (args) => {
        const type = import_minato.Type.fromTerm(this.state.expr, import_minato.Type.Boolean);
        if (import_minato.Field.boolean.includes(type.type))
          return this.logicalAnd(args.map((arg) => this.parseEval(arg)));
        else
          return `(${args.map((arg) => this.parseEval(arg)).join(" & ")})`;
      },
      $not: (arg) => {
        const type = import_minato.Type.fromTerm(this.state.expr, import_minato.Type.Boolean);
        if (import_minato.Field.boolean.includes(type.type))
          return this.logicalNot(this.parseEval(arg));
        else
          return `(~(${this.parseEval(arg)}))`;
      },
      // boolean
      $eq: this.binary("="),
      $ne: this.binary("!="),
      $gt: this.binary(">"),
      $gte: this.binary(">="),
      $lt: this.binary("<"),
      $lte: this.binary("<="),
      // membership
      $in: ([key, value]) => this.asEncoded(this.createMemberQuery(this.parseEval(key, false), value, ""), false),
      $nin: ([key, value]) => this.asEncoded(this.createMemberQuery(this.parseEval(key, false), value, " NOT"), false),
      // typecast
      $literal: ([value, type]) => this.escape(value, type),
      // aggregation
      $sum: (expr) => this.createAggr(expr, (value) => `ifnull(sum(${value}), 0)`),
      $avg: (expr) => this.createAggr(expr, (value) => `avg(${value})`),
      $min: (expr) => this.createAggr(expr, (value) => `min(${value})`),
      $max: (expr) => this.createAggr(expr, (value) => `max(${value})`),
      $count: (expr) => this.createAggr(expr, (value) => `count(distinct ${value})`),
      $length: (expr) => this.createAggr(expr, (value) => `count(${value})`, (value) => this.isEncoded() ? this.jsonLength(value) : this.asEncoded(`if(${value}, LENGTH(${value}) - LENGTH(REPLACE(${value}, ${this.escape(",")}, ${this.escape("")})) + 1, 0)`, false)),
      $object: (fields) => this.groupObject(fields),
      $array: (expr) => this.groupArray(this.transform(this.parseEval(expr, false), expr, "encode")),
      $exec: (sel) => this.parseSelection(sel)
    };
  }
  static {
    __name(this, "Builder");
  }
  escapeMap = {};
  escapeRegExp;
  createEqualQuery = this.comparator("=");
  queryOperators;
  evalOperators;
  state = {};
  $true = "1";
  $false = "0";
  modifiedTable;
  transformers = /* @__PURE__ */ Object.create(null);
  createNullQuery(key, value) {
    return `${key} is ${value ? "not " : ""}null`;
  }
  createMemberQuery(key, value, notStr = "") {
    if (Array.isArray(value)) {
      if (!value.length)
        return notStr ? this.$true : this.$false;
      if (Array.isArray(value[0])) {
        return `(${key})${notStr} in (${value.map((val) => `(${val.map((x) => this.escape(x)).join(", ")})`).join(", ")})`;
      }
      return `${key}${notStr} in (${value.map((val) => this.escape(val)).join(", ")})`;
    } else if (value.$exec) {
      return `(${key})${notStr} in ${this.parseSelection(value.$exec, true)}`;
    } else {
      const res = this.jsonContains(this.parseEval(value, false), this.encode(key, true, true));
      return notStr ? this.logicalNot(res) : res;
    }
  }
  createRegExpQuery(key, value) {
    if (typeof value !== "string" && value.flags?.includes("i")) {
      return `${key} regexp ${this.escape(value.source)}`;
    } else {
      return `${key} collate utf8mb4_bin regexp ${this.escape(typeof value === "string" ? value : value.source)}`;
    }
  }
  createElementQuery(key, value) {
    if (this.isJsonQuery(key)) {
      return this.jsonContains(key, this.encode(value, true, true));
    } else {
      return `find_in_set(${this.escape(value)}, ${key})`;
    }
  }
  isJsonQuery(key) {
    return import_minato.Type.fromTerm(this.state.expr)?.type === "json" || this.isEncoded(key);
  }
  comparator(operator) {
    return (key, value) => {
      return `${key} ${operator} ${this.escape(value)}`;
    };
  }
  binary(operator) {
    return ([left, right]) => {
      return `(${this.parseEval(left)} ${operator} ${this.parseEval(right)})`;
    };
  }
  logicalAnd(conditions) {
    if (!conditions.length)
      return this.$true;
    if (conditions.includes(this.$false))
      return this.$false;
    return conditions.join(" AND ");
  }
  logicalOr(conditions) {
    if (!conditions.length)
      return this.$false;
    if (conditions.includes(this.$true))
      return this.$true;
    return `(${conditions.join(" OR ")})`;
  }
  logicalNot(condition) {
    return `NOT(${condition})`;
  }
  parseSelection(sel, inline = false) {
    const { args: [expr], ref, table, tables } = sel;
    const restore = this.saveState({ tables });
    const inner = this.get(table, true, true);
    const output = this.parseEval(expr, false);
    const fields = expr["$select"]?.map((x) => this.getRecursive(x["$"]));
    const where = fields && this.logicalAnd(fields.map((x) => `(${x} is not null)`));
    restore();
    if (inline || !(0, import_minato.isAggrExpr)(expr)) {
      return `(SELECT ${output} FROM ${inner} ${isBracketed(inner) ? ref : ""}${where ? ` WHERE ${where}` : ""})`;
    } else {
      return [
        `(ifnull((SELECT ${this.groupArray(this.transform(output, import_minato.Type.getInner(import_minato.Type.fromTerm(expr)), "encode"))}`,
        `FROM ${inner} ${isBracketed(inner) ? ref : ""}), json_array()))`
      ].join(" ");
    }
  }
  jsonLength(value) {
    return this.asEncoded(`json_length(${value})`, false);
  }
  jsonContains(obj, value) {
    return this.asEncoded(`json_contains(${obj}, ${value})`, false);
  }
  asEncoded(value, encoded) {
    if (encoded !== void 0)
      this.state.encoded = encoded;
    return value;
  }
  encode(value, encoded, pure = false, type) {
    return this.asEncoded(encoded === this.isEncoded() && !pure ? value : encoded ? `cast(${this.transform(value, type, "encode")} as json)` : this.transform(`json_unquote(${value})`, type, "decode"), pure ? void 0 : encoded);
  }
  isEncoded(key) {
    return key ? this.state.encodedMap?.[key] : this.state.encoded;
  }
  createAggr(expr, aggr, nonaggr) {
    if (this.state.group) {
      this.state.group = false;
      const value = aggr(this.parseEval(expr, false));
      this.state.group = true;
      return value;
    } else {
      const value = this.parseEval(expr, false);
      const res = nonaggr ? nonaggr(value) : `(select ${aggr(`json_unquote(${this.escapeId("value")})`)} from json_table(${value}, '$[*]' columns (value json path '$')) ${(0, import_minato.randomId)()})`;
      return res;
    }
  }
  /**
   * Convert value from SQL field to JSON field
   */
  transform(value, type, method, miss) {
    type = import_minato.Type.isType(type) ? type : import_minato.Type.fromTerm(type);
    const transformer = this.transformers[type.type] ?? this.transformers[this.driver.database.types[type.type]?.type];
    return transformer?.[method] ? transformer[method](value) : miss ?? value;
  }
  groupObject(_fields) {
    const _groupObject = /* @__PURE__ */ __name((fields, type, prefix = "") => {
      const parse = /* @__PURE__ */ __name((expr, key) => {
        const value = !_fields[`${prefix}${key}`] && type && import_minato.Type.getInner(type, key)?.inner ? _groupObject(expr, import_minato.Type.getInner(type, key), `${prefix}${key}.`) : this.parseEval(expr, false);
        return this.isEncoded() ? `json_extract(${value}, '$')` : this.transform(value, expr, "encode");
      }, "parse");
      return `json_object(` + Object.entries(fields).map(([key, expr]) => `'${key}', ${parse(expr, key)}`).join(",") + `)`;
    }, "_groupObject");
    return this.asEncoded(_groupObject((0, import_minato.unravel)(_fields), import_minato.Type.fromTerm(this.state.expr), ""), true);
  }
  groupArray(value) {
    return this.asEncoded(`ifnull(json_arrayagg(${value}), json_array())`, true);
  }
  parseFieldQuery(key, query) {
    const conditions = [];
    if (Array.isArray(query)) {
      conditions.push(this.createMemberQuery(key, query));
    } else if (query instanceof RegExp) {
      conditions.push(this.createRegExpQuery(key, query));
    } else if ((0, import_minato.isComparable)(query)) {
      conditions.push(this.createEqualQuery(key, query));
    } else if ((0, import_cosmokit.isNullable)(query)) {
      conditions.push(this.createNullQuery(key, false));
    } else {
      for (const prop in query) {
        if (prop in this.queryOperators) {
          conditions.push(this.queryOperators[prop](key, query[prop]));
        }
      }
    }
    return this.logicalAnd(conditions);
  }
  parseQuery(query) {
    const conditions = [];
    for (const key in query) {
      if (key === "$not") {
        conditions.push(this.logicalNot(this.parseQuery(query.$not)));
      } else if (key === "$and") {
        conditions.push(this.logicalAnd(query.$and.map(this.parseQuery.bind(this))));
      } else if (key === "$or") {
        conditions.push(this.logicalOr(query.$or.map(this.parseQuery.bind(this))));
      } else if (key === "$expr") {
        conditions.push(this.parseEval(query.$expr));
      } else {
        const flattenQuery = (0, import_minato.isFlat)(query[key]) ? { [key]: query[key] } : (0, import_minato.flatten)(query[key], `${key}.`);
        for (const key2 in flattenQuery) {
          const model = this.state.tables[this.state.table] ?? Object.values(this.state.tables)[0];
          const expr = (0, import_minato.Eval)("", [this.state.table ?? Object.keys(this.state.tables)[0], key2], model.getType(key2));
          conditions.push(this.parseFieldQuery(this.parseEval(expr), flattenQuery[key2]));
        }
      }
    }
    return this.logicalAnd(conditions);
  }
  parseEvalExpr(expr) {
    this.state.encoded = false;
    for (const key in expr) {
      if (key in this.evalOperators) {
        this.state.expr = expr;
        return this.evalOperators[key](expr[key]);
      }
    }
    return this.escape(expr);
  }
  transformJsonField(obj, path) {
    return this.asEncoded(`json_extract(${obj}, '$${path}')`, true);
  }
  transformKey(key, fields, prefix) {
    if (key in fields || !key.includes(".")) {
      return this.asEncoded(prefix + this.escapeId(key), this.isEncoded(key) ?? isSqlJson(fields[key]?.type));
    }
    const field = Object.keys(fields).find((k) => key.startsWith(k + ".")) || key.split(".")[0];
    const rest = key.slice(field.length + 1).split(".");
    return this.transformJsonField(`${prefix}${this.escapeId(field)}`, rest.map((key2) => `.${this.escapeKey(key2)}`).join(""));
  }
  getRecursive(args) {
    if (typeof args === "string") {
      return this.getRecursive(["_", args]);
    }
    const [table, key] = args;
    const fields = this.state.tables?.[table]?.fields || {};
    const fkey = Object.keys(fields).find((field) => key === field || key.startsWith(field + "."));
    if (fkey && fields[fkey]?.expr) {
      if (key === fkey) {
        return this.parseEvalExpr(fields[fkey]?.expr);
      } else {
        const field = this.parseEvalExpr(fields[fkey]?.expr);
        const rest = key.slice(fkey.length + 1).split(".");
        return this.transformJsonField(`${field}`, rest.map((key2) => `.${this.escapeKey(key2)}`).join(""));
      }
    }
    const prefix = this.modifiedTable ? `${this.escapeId(this.state.tables?.[table]?.name ?? this.modifiedTable)}.` : !this.state.tables || table === "_" || key in fields || table in this.state.tables ? "" : `${this.escapeId(table)}.`;
    if (!(table in (this.state.tables || {})) && table in (this.state.innerTables || {})) {
      const fields2 = this.state.innerTables?.[table]?.fields || {};
      const res = fields2[key]?.expr ? this.parseEvalExpr(fields2[key]?.expr) : this.transformKey(key, fields2, `${this.escapeId(table)}.`);
      return res;
    }
    if (!(table in (this.state.tables || {})) && table in (this.state.refTables || {})) {
      const fields2 = this.state.refTables?.[table]?.fields || {};
      const res = fields2[key]?.expr ? this.parseEvalExpr(fields2[key]?.expr) : this.transformKey(key, fields2, `${this.escapeId(table)}.`);
      if (this.state.wrappedSubquery) {
        if (res in (this.state.refFields ?? {}))
          return this.state.refFields[res];
        const key2 = `minato_tvar_${(0, import_minato.randomId)()}`;
        (this.state.refFields ??= {})[res] = key2;
        return this.asEncoded(this.escapeId(key2), true);
      } else
        return res;
    }
    return this.transformKey(key, fields, prefix);
  }
  parseEval(expr, unquote = true) {
    this.state.encoded = false;
    if (typeof expr === "string" || typeof expr === "number" || typeof expr === "boolean" || expr instanceof Date || expr instanceof RegExp) {
      return this.escape(expr);
    }
    return unquote ? this.encode(this.parseEvalExpr(expr), false, false, import_minato.Type.fromTerm(expr)) : this.parseEvalExpr(expr);
  }
  saveState(extra = {}) {
    const thisState = this.state;
    this.state = { refTables: { ...this.state.refTables || {}, ...this.state.tables || {} }, ...extra };
    return () => {
      thisState.encoded = this.state.encoded;
      this.state = thisState;
    };
  }
  suffix(modifier) {
    const { limit, offset, sort, group, having } = modifier;
    let sql = "";
    if (group?.length) {
      sql += ` GROUP BY ${group.map(this.escapeId).join(", ")}`;
      const filter = this.parseEval(having);
      if (filter !== this.$true)
        sql += ` HAVING ${filter}`;
    }
    if (sort.length) {
      sql += " ORDER BY " + sort.map(([expr, dir]) => {
        return `${this.parseEval(expr)} ${dir.toUpperCase()}`;
      }).join(", ");
    }
    if (limit < Infinity)
      sql += " LIMIT " + limit;
    if (offset > 0)
      sql += " OFFSET " + offset;
    return sql;
  }
  get(sel, inline = false, group = false, addref = true) {
    const { args, table, query, ref, model } = sel;
    this.state.table = ref;
    let prefix;
    if (typeof table === "string") {
      prefix = this.escapeId(table);
    } else if (table instanceof import_minato.Selection) {
      prefix = this.get(table, true);
      if (!prefix)
        return;
    } else {
      this.state.innerTables = Object.fromEntries(Object.values(table).map((t) => [t.ref, t.model]));
      const joins = Object.entries(table).map(([key, table2]) => {
        const restore = this.saveState({ tables: { ...table2.tables } });
        const t = `${this.get(table2, true, false, false)} AS ${this.escapeId(table2.ref)}`;
        restore();
        return [key, t];
      });
      prefix = [
        // the leading space is to prevent from being parsed as bracketed and added ref
        " ",
        joins[0][1],
        ...joins.slice(1, -1).map(([key, join]) => `${args[0].optional?.[key] ? "LEFT" : ""} JOIN ${join} ON ${this.$true}`),
        `${args[0].optional?.[joins.at(-1)[0]] ? "LEFT " : ""}JOIN`,
        joins.at(-1)[1]
      ].join(" ");
      const filter2 = this.parseEval(args[0].having);
      prefix += ` ON ${filter2}`;
    }
    const filter = this.parseQuery(query);
    if (filter === this.$false)
      return;
    this.state.group = group || !!args[0].group;
    const encodedMap = {};
    const fields = args[0].fields ?? Object.fromEntries(Object.entries(model.fields).filter(([, field]) => import_minato.Field.available(field)).map(([key, field]) => [key, field.expr ? field.expr : (0, import_minato.Eval)("", [ref, key], import_minato.Type.fromField(field))]));
    const keys = Object.entries(fields).map(([key, value]) => {
      value = this.parseEval(value, false);
      encodedMap[key] = this.state.encoded;
      return this.escapeId(key) === value ? this.escapeId(key) : `${value} AS ${this.escapeId(key)}`;
    }).join(", ");
    let suffix = this.suffix(args[0]);
    this.state.encodedMap = encodedMap;
    if (filter !== this.$true) {
      suffix = ` WHERE ${filter}` + suffix;
    }
    if (inline && !args[0].fields && !suffix && (typeof table === "string" || table instanceof import_minato.Selection)) {
      return addref && isBracketed(prefix) ? `${prefix} ${ref}` : prefix;
    }
    if (!prefix.includes(" ") || isBracketed(prefix)) {
      suffix = ` ${ref}` + suffix;
    }
    const result = `SELECT ${keys} FROM ${prefix}${suffix}`;
    return inline ? `(${result})` : result;
  }
  /**
   * Convert value from Type to Field.Type.
   * @param root indicate whether the context is inside json
   */
  dump(value, type, root = true) {
    if (!type)
      return value;
    if (import_minato.Type.isType(type) || (0, import_minato.isEvalExpr)(type)) {
      type = import_minato.Type.isType(type) ? type : import_minato.Type.fromTerm(type);
      const converter = type.inner || type.type === "json" ? root ? this.driver.types["json"] : void 0 : this.driver.types[type.type];
      if (type.inner || type.type === "json")
        root = false;
      let res = value;
      res = import_minato.Type.transform(res, type, (value2, type2) => this.dump(value2, type2, root));
      res = converter?.dump ? converter.dump(res) : res;
      const ancestor = this.driver.database.types[type.type]?.type;
      if (!root && !ancestor)
        res = this.transform(res, type, "dump");
      res = this.dump(res, ancestor ? import_minato.Type.fromField(ancestor) : void 0, root);
      return res;
    }
    value = type.format(value);
    const result = {};
    for (const key in value) {
      const { type: ftype } = type.fields[key];
      result[key] = this.dump(value[key], ftype);
    }
    return result;
  }
  /**
   * Convert value from Field.Type to Type.
   */
  load(value, type, root = true) {
    if (!type)
      return value;
    if (import_minato.Type.isType(type) || (0, import_minato.isEvalExpr)(type)) {
      type = import_minato.Type.isType(type) ? type : import_minato.Type.fromTerm(type);
      const converter = this.driver.types[root && value && type.type === "json" ? "json" : type.type];
      const ancestor = this.driver.database.types[type.type]?.type;
      let res = this.load(value, ancestor ? import_minato.Type.fromField(ancestor) : void 0, root);
      res = this.transform(res, type, "load");
      res = converter?.load ? converter.load(res) : res;
      res = import_minato.Type.transform(res, type, (value2, type2) => this.load(value2, type2, false));
      return !(0, import_cosmokit.isNullable)(res) && type.inner && !import_minato.Type.isArray(type) ? (0, import_minato.unravel)(res) : res;
    }
    const result = {};
    for (const key in value) {
      if (!(key in type.fields))
        continue;
      result[key] = value[key];
      let subroot = root;
      if (subroot && result[key] && this.isEncoded(key)) {
        subroot = false;
        result[key] = this.driver.types["json"].load(result[key]);
      }
      result[key] = this.load(result[key], type.fields[key].type, subroot);
    }
    return type.parse(result);
  }
  /**
   * Convert value from Type to SQL.
   */
  escape(value, type) {
    type &&= import_minato.Type.fromField(type);
    return this.escapePrimitive(type ? this.dump(value, type) : value, type);
  }
  /**
   * Convert value from Field.Type to SQL.
   */
  escapePrimitive(value, type) {
    if ((0, import_cosmokit.isNullable)(value))
      return "NULL";
    switch (typeof value) {
      case "boolean":
      case "number":
      case "bigint":
        return value + "";
      case "object":
        return this.quote(JSON.stringify(value));
      default:
        return this.quote(value);
    }
  }
  escapeId(value) {
    return escapeId(value);
  }
  escapeKey(value) {
    return `"${value}"`;
  }
  quote(value) {
    this.escapeRegExp ??= new RegExp(`[${Object.values(this.escapeMap).join("")}]`, "g");
    let chunkIndex = this.escapeRegExp.lastIndex = 0;
    let escapedVal = "";
    let match;
    while (match = this.escapeRegExp.exec(value)) {
      escapedVal += value.slice(chunkIndex, match.index) + this.escapeMap[match[0]];
      chunkIndex = this.escapeRegExp.lastIndex;
    }
    if (chunkIndex === 0) {
      return "'" + value + "'";
    }
    if (chunkIndex < value.length) {
      return "'" + escapedVal + value.slice(chunkIndex) + "'";
    }
    return "'" + escapedVal + "'";
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Builder,
  escapeId,
  isBracketed,
  isSqlJson
});
//# sourceMappingURL=index.cjs.map
