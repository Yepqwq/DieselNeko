import { Dict } from 'cosmokit';
import { Driver, Eval, Field, Model, Modifier, Query, RegExpLike, Selection, Type } from 'minato';
export function escapeId(value: string): string;
export function isBracketed(value: string): boolean;
export function isSqlJson(type?: Type): boolean;
export type QueryOperators = {
    [K in keyof Query.FieldExpr]?: (key: string, value: NonNullable<Query.FieldExpr[K]>) => string;
};
export type ExtractUnary<T> = T extends [infer U] ? U : T;
export type EvalOperators = {
    [K in keyof Eval.Static as `$${K}`]?: (expr: ExtractUnary<Parameters<Eval.Static[K]>>) => string;
} & {
    $: (expr: any) => string;
};
declare interface Transformer<S = any, T = any> {
    encode?(value: string): string;
    decode?(value: string): string;
    load?(value: S | null): T | null;
    dump?(value: T | null): S | null;
}
declare interface State {
    table?: string;
    encoded?: boolean;
    encodedMap?: Dict<boolean>;
    expr?: Eval.Expr;
    group?: boolean;
    tables?: Dict<Model>;
    innerTables?: Dict<Model>;
    refFields?: Dict<string>;
    refTables?: Dict<Model>;
    wrappedSubquery?: boolean;
}
export class Builder {
    protected driver: Driver;
    protected escapeMap: {};
    protected escapeRegExp?: RegExp;
    protected createEqualQuery: (key: string, value: any) => string;
    protected queryOperators: QueryOperators;
    protected evalOperators: EvalOperators;
    protected state: State;
    protected $true: string;
    protected $false: string;
    protected modifiedTable?: string;
    protected transformers: Dict<Transformer>;
    constructor(driver: Driver, tables?: Dict<Model>);
    protected createNullQuery(key: string, value: boolean): string;
    protected createMemberQuery(key: string, value: any, notStr?: string): string;
    protected createRegExpQuery(key: string, value: string | RegExpLike): string;
    protected createElementQuery(key: string, value: any): string;
    protected isJsonQuery(key: string): boolean | undefined;
    protected comparator(operator: string): (key: string, value: any) => string;
    protected binary(operator: string): ([left, right]: [any, any]) => string;
    protected logicalAnd(conditions: string[]): string;
    protected logicalOr(conditions: string[]): string;
    protected logicalNot(condition: string): string;
    protected parseSelection(sel: Selection, inline?: boolean): string;
    protected jsonLength(value: string): string;
    protected jsonContains(obj: string, value: string): string;
    protected asEncoded(value: string, encoded: boolean | undefined): string;
    protected encode(value: string, encoded: boolean, pure?: boolean, type?: Type): string;
    protected isEncoded(key?: string): boolean | undefined;
    protected createAggr(expr: any, aggr: (value: string) => string, nonaggr?: (value: string) => string): string;
    /**
     * Convert value from SQL field to JSON field
     */
    protected transform(value: string, type: Type | Eval.Expr | undefined, method: 'encode' | 'decode' | 'load' | 'dump', miss?: any): any;
    protected groupObject(_fields: any): string;
    protected groupArray(value: string): string;
    protected parseFieldQuery(key: string, query: Query.Field): string;
    parseQuery(query: Query.Expr): string;
    protected parseEvalExpr(expr: any): any;
    protected transformJsonField(obj: string, path: string): string;
    protected transformKey(key: string, fields: Field.Config, prefix: string): string;
    protected getRecursive(args: string | string[]): any;
    parseEval(expr: any, unquote?: boolean): string;
    protected saveState(extra?: Partial<State>): () => void;
    suffix(modifier: Modifier): string;
    get(sel: Selection.Immutable, inline?: boolean, group?: boolean, addref?: boolean): any;
    /**
     * Convert value from Type to Field.Type.
     * @param root indicate whether the context is inside json
     */
    dump(value: any, type: Model | Type | Eval.Expr | undefined, root?: boolean): any;
    /**
     * Convert value from Field.Type to Type.
     */
    load(value: any, type: Model | Type | Eval.Expr | undefined, root?: boolean): any;
    /**
     * Convert value from Type to SQL.
     */
    escape(value: any, type?: Field | Field.Type | Type): string;
    /**
     * Convert value from Field.Type to SQL.
     */
    escapePrimitive(value: any, type?: Type): string;
    escapeId(value: string): string;
    escapeKey(value: string): string;
    quote(value: string): string;
}
