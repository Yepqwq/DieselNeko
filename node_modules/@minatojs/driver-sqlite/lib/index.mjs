var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// src/index.ts
import { Binary as Binary2, deepEqual, difference, isNullable as isNullable2, makeArray, mapValues } from "cosmokit";
import { Driver as Driver2, Eval, executeUpdate, Field as Field2, getCell, hasSubquery, isEvalExpr, z } from "minato";
import { escapeId as escapeId2 } from "@minatojs/sql-utils";
import { resolve } from "node:path";
import { readFile, writeFile } from "node:fs/promises";
import { createRequire } from "node:module";
import init from "@minatojs/sql.js";

// src/locales/en-US.yml
var en_US_default = { path: "Database path." };

// src/locales/zh-CN.yml
var zh_CN_default = { path: "数据库路径。" };

// src/builder.ts
import { Builder, escapeId } from "@minatojs/sql-utils";
import { Binary, isNullable } from "cosmokit";
import { Field, randomId, Type } from "minato";
var SQLiteBuilder = class extends Builder {
  constructor(driver, tables) {
    super(driver, tables);
    this.driver = driver;
    this.queryOperators.$regexFor = (key, value) => typeof value === "string" ? `${this.escape(value)} regexp ${key}` : value.flags?.includes("i") ? `regexp2(${key}, ${this.escape(value.input)}, 'i')` : `${this.escape(value.input)} regexp ${key}`;
    this.evalOperators.$if = (args) => `iif(${args.map((arg) => this.parseEval(arg)).join(", ")})`;
    this.evalOperators.$regex = ([key, value, flags]) => flags?.includes("i") || value instanceof RegExp && value.flags?.includes("i") ? `regexp2(${this.parseEval(value)}, ${this.parseEval(key)}, ${this.escape(flags ?? value.flags)})` : `regexp(${this.parseEval(value)}, ${this.parseEval(key)})`;
    this.evalOperators.$concat = (args) => `(${args.map((arg) => this.parseEval(arg)).join("||")})`;
    this.evalOperators.$modulo = ([left, right]) => `modulo(${this.parseEval(left)}, ${this.parseEval(right)})`;
    this.evalOperators.$log = ([left, right]) => isNullable(right) ? `log(${this.parseEval(left)})` : `log(${this.parseEval(left)}) / log(${this.parseEval(right)})`;
    this.evalOperators.$length = (expr) => this.createAggr(expr, (value) => `count(${value})`, (value) => this.isEncoded() ? this.jsonLength(value) : this.asEncoded(`iif(${value}, LENGTH(${value}) - LENGTH(REPLACE(${value}, ${this.escape(",")}, ${this.escape("")})) + 1, 0)`, false));
    this.evalOperators.$number = (arg) => {
      const type = Type.fromTerm(arg);
      const value = this.parseEval(arg);
      const res = Field.date.includes(type.type) ? `cast(${value} / 1000 as integer)` : `cast(${this.parseEval(arg)} as double)`;
      return this.asEncoded(`ifnull(${res}, 0)`, false);
    };
    const binaryXor = /* @__PURE__ */ __name((left, right) => `((${left} & ~${right}) | (~${left} & ${right}))`, "binaryXor");
    this.evalOperators.$xor = (args) => {
      const type = Type.fromTerm(this.state.expr, Type.Boolean);
      if (Field.boolean.includes(type.type))
        return args.map((arg) => this.parseEval(arg)).reduce((prev, curr) => `(${prev} != ${curr})`);
      else
        return args.map((arg) => this.parseEval(arg)).reduce((prev, curr) => binaryXor(prev, curr));
    };
    this.transformers["bigint"] = {
      encode: (value) => `cast(${value} as text)`,
      decode: (value) => `cast(${value} as integer)`,
      load: (value) => isNullable(value) ? value : BigInt(value),
      dump: (value) => isNullable(value) ? value : `${value}`
    };
    this.transformers["binary"] = {
      encode: (value) => `hex(${value})`,
      decode: (value) => `unhex(${value})`,
      load: (value) => isNullable(value) || typeof value === "object" ? value : Binary.fromHex(value),
      dump: (value) => isNullable(value) || typeof value === "string" ? value : Binary.toHex(value)
    };
  }
  static {
    __name(this, "SQLiteBuilder");
  }
  escapeMap = {
    "'": "''"
  };
  escapePrimitive(value, type) {
    if (value instanceof Date)
      value = +value;
    else if (value instanceof RegExp)
      value = value.source;
    else if (Binary.is(value))
      return `X'${Binary.toHex(value)}'`;
    else if (Binary.isSource(value))
      return `X'${Binary.toHex(Binary.fromSource(value))}'`;
    return super.escapePrimitive(value, type);
  }
  createElementQuery(key, value) {
    if (this.isJsonQuery(key)) {
      return this.jsonContains(key, this.escape(value, "json"));
    } else {
      return `(',' || ${key} || ',') LIKE ${this.escape("%," + value + ",%")}`;
    }
  }
  createRegExpQuery(key, value) {
    if (typeof value !== "string" && value.flags?.includes("i")) {
      return `regexp2(${this.escape(typeof value === "string" ? value : value.source)}, ${key}, ${this.escape(value.flags)})`;
    } else {
      return `regexp(${this.escape(typeof value === "string" ? value : value.source)}, ${key})`;
    }
  }
  jsonLength(value) {
    return this.asEncoded(`json_array_length(${value})`, false);
  }
  jsonContains(obj, value) {
    return this.asEncoded(`json_array_contains(${obj}, ${value})`, false);
  }
  encode(value, encoded, pure = false, type) {
    return encoded ? super.encode(value, encoded, pure, type) : encoded === this.isEncoded() && !pure ? value : this.asEncoded(this.transform(`(${value} ->> '$')`, type, "decode"), pure ? void 0 : false);
  }
  createAggr(expr, aggr, nonaggr) {
    if (!this.state.group && !nonaggr) {
      const value = this.parseEval(expr, false);
      return `(select ${aggr(escapeId("value"))} from json_each(${value}) ${randomId()})`;
    } else {
      return super.createAggr(expr, aggr, nonaggr);
    }
  }
  groupArray(value) {
    const res = this.isEncoded() ? `('[' || group_concat(${value}) || ']')` : `('[' || group_concat(json_quote(${value})) || ']')`;
    return this.asEncoded(`ifnull(${res}, json_array())`, true);
  }
  transformJsonField(obj, path) {
    return this.asEncoded(`(${obj} -> '$${path}')`, true);
  }
};

// src/index.ts
import { pathToFileURL } from "node:url";
function getTypeDef({ deftype: type }) {
  switch (type) {
    case "primary":
    case "boolean":
    case "integer":
    case "unsigned":
    case "bigint":
    case "date":
    case "time":
    case "timestamp":
      return `INTEGER`;
    case "float":
    case "double":
    case "decimal":
      return `REAL`;
    case "char":
    case "string":
    case "text":
    case "list":
    case "json":
      return `TEXT`;
    case "binary":
      return `BLOB`;
    default:
      throw new Error(`unsupported type: ${type}`);
  }
}
__name(getTypeDef, "getTypeDef");
var SQLiteDriver = class extends Driver2 {
  static name = "sqlite";
  path;
  db;
  sql = new SQLiteBuilder(this);
  beforeUnload;
  _transactionTask;
  /** synchronize table schema */
  async prepare(table, dropKeys) {
    const columns = this._all(`PRAGMA table_info(${escapeId2(table)})`);
    const model = this.model(table);
    const columnDefs = [];
    const indexDefs = [];
    const alter = [];
    const mapping = {};
    let shouldMigrate = false;
    for (const key in model.fields) {
      if (!Field2.available(model.fields[key])) {
        if (dropKeys?.includes(key))
          shouldMigrate = true;
        continue;
      }
      const legacy = [key, ...model.fields[key].legacy || []];
      const column = columns.find(({ name }) => legacy.includes(name));
      const { initial, nullable = true } = model.fields[key];
      const typedef = getTypeDef(model.fields[key]);
      let def = `${escapeId2(key)} ${typedef}`;
      if (key === model.primary && model.autoInc) {
        def += " NOT NULL PRIMARY KEY AUTOINCREMENT";
      } else {
        def += (nullable ? " " : " NOT ") + "NULL";
        if (!isNullable2(initial)) {
          def += " DEFAULT " + this.sql.escape(this.sql.dump({ [key]: initial }, model)[key]);
        }
      }
      columnDefs.push(def);
      if (!column) {
        alter.push("ADD " + def);
      } else {
        mapping[column.name] = key;
        shouldMigrate ||= column.name !== key || column.type !== typedef;
      }
    }
    if (model.primary && !model.autoInc) {
      indexDefs.push(`PRIMARY KEY (${this._joinKeys(makeArray(model.primary))})`);
    }
    if (model.unique) {
      indexDefs.push(...model.unique.map((keys) => `UNIQUE (${this._joinKeys(makeArray(keys))})`));
    }
    if (model.foreign) {
      indexDefs.push(...Object.entries(model.foreign).map(([key, value]) => {
        const [table2, key2] = value;
        return `FOREIGN KEY (\`${key}\`) REFERENCES ${escapeId2(table2)} (\`${key2}\`)`;
      }));
    }
    if (!columns.length) {
      this.logger.info("auto creating table %c", table);
      this._run(`CREATE TABLE ${escapeId2(table)} (${[...columnDefs, ...indexDefs].join(", ")})`);
    } else if (shouldMigrate) {
      for (const { name, type, notnull, pk, dflt_value: value } of columns) {
        if (mapping[name] || dropKeys?.includes(name))
          continue;
        let def = `${escapeId2(name)} ${type}`;
        def += (notnull ? " NOT " : " ") + "NULL";
        if (pk)
          def += " PRIMARY KEY";
        if (value !== null)
          def += " DEFAULT " + this.sql.escape(value);
        columnDefs.push(def);
        mapping[name] = name;
      }
      const temp = table + "_temp";
      const fields = Object.keys(mapping).map(escapeId2).join(", ");
      this.logger.info("auto migrating table %c", table);
      this._run(`CREATE TABLE ${escapeId2(temp)} (${[...columnDefs, ...indexDefs].join(", ")})`);
      try {
        this._run(`INSERT INTO ${escapeId2(temp)} SELECT ${fields} FROM ${escapeId2(table)}`);
        this._run(`DROP TABLE ${escapeId2(table)}`);
      } catch (error) {
        this._run(`DROP TABLE ${escapeId2(temp)}`);
        throw error;
      }
      this._run(`ALTER TABLE ${escapeId2(temp)} RENAME TO ${escapeId2(table)}`);
    } else if (alter.length) {
      this.logger.info("auto updating table %c", table);
      for (const def of alter) {
        this._run(`ALTER TABLE ${escapeId2(table)} ${def}`);
      }
    }
    if (dropKeys)
      return;
    dropKeys = [];
    await this.migrate(table, {
      error: this.logger.warn,
      before: (keys) => keys.every((key) => columns.some(({ name }) => name === key)),
      after: (keys) => dropKeys.push(...keys),
      finalize: () => {
        if (!dropKeys.length)
          return;
        this.prepare(table, dropKeys);
      }
    });
  }
  async start() {
    this.path = this.config.path;
    if (this.path !== ":memory:") {
      this.path = resolve(this.ctx.baseDir, this.path);
    }
    const isBrowser = process.env.KOISHI_ENV === "browser";
    const sqlite = await init({
      locateFile: (file) => process.env.KOISHI_BASE ? process.env.KOISHI_BASE + "/" + file : isBrowser ? "/modules/@koishijs/plugin-database-sqlite/" + file : createRequire(import.meta.url || pathToFileURL(__filename).href).resolve("@minatojs/sql.js/dist/" + file)
    });
    if (!isBrowser || this.path === ":memory:") {
      this.db = new sqlite.Database(this.path);
    } else {
      const buffer = await readFile(this.path).catch(() => null);
      this.db = new sqlite.Database(this.path, buffer);
      if (isBrowser) {
        window.addEventListener("beforeunload", this.beforeUnload = () => {
          this._export();
        });
      }
    }
    this.db.create_function("regexp", (pattern, str) => +new RegExp(pattern).test(str));
    this.db.create_function("regexp2", (pattern, str, flags) => +new RegExp(pattern, flags).test(str));
    this.db.create_function("json_array_contains", (array, value) => +JSON.parse(array).includes(JSON.parse(value)));
    this.db.create_function("modulo", (left, right) => left % right);
    this.db.create_function("rand", () => Math.random());
    this.define({
      types: ["boolean"],
      dump: (value) => isNullable2(value) ? value : +value,
      load: (value) => isNullable2(value) ? value : !!value
    });
    this.define({
      types: ["json"],
      dump: (value) => JSON.stringify(value),
      load: (value) => typeof value === "string" ? JSON.parse(value) : value
    });
    this.define({
      types: ["list"],
      dump: (value) => Array.isArray(value) ? value.join(",") : value,
      load: (value) => value ? value.split(",") : []
    });
    this.define({
      types: ["date", "time", "timestamp"],
      dump: (value) => isNullable2(value) ? value : +new Date(value),
      load: (value) => isNullable2(value) ? value : new Date(Number(value))
    });
    this.define({
      types: ["binary"],
      dump: (value) => isNullable2(value) ? value : new Uint8Array(value),
      load: (value) => isNullable2(value) ? value : Binary2.fromSource(value)
    });
    this.define({
      types: Field2.number,
      dump: (value) => value,
      load: (value) => isNullable2(value) ? value : Number(value)
    });
  }
  _joinKeys(keys) {
    return keys?.length ? keys.map((key) => `\`${key}\``).join(", ") : "*";
  }
  async stop() {
    await new Promise((resolve2) => setTimeout(resolve2, 0));
    this.db?.close();
    if (this.beforeUnload) {
      this.beforeUnload();
      window.removeEventListener("beforeunload", this.beforeUnload);
    }
  }
  _exec(sql, params, callback) {
    try {
      const stmt = this.db.prepare(sql);
      const result = callback(stmt);
      stmt.free();
      this.logger.debug("> %s", sql, params);
      return result;
    } catch (e) {
      this.logger.warn("> %s", sql, params);
      throw e;
    }
  }
  _all(sql, params = [], config) {
    return this._exec(sql, params, (stmt) => {
      stmt.bind(params);
      const result = [];
      while (stmt.step()) {
        result.push(stmt.getAsObject(null, config));
      }
      return result;
    });
  }
  _get(sql, params = [], config) {
    return this._exec(sql, params, (stmt) => stmt.getAsObject(params, config));
  }
  _export() {
    const data = this.db.export();
    return writeFile(this.path, data);
  }
  _run(sql, params = [], callback) {
    this._exec(sql, params, (stmt) => stmt.run(params));
    const result = callback?.();
    return result;
  }
  async drop(table) {
    this._run(`DROP TABLE ${escapeId2(table)}`);
  }
  async dropAll() {
    const tables = Object.keys(this.database.tables);
    for (const table of tables) {
      this._run(`DROP TABLE ${escapeId2(table)}`);
    }
  }
  async stats() {
    const stats = { size: this.db.size(), tables: {} };
    const tableNames = this._all('SELECT name FROM sqlite_master WHERE type="table" ORDER BY name;');
    const dbstats = this._all('SELECT name, pgsize as size FROM "dbstat" WHERE aggregate=TRUE;');
    tableNames.forEach((tbl) => {
      stats.tables[tbl.name] = this._get(`SELECT COUNT(*) as count FROM ${escapeId2(tbl.name)};`);
      stats.tables[tbl.name].size = dbstats.find((o) => o.name === tbl.name).size;
    });
    return stats;
  }
  async remove(sel) {
    const { query, table, tables } = sel;
    const builder = new SQLiteBuilder(this, tables);
    const filter = builder.parseQuery(query);
    if (filter === "0")
      return {};
    const result = this._run(`DELETE FROM ${escapeId2(table)} WHERE ${filter}`, [], () => this._get(`SELECT changes() AS count`));
    return { matched: result.count, removed: result.count };
  }
  async get(sel) {
    const { model, tables } = sel;
    const builder = new SQLiteBuilder(this, tables);
    const sql = builder.get(sel);
    if (!sql)
      return [];
    const rows = this._all(sql, [], { useBigInt: true });
    return rows.map((row) => builder.load(row, model));
  }
  async eval(sel, expr) {
    const builder = new SQLiteBuilder(this, sel.tables);
    const inner = builder.get(sel.table, true, true);
    const output = builder.parseEval(expr, false);
    const { value } = this._get(`SELECT ${output} AS value FROM ${inner}`, [], { useBigInt: true });
    return builder.load(value, expr);
  }
  _update(sel, indexFields, updateFields, update, data) {
    const { ref, table, tables, model } = sel;
    const builder = new SQLiteBuilder(this, tables);
    executeUpdate(data, update, ref);
    const row = builder.dump(data, model);
    const assignment = updateFields.map((key) => `${escapeId2(key)} = ?`).join(",");
    const query = Object.fromEntries(indexFields.map((key) => [key, row[key]]));
    const filter = builder.parseQuery(query);
    this._run(`UPDATE ${escapeId2(table)} SET ${assignment} WHERE ${filter}`, updateFields.map((key) => row[key] ?? null));
  }
  async set(sel, update) {
    const { model, table, query } = sel;
    const { primary } = model, fields = model.avaiableFields();
    const updateFields = [...new Set(Object.keys(update).map((key) => {
      return Object.keys(fields).find((field) => field === key || key.startsWith(field + "."));
    }))];
    const primaryFields = makeArray(primary);
    if (query.$expr || hasSubquery(sel.query) || Object.values(update).some((x) => hasSubquery(x))) {
      const sel2 = this.database.select(table, query);
      sel2.tables[sel.ref] = sel2.tables[sel2.ref];
      delete sel2.tables[sel2.ref];
      sel2.ref = sel.ref;
      const project = mapValues(update, (value, key) => () => isEvalExpr(value) ? value : Eval.literal(value, model.getType(key)));
      const rawUpsert = await sel2.project({
        ...project,
        // do not touch sel2.row since it is not patched
        ...Object.fromEntries(primaryFields.map((x) => [x, () => Eval("", [sel.ref, x], sel2.model.getType(x))]))
      }).execute();
      const upsert = rawUpsert.map((row) => ({
        ...mapValues(update, (_, key) => getCell(row, key)),
        ...Object.fromEntries(primaryFields.map((x) => [x, getCell(row, x)]))
      }));
      return this.database.upsert(table, upsert);
    } else {
      const data = await this.database.get(table, query);
      for (const row of data) {
        this._update(sel, primaryFields, updateFields, update, row);
      }
      return { matched: data.length };
    }
  }
  _create(table, data) {
    const model = this.model(table);
    data = this.sql.dump(data, model);
    const keys = Object.keys(data);
    const sql = `INSERT INTO ${escapeId2(table)} (${this._joinKeys(keys)}) VALUES (${Array(keys.length).fill("?").join(", ")})`;
    return this._run(sql, keys.map((key) => data[key] ?? null), () => this._get(`SELECT last_insert_rowid() AS id`));
  }
  async create(sel, data) {
    const { model, table } = sel;
    const { id } = this._create(table, data);
    const { autoInc, primary } = model;
    if (!autoInc || Array.isArray(primary))
      return data;
    return { ...data, [primary]: id };
  }
  async upsert(sel, data, keys) {
    if (!data.length)
      return {};
    const { model, table, ref } = sel;
    const fields = model.avaiableFields();
    const result = { inserted: 0, matched: 0, modified: 0 };
    const dataFields = [...new Set(Object.keys(Object.assign({}, ...data)).map((key) => {
      return Object.keys(fields).find((field) => field === key || key.startsWith(field + "."));
    }))];
    let updateFields = difference(dataFields, keys);
    if (!updateFields.length)
      updateFields = [dataFields[0]];
    const step = Math.floor(960 / keys.length);
    for (let i = 0; i < data.length; i += step) {
      const chunk = data.slice(i, i + step);
      const results = await this.database.get(table, {
        $or: chunk.map((item) => Object.fromEntries(keys.map((key) => [key, item[key]])))
      });
      for (const item of chunk) {
        const row = results.find((row2) => {
          row2 = model.format(row2);
          return keys.every((key) => deepEqual(row2[key], item[key], true));
        });
        if (row) {
          this._update(sel, keys, updateFields, item, row);
          result.matched++;
        } else {
          this._create(table, executeUpdate(model.create(), item, ref));
          result.inserted++;
        }
      }
    }
    return result;
  }
  async withTransaction(callback) {
    if (this._transactionTask)
      await this._transactionTask.catch(() => {
      });
    return this._transactionTask = new Promise((resolve2, reject) => {
      this._run("BEGIN TRANSACTION");
      callback().then(
        () => resolve2(this._run("COMMIT")),
        (e) => (this._run("ROLLBACK"), reject(e))
      );
    });
  }
};
((SQLiteDriver2) => {
  SQLiteDriver2.Config = z.object({
    path: z.string().role("path").required()
  }).i18n({
    "en-US": en_US_default,
    "zh-CN": zh_CN_default
  });
})(SQLiteDriver || (SQLiteDriver = {}));
var src_default = SQLiteDriver;
export {
  SQLiteDriver,
  src_default as default
};
//# sourceMappingURL=index.mjs.map
