"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCoreMachineId = void 0;
const node_child_process_1 = require("node:child_process");
const node_crypto_1 = require("node:crypto");
const node_path_1 = require("node:path");
const node_process_1 = require("node:process");
const fs_1 = require("../fs");
const promises_1 = require("node:fs/promises");
const regexWin32 = /MachineGuid.*?REG_SZ.*?([\d\-a-f]+)/;
const getCoreMachineIdForWin32 = async (ctx) => {
    const l = ctx.logger('telemetry/utils/id/cmid');
    let reg = 'REG';
    const regPath = (0, node_path_1.join)(node_process_1.env['windir'], 'System32/reg.exe');
    if (await (0, fs_1.exists)(regPath))
        reg = regPath;
    const child = (0, node_child_process_1.spawn)(reg, ['query', 'HKLM\\SOFTWARE\\Microsoft\\Cryptography', '/v', 'MachineGuid'], {
        shell: false,
    });
    let stdout = '';
    child.stdout.on('data', (x) => (stdout += x));
    await new Promise((resolve, reject) => {
        child.on('close', (x) => {
            if (x)
                reject(new Error(`reg query failed with code ${x}`));
            else
                resolve();
        });
    });
    const rawCMId = regexWin32.exec(stdout)?.[1];
    if (!rawCMId) {
        l.debug(`full stdout:\n${stdout}\n`);
        throw new Error('cannot get raw cmid');
    }
    return rawCMId;
};
const regexMacos = /IOPlatformUUID.*?([\d\-A-F]+)/;
const getCoreMachineIdForMacos = async (ctx) => {
    const l = ctx.logger('telemetry/utils/id/cmid');
    const child = (0, node_child_process_1.spawn)('ioreg', ['-rd1', '-c', 'IOPlatformExpertDevice'], {
        shell: false,
    });
    let stdout = '';
    child.stdout.on('data', (x) => (stdout += x));
    await new Promise((resolve, reject) => {
        child.on('close', (x) => {
            if (x)
                reject(new Error(`ioreg query failed with code ${x}`));
            else
                resolve();
        });
    });
    let rawCMId = regexMacos.exec(stdout)?.[1];
    if (!rawCMId) {
        l.debug(`full stdout:\n${stdout}\n`);
        throw new Error('cannot get raw cmid');
    }
    rawCMId = rawCMId.toLowerCase();
    return rawCMId;
};
const linuxPathList = ['/etc/machine-id', '/var/lib/dbus/machine-id'];
const getCoreMachineIdForLinux = async (ctx) => {
    const l = ctx.logger('telemetry/utils/id/cmid');
    let path = undefined;
    for (const p of linuxPathList)
        if (await (0, fs_1.exists)(p)) {
            path = p;
            break;
        }
    if (!path)
        throw new Error('cannot query cmid. maybe distrib too old?');
    try {
        return (await (0, promises_1.readFile)(path)).toString().trim();
    }
    catch (e) {
        l.debug('cause:');
        l.debug(e);
        throw new Error('read cmid failed.');
    }
};
const getCoreMachineId = async (ctx) => {
    const l = ctx.logger('telemetry/utils/id/cmid');
    let rawCMId;
    switch (node_process_1.platform) {
        case 'win32': {
            rawCMId = await getCoreMachineIdForWin32(ctx);
            break;
        }
        case 'darwin': {
            rawCMId = await getCoreMachineIdForMacos(ctx);
            break;
        }
        case 'linux': {
            rawCMId = await getCoreMachineIdForLinux(ctx);
            break;
        }
        default:
            throw new Error(`unsupported platform ${node_process_1.platform}`);
    }
    l.debug(`raw cmid: ${rawCMId}`);
    const cmid = (0, node_crypto_1.createHash)('sha256').update(rawCMId).digest('hex');
    l.debug(`cmid: ${cmid}`);
    return cmid;
};
exports.getCoreMachineId = getCoreMachineId;
