"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TelemetryStorage = void 0;
const promises_1 = require("node:fs/promises");
const node_path_1 = require("node:path");
const node_process_1 = require("node:process");
const client_1 = require("../client");
const fs_1 = require("../utils/fs");
const id_1 = require("./id");
const defaultTelemetryData = {
    nonoob: false,
    privacy: 0,
    readAlerts: [],
};
class TelemetryStorage {
    ctx;
    basis;
    constructor(ctx, basis) {
        this.ctx = ctx;
        this.basis = basis;
        this.#l = ctx.logger('telemetry/storage');
        this.root = basis.root;
        this.privacyReady = new Promise((res) => {
            this.commitPrivacyReady = res;
        });
        void this.init();
    }
    #l;
    init = async () => {
        await (0, promises_1.mkdir)((0, node_path_1.join)((0, node_process_1.cwd)(), 'data'), {
            recursive: true,
        });
        // Load storage
        if (!(await (0, fs_1.exists)(this.storagePath))) {
            this.data = structuredClone(defaultTelemetryData);
            await (0, promises_1.writeFile)(this.storagePath, JSON.stringify(this.data));
        }
        else {
            this.data = JSON.parse((await (0, promises_1.readFile)(this.storagePath)).toString());
        }
        if (!this.data.nonoob) {
            this.#oob(this.basis.post);
            this.data.nonoob = true;
            await this.save();
            this.ctx.logger('telemetry').success(`
欢迎使用 Koishi！
telemetry 服务是一组可选的 Koishi 服务，旨在通过分析您的 Koishi 使用情况来改善 Koishi 的使用体验、提供精确的插件使用量数据，并仅在您需要时为您提供支持。
拒绝同意将影响我们提供的相关数据和功能，但不会影响 Koishi 的基础功能。
要了解更多信息，请打开 Koishi 控制台并参阅我们的隐私政策。在您点击「同意」前，telemetry 服务不会启动。
`);
        }
        // OOB. Pop OOB client.
        if (!this.data.privacy)
            this.ctx.plugin(client_1.TelemetryOobClient, this);
        if (!(await this.basis.whenReady())) {
            this.#l.debug('basis whenReady failed');
            return;
        }
        this.commitPrivacy = async () => {
            this.data.privacy = this.basis.hello.privacyVer;
            await this.save();
            this.commitPrivacyReady();
        };
        if (this.data.privacy)
            if (this.data.privacy < this.basis.hello.privacyVer)
                // Privacy updated. Pop OOB client.
                this.ctx.plugin(client_1.TelemetryOobClient, this);
            // Stored privacy ver equals remote. Directly commit privacy.
            else
                this.commitPrivacyReady();
        await this.privacyReady;
        this.ctx.plugin(id_1.TelemetryId, this);
    };
    privacyReady = undefined;
    commitPrivacyReady = undefined;
    storagePath = (0, node_path_1.join)((0, node_process_1.cwd)(), 'data/telemetry.json');
    data = undefined;
    root;
    save = async () => {
        await (0, promises_1.writeFile)(this.storagePath, JSON.stringify(this.data));
    };
    commitPrivacy = async () => { };
    saveBundleId = async (bundleId) => {
        this.data.bundleId = bundleId;
        return this.save();
    };
    saveInstanceId = async (instanceId) => {
        this.data.instanceId = instanceId;
        return this.save();
    };
    #oob = (post) => {
        void post('/oob', {}).catch(() => this.#l.debug('oob failed'));
    };
}
exports.TelemetryStorage = TelemetryStorage;
