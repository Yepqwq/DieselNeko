"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.apply = exports.Sentences = exports.Config = exports.name = void 0;
const path_1 = require("path");
const koishi_1 = require("koishi");
exports.name = 'sentences';
exports.Config = koishi_1.Schema.object({});
class Sentences extends koishi_1.Service {
    s = {};
    constructor(ctx) {
        super(ctx, 'sentences', true);
        this.s = {
            a: require('../data/a.json'),
            b: require('../data/b.json'),
            c: require('../data/c.json'),
            d: require('../data/d.json'),
            e: require('../data/e.json'),
            f: require('../data/f.json'),
            g: require('../data/g.json'),
            h: require('../data/h.json'),
            i: require('../data/i.json'),
            j: require('../data/j.json'),
            k: require('../data/k.json'),
            l: require('../data/l.json'),
        };
    }
    getSentence(params) {
        const types = params?.c && params.c.length ? params.c : Object.keys(this.s);
        const type = types[Math.floor(Math.random() * types.length)];
        if (!(params?.min_length && params?.max_length)) {
            return this.s[type][Math.floor(Math.random() * this.s[type].length)];
        }
        const sentences = this.s[type].filter((s) => {
            if (params?.min_length && s.length < params.min_length)
                return false;
            if (params?.max_length && s.length > params.max_length)
                return false;
            return true;
        });
        return sentences[Math.floor(Math.random() * sentences.length)];
    }
}
exports.Sentences = Sentences;
function apply(ctx) {
    ctx.plugin(Sentences);
    ctx.inject(['console'], (ctx) => {
        ctx.console.addEntry({
            dev: (0, path_1.resolve)(__dirname, '../client/index.ts'),
            prod: (0, path_1.resolve)(__dirname, '../dist'),
        });
    });
}
exports.apply = apply;
