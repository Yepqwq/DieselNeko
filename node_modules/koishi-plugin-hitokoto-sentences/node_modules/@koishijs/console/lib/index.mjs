var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// src/index.ts
import { Service as Service2, valueMap } from "koishi";

// src/service.ts
import { Service } from "koishi";
var DataService = class extends Service {
  constructor(ctx, key, options = {}) {
    super(ctx, `console.services.${key}`, options.immediate);
    this.ctx = ctx;
    this.key = key;
    this.options = options;
  }
  static {
    __name(this, "DataService");
  }
  static filter = false;
  static inject = ["console"];
  async get(forced, client) {
    return null;
  }
  start() {
    this.refresh();
  }
  async refresh(forced = true) {
    this.ctx.get("console")?.broadcast("data", async (client) => ({
      key: this.key,
      value: await this.get(forced, client)
    }), this.options);
  }
  patch(value) {
    this.ctx.get("console")?.broadcast("patch", {
      key: this.key,
      value
    }, this.options);
  }
};

// src/schema.ts
var SchemaProvider = class extends DataService {
  static {
    __name(this, "SchemaProvider");
  }
  constructor(ctx) {
    super(ctx, "schema", { immediate: true });
    ctx.on("internal/schema", () => this.refresh());
  }
  async get() {
    return this.ctx.schema._data;
  }
};

// src/permission.ts
var PermissionProvider = class extends DataService {
  static {
    __name(this, "PermissionProvider");
  }
  constructor(ctx) {
    super(ctx, "permissions", { immediate: true });
    ctx.on("internal/permission", () => this.refresh());
  }
  async get() {
    return this.ctx.permissions.list();
  }
};

// src/client.ts
import { coerce, Context as Context2, Logger, Random } from "koishi";
var logger = new Logger("console");
var Client = class {
  constructor(ctx, socket, request) {
    this.ctx = ctx;
    this.socket = socket;
    this.request = request;
    socket.addEventListener("message", this.receive);
    ctx.on("dispose", () => {
      socket.removeEventListener("message", this.receive);
    });
    this.refresh();
  }
  static {
    __name(this, "Client");
  }
  id = Random.id();
  send(payload) {
    this.socket.send(JSON.stringify(payload));
  }
  receive = async (data) => {
    const { type, args, id } = JSON.parse(data.data.toString());
    const listener = this.ctx.get("console").listeners[type];
    if (!listener) {
      logger.info("unknown message:", type, ...args);
      return this.send({ type: "response", body: { id, error: "not implemented" } });
    }
    if (await this.ctx.serial("console/intercept", this, listener)) {
      return this.send({ type: "response", body: { id, error: "unauthorized" } });
    }
    try {
      const value = await listener.callback.call(this, ...args);
      return this.send({ type: "response", body: { id, value } });
    } catch (e) {
      logger.debug(e);
      const error = coerce(e);
      return this.send({ type: "response", body: { id, error } });
    }
  };
  refresh() {
    Object.keys(this.ctx.root[Context2.internal]).forEach(async (name) => {
      if (!name.startsWith("console.services."))
        return;
      const key = name.slice(17);
      const service = this.ctx.get(name);
      if (!service)
        return;
      if (await this.ctx.serial("console/intercept", this, service.options)) {
        return this.send({ type: "data", body: { key, value: null } });
      }
      try {
        const value = await service.get(false, this);
        if (!value)
          return;
        this.send({ type: "data", body: { key, value } });
      } catch (error) {
        logger.warn(error);
      }
    });
  }
};

// src/entry.ts
var Entry = class {
  constructor(ctx, files, data) {
    this.ctx = ctx;
    this.files = files;
    this.data = data;
    ctx.console.entries[this.id] = this;
    ctx.console.refresh("entry");
    this.dispose = ctx.collect("entry", () => {
      delete this.ctx.console.entries[this.id];
      ctx.console.refresh("entry");
    });
  }
  static {
    __name(this, "Entry");
  }
  id = Math.random().toString(36).slice(2);
  dispose;
  refresh() {
    this.ctx.console.broadcast("entry-data", async (client) => ({
      id: this.id,
      data: await this.data(client)
    }));
  }
};

// src/index.ts
var EntryProvider = class extends DataService {
  static {
    __name(this, "EntryProvider");
  }
  static inject = [];
  constructor(ctx) {
    super(ctx, "entry", { immediate: true });
  }
  async get(forced, client) {
    return this.ctx.get("console").get(client);
  }
};
var Console = class extends Service2 {
  constructor(ctx) {
    super(ctx, "console", true);
    this.ctx = ctx;
    ctx.plugin(EntryProvider);
    ctx.plugin(SchemaProvider);
    ctx.plugin(PermissionProvider);
    this.addListener("ping", () => "pong");
  }
  static {
    __name(this, "Console");
  }
  static filter = false;
  static inject = { optional: ["console"] };
  id = Math.random().toString(36).slice(2);
  entries = /* @__PURE__ */ Object.create(null);
  listeners = /* @__PURE__ */ Object.create(null);
  clients = /* @__PURE__ */ Object.create(null);
  services = new Proxy({}, {
    get: (target, key, receiver) => {
      if (typeof key === "symbol")
        return Reflect.get(target, key, receiver);
      return this.ctx.get(`console.services.${key}`);
    },
    set: (target, key, value, receiver) => {
      return false;
    }
  });
  accept(socket, request) {
    const client = new Client(this.ctx, socket, request);
    socket.addEventListener("close", () => {
      delete this.clients[client.id];
      this.ctx.emit("console/connection", client);
    });
    this.clients[client.id] = client;
    this.ctx.emit("console/connection", client);
  }
  async get(client) {
    const result = valueMap(this.entries, ({ files, ctx, data }, key) => ({
      files: this.resolveEntry(files, key),
      paths: this.ctx.get("loader")?.paths(ctx.scope),
      data: data?.(client)
    }));
    result["_id"] = this.id;
    return result;
  }
  addEntry(files, data) {
    return new Entry(this.ctx, files, data);
  }
  addListener(event, callback, options) {
    this.listeners[event] = { callback, ...options };
  }
  async broadcast(type, body, options = {}) {
    const handles = Object.values(this.clients);
    if (!handles.length)
      return;
    await Promise.all(Object.values(this.clients).map(async (client) => {
      if (await this.ctx.serial("console/intercept", client, options))
        return;
      const data = { type, body };
      if (typeof body === "function")
        data.body = await body(client);
      client.socket.send(JSON.stringify(data));
    }));
  }
  refresh(type) {
    return this.ctx.get(`console.services.${type}`)?.refresh();
  }
  patch(type, value) {
    return this.ctx.get(`console.services.${type}`)?.patch(value);
  }
};
var src_default = Console;
export {
  Client,
  Console,
  DataService,
  Entry,
  EntryProvider,
  src_default as default
};
//# sourceMappingURL=index.mjs.map
